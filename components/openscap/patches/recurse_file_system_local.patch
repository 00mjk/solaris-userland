This patch fixes the issue with recursing directories when local is specified
on solaris. It no longer traverses remote and pseudo file systems like proc,
etc.

This patch has not been contributed upstream, but is planned to be done by
 2013-Jul-12.

--- openscap-0.9.5/src/OVAL/probes/oval_fts.c.~1~	2013-01-14 05:21:10.139830956 -0800
+++ openscap-0.9.5/src/OVAL/probes/oval_fts.c	2013-02-27 14:12:10.322103381 -0800
@@ -44,11 +44,11 @@
 #include "oval_fts.h"
 #if defined(__SVR4) && defined(__sun)
 #include "fts_sun.h"
+#include <sys/mntent.h>
 #else
 #include <fts.h>
 #endif
 
-#undef OSCAP_FTS_DEBUG
 
 static OVAL_FTS *OVAL_FTS_new()
 {
@@ -130,14 +130,73 @@
 	return;
 }
 
+#if defined(__SVR4) && defined(__sun)
+#ifndef MNTTYPE_SMB
+#define MNTTYPE_SMB	"smb"
+#endif
+#ifndef MNTTYPE_PROC
+#define MNTTYPE_PROC	"proc"
+#endif
+
+static bool valid_remote_fs(char *fstype)
+{
+	if (strcmp(fstype, MNTTYPE_NFS) == 0 ||
+	    strcmp(fstype, MNTTYPE_SMBFS) == 0 ||
+	    strcmp(fstype, MNTTYPE_SMB) == 0)
+		return (true);
+	return (false);
+}
+
+static bool valid_local_fs(char *fstype)
+{
+	if (strcmp(fstype, MNTTYPE_SWAP) == 0 ||
+	    strcmp(fstype, MNTTYPE_MNTFS) == 0 ||
+	    strcmp(fstype, MNTTYPE_CTFS) == 0 ||
+	    strcmp(fstype, MNTTYPE_OBJFS) == 0 ||
+	    strcmp(fstype, MNTTYPE_SHAREFS) == 0 ||
+	    strcmp(fstype, MNTTYPE_PROC) == 0 ||
+	    strcmp(fstype, MNTTYPE_LOFS) == 0 ||
+	    strcmp(fstype, MNTTYPE_AUTOFS) == 0)
+		return (false);
+	return (true);
+}
+#endif
+
 static bool OVAL_FTS_localp(OVAL_FTS *ofts, const char *path, void *id)
 {
+#if defined(__SVR4) && defined(__sun)
+	if (id != NULL && (*(char*)id) != '\0') {
+		/* if not a valid local fs skip */
+		if (valid_local_fs((char*)id)) {
+			/* if recurse is local , skip remote fs */
+			if (ofts->filesystem == OVAL_RECURSE_FS_LOCAL) {
+				return (!valid_remote_fs((char*)id));
+			}
+			return (true);
+		}
+		return (false);
+	} else if (path != NULL) {
+		/* id was not set, because fts_read failed to stat the node */
+		struct stat sb;
+		if ((stat(path, &sb) == 0) && (valid_local_fs(sb.st_fstype))) {
+			/* if recurse is local , skip remote fs */
+			if (ofts->filesystem == OVAL_RECURSE_FS_LOCAL) {
+				return (!valid_remote_fs(sb.st_fstype));
+			}
+			return (true);
+		}
+		return (false);
+	} else {
+		return (false);
+	}
+#else	
 	if (id != NULL)
 		return (fsdev_search(ofts->localdevs, id) == 1 ? true : false);
 	else if (path != NULL)
 		return (fsdev_path(ofts->localdevs, path) == 1 ? true : false);
 	else
 		return (false);
+#endif
 }
 
 static char *__regex_locate(char *str)
@@ -695,6 +754,9 @@
 	}
 
 	if (filesystem == OVAL_RECURSE_FS_LOCAL) {
+#if   defined(__SVR4) && defined(__sun)
+		ofts->localdevs = NULL;
+#else
 		ofts->localdevs = fsdev_init(NULL, 0);
 		if (ofts->localdevs == NULL) {
 			dE("fsdev_init() failed.\n");
@@ -705,6 +767,7 @@
 			oval_fts_close(ofts);
 			return (NULL);
 		}
+#endif
 	} else if (filesystem == OVAL_RECURSE_FS_DEFINED) {
 		/* store the device id for future comparison */
 		FTSENT *fts_ent;
@@ -745,7 +808,6 @@
 		fts_ent = fts_read(ofts->ofts_match_path_fts);
 		if (fts_ent == NULL)
 			return NULL;
-
 		switch (fts_ent->fts_info) {
 		case FTS_DP:
 			continue;
@@ -769,13 +831,21 @@
 			fts_set(ofts->ofts_match_path_fts, fts_ent, FTS_FOLLOW);
 			continue;
 		}
-
+#if   defined(__SVR4) && defined(__sun)
+		/* pseudo filesystems will be skipped */
+		/* don't recurse into remote fs if local is specified */
+		if ((fts_ent->fts_info == FTS_D || fts_ent->fts_info == FTS_SL)
+		    && (!OVAL_FTS_localp(ofts, fts_ent->fts_path,
+		    (fts_ent->fts_statp != NULL) ?
+		    &fts_ent->fts_statp->st_fstype : NULL))) {
+#else
 		/* don't recurse into non-local filesystems */
 		if (ofts->filesystem == OVAL_RECURSE_FS_LOCAL
 		    && (fts_ent->fts_info == FTS_D || fts_ent->fts_info == FTS_SL)
 		    && (!OVAL_FTS_localp(ofts, fts_ent->fts_path,
 					 (fts_ent->fts_statp != NULL) ?
 					 &fts_ent->fts_statp->st_dev : NULL))) {
+#endif
 			dI("Don't recurse into non-local filesystems, skipping '%s'.\n", fts_ent->fts_path);
 			fts_set(ofts->ofts_recurse_path_fts, fts_ent, FTS_SKIP);
 			continue;
@@ -964,6 +1034,15 @@
 					continue;
 				}
 			}
+#if   defined(__SVR4) && defined(__sun)
+			/* pseudo filesystems will be skipped */
+			/* don't recurse into remote fs if local is specified */
+			if ((fts_ent->fts_info == FTS_D ||
+			    fts_ent->fts_info == FTS_SL)
+                            && (!OVAL_FTS_localp(ofts, fts_ent->fts_path,
+			    (fts_ent->fts_statp != NULL) ?
+			    &fts_ent->fts_statp->st_fstype : NULL))) {
+#else
 
 			/* don't recurse into non-local filesystems */
 			if (ofts->filesystem == OVAL_RECURSE_FS_LOCAL
@@ -971,6 +1050,7 @@
 			    && (!OVAL_FTS_localp(ofts, fts_ent->fts_path,
 					(fts_ent->fts_statp != NULL) ?
 					&fts_ent->fts_statp->st_dev : NULL))) {
+#endif
 				fts_set(ofts->ofts_recurse_path_fts, fts_ent, FTS_SKIP);
 				continue;
 			}
@@ -1039,12 +1119,18 @@
 				if (ofts->ofts_recurse_path_curdepth == 0)
 					ofts->ofts_recurse_path_devid = fts_ent->fts_statp->st_dev;
 				*/
-
+#if   defined(__SVR4) && defined(__sun)
+				if ((!OVAL_FTS_localp(ofts, fts_ent->fts_path,
+				    (fts_ent->fts_statp != NULL) ?
+				    &fts_ent->fts_statp->st_fstype : NULL)))
+				       break;
+#else
 				if (ofts->filesystem == OVAL_RECURSE_FS_LOCAL
 				    && (!OVAL_FTS_localp(ofts, fts_ent->fts_path,
 						(fts_ent->fts_statp != NULL) ?
 						&fts_ent->fts_statp->st_dev : NULL)))
 					break;
+#endif
 				if (ofts->filesystem == OVAL_RECURSE_FS_DEFINED
 				    && ofts->ofts_recurse_path_devid != fts_ent->fts_statp->st_dev)
 					break;
--- openscap-0.9.5/src/OVAL/fts_sun.c.~1~	2012-11-06 05:51:31.668229747 -0800
+++ openscap-0.9.5/src/OVAL/fts_sun.c	2013-02-27 11:32:47.333961072 -0800
@@ -1022,6 +1022,10 @@
 	p->fts_instr = FTS_NOINSTR;
 	p->fts_number = 0;
 	p->fts_pointer = NULL;
+#if	defined(__SVR4) && defined(__sun)
+	if (!ISSET(FTS_NOSTAT))
+		p->fts_statp->st_fstype[0] = '\0';
+#endif
 	return (p);
 }
 
