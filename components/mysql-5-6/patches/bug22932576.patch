Developed in-house, not fed back.
Solaris-specific
stlport is no longer supported/maintained, so we had to switch to std=c++03
For Sun Studio we must build with -std=c++03 flag
Since Sun Studio depends on seeing __attribute__ ((__weakref__)) in order to generate correct code.
Introduced MY_ATTRIBUTE:  sed -i -e 's/__attribute__/MY_ATTRIBUTE/g' `cat <all srouce files>`

--- a/client/mysql.cc
+++ b/client/mysql.cc
@@ -1819,7 +1819,7 @@ static void usage(int version)
 
 
 my_bool
-get_one_option(int optid, const struct my_option *opt __attribute__((unused)),
+get_one_option(int optid, const struct my_option *opt MY_ATTRIBUTE((unused)),
 	       char *argument)
 {
   switch(optid) {
@@ -2755,8 +2755,8 @@ static void initialize_readline (char *name)
 */
 
 static char **new_mysql_completion(const char *text,
-                                   int start __attribute__((unused)),
-                                   int end __attribute__((unused)))
+                                   int start MY_ATTRIBUTE((unused)),
+                                   int end MY_ATTRIBUTE((unused)))
 {
   if (!status.batch && !quick)
 #if defined(USE_NEW_READLINE_INTERFACE)
@@ -3166,8 +3166,8 @@ static void print_help_item(MYSQL_ROW *cur, int num_name, int num_cat, char *las
 }
 
 
-static int com_server_help(String *buffer __attribute__((unused)),
-			   char *line __attribute__((unused)), char *help_arg)
+static int com_server_help(String *buffer MY_ATTRIBUTE((unused)),
+			   char *line MY_ATTRIBUTE((unused)), char *help_arg)
 {
   MYSQL_ROW cur;
   const char *server_cmd;
@@ -3273,8 +3273,8 @@ err:
 }
 
 static int
-com_help(String *buffer __attribute__((unused)),
-	 char *line __attribute__((unused)))
+com_help(String *buffer MY_ATTRIBUTE((unused)),
+	 char *line MY_ATTRIBUTE((unused)))
 {
   reg1 int i, j;
   char * help_arg= strchr(line,' '), buff[32], *end;
@@ -3313,7 +3313,7 @@ com_help(String *buffer __attribute__((unused)),
 
 	/* ARGSUSED */
 static int
-com_clear(String *buffer,char *line __attribute__((unused)))
+com_clear(String *buffer,char *line MY_ATTRIBUTE((unused)))
 {
 #ifdef HAVE_READLINE
   if (status.add_to_history)
@@ -3325,7 +3325,7 @@ com_clear(String *buffer,char *line __attribute__((unused)))
 
 	/* ARGSUSED */
 static int
-com_charset(String *buffer __attribute__((unused)), char *line)
+com_charset(String *buffer MY_ATTRIBUTE((unused)), char *line)
 {
   char buff[256], *param;
   const CHARSET_INFO *new_cs;
@@ -3357,7 +3357,7 @@ com_charset(String *buffer __attribute__((unused)), char *line)
 
 
 static int
-com_go(String *buffer,char *line __attribute__((unused)))
+com_go(String *buffer,char *line MY_ATTRIBUTE((unused)))
 {
   char		buff[200]; /* about 110 chars used so far */
   char		time_buff[52+3+1]; /* time max + space&parens + NUL */
@@ -4118,8 +4118,8 @@ print_tab_data(MYSQL_RES *result)
 }
 
 static int
-com_tee(String *buffer __attribute__((unused)),
-        char *line __attribute__((unused)))
+com_tee(String *buffer MY_ATTRIBUTE((unused)),
+        char *line MY_ATTRIBUTE((unused)))
 {
   char file_name[FN_REFLEN], *end, *param;
 
@@ -4161,8 +4161,8 @@ com_tee(String *buffer __attribute__((unused)),
 
 
 static int
-com_notee(String *buffer __attribute__((unused)),
-	  char *line __attribute__((unused)))
+com_notee(String *buffer MY_ATTRIBUTE((unused)),
+	  char *line MY_ATTRIBUTE((unused)))
 {
   if (opt_outfile)
     end_tee();
@@ -4176,8 +4176,8 @@ com_notee(String *buffer __attribute__((unused)),
 
 #ifdef USE_POPEN
 static int
-com_pager(String *buffer __attribute__((unused)),
-          char *line __attribute__((unused)))
+com_pager(String *buffer MY_ATTRIBUTE((unused)),
+          char *line MY_ATTRIBUTE((unused)))
 {
   char pager_name[FN_REFLEN], *end, *param;
 
@@ -4220,8 +4220,8 @@ com_pager(String *buffer __attribute__((unused)),
 
 
 static int
-com_nopager(String *buffer __attribute__((unused)),
-	    char *line __attribute__((unused)))
+com_nopager(String *buffer MY_ATTRIBUTE((unused)),
+	    char *line MY_ATTRIBUTE((unused)))
 {
   strmov(pager, "stdout");
   opt_nopager=1;
@@ -4238,7 +4238,7 @@ com_nopager(String *buffer __attribute__((unused)),
 
 #ifdef USE_POPEN
 static int
-com_edit(String *buffer,char *line __attribute__((unused)))
+com_edit(String *buffer,char *line MY_ATTRIBUTE((unused)))
 {
   char	filename[FN_REFLEN],buff[160];
   int	fd,tmp;
@@ -4282,16 +4282,16 @@ err:
 /* If arg is given, exit without errors. This happens on command 'quit' */
 
 static int
-com_quit(String *buffer __attribute__((unused)),
-	 char *line __attribute__((unused)))
+com_quit(String *buffer MY_ATTRIBUTE((unused)),
+	 char *line MY_ATTRIBUTE((unused)))
 {
   status.exit_status=0;
   return 1;
 }
 
 static int
-com_rehash(String *buffer __attribute__((unused)),
-	 char *line __attribute__((unused)))
+com_rehash(String *buffer MY_ATTRIBUTE((unused)),
+	 char *line MY_ATTRIBUTE((unused)))
 {
 #ifdef HAVE_READLINE
   build_completion_hash(1, 0);
@@ -4302,8 +4302,8 @@ com_rehash(String *buffer __attribute__((unused)),
 
 #ifdef USE_POPEN
 static int
-com_shell(String *buffer __attribute__((unused)),
-          char *line __attribute__((unused)))
+com_shell(String *buffer MY_ATTRIBUTE((unused)),
+          char *line MY_ATTRIBUTE((unused)))
 {
   char *shell_cmd;
 
@@ -4330,7 +4330,7 @@ com_shell(String *buffer __attribute__((unused)),
 
 
 static int
-com_print(String *buffer,char *line __attribute__((unused)))
+com_print(String *buffer,char *line MY_ATTRIBUTE((unused)))
 {
   tee_puts("--------------", stdout);
   (void) tee_fputs(buffer->c_ptr(), stdout);
@@ -4395,7 +4395,7 @@ com_connect(String *buffer, char *line)
 }
 
 
-static int com_source(String *buffer __attribute__((unused)),
+static int com_source(String *buffer MY_ATTRIBUTE((unused)),
                       char *line)
 {
   char source_name[FN_REFLEN], *end, *param;
@@ -4450,7 +4450,7 @@ static int com_source(String *buffer __attribute__((unused)),
 
 	/* ARGSUSED */
 static int
-com_delimiter(String *buffer __attribute__((unused)), char *line)
+com_delimiter(String *buffer MY_ATTRIBUTE((unused)), char *line)
 {
   char buff[256], *tmp;
 
@@ -4479,7 +4479,7 @@ com_delimiter(String *buffer __attribute__((unused)), char *line)
 
 	/* ARGSUSED */
 static int
-com_use(String *buffer __attribute__((unused)), char *line)
+com_use(String *buffer MY_ATTRIBUTE((unused)), char *line)
 {
   char *tmp, buff[FN_REFLEN + 1];
   int select_db;
@@ -4624,8 +4624,8 @@ normalize_dbname(const char *line, char *buff, uint buff_size)
 }
 
 static int
-com_warnings(String *buffer __attribute__((unused)),
-   char *line __attribute__((unused)))
+com_warnings(String *buffer MY_ATTRIBUTE((unused)),
+   char *line MY_ATTRIBUTE((unused)))
 {
   show_warnings = 1;
   put_info("Show warnings enabled.",INFO_INFO);
@@ -4633,8 +4633,8 @@ com_warnings(String *buffer __attribute__((unused)),
 }
 
 static int
-com_nowarnings(String *buffer __attribute__((unused)),
-   char *line __attribute__((unused)))
+com_nowarnings(String *buffer MY_ATTRIBUTE((unused)),
+   char *line MY_ATTRIBUTE((unused)))
 {
   show_warnings = 0;
   put_info("Show warnings disabled.",INFO_INFO);
@@ -4914,8 +4914,8 @@ sql_connect(char *host,char *database,char *user,char *password,uint silent)
 
 
 static int
-com_status(String *buffer __attribute__((unused)),
-	   char *line __attribute__((unused)))
+com_status(String *buffer MY_ATTRIBUTE((unused)),
+	   char *line MY_ATTRIBUTE((unused)))
 {
   const char *status_str;
   char buff[40];
@@ -5555,7 +5555,7 @@ static void init_username()
   }
 }
 
-static int com_prompt(String *buffer __attribute__((unused)),
+static int com_prompt(String *buffer MY_ATTRIBUTE((unused)),
                       char *line)
 {
   char *ptr=strchr(line, ' ');
--- a/client/mysql_config_editor.cc
+++ b/client/mysql_config_editor.cc
@@ -1,5 +1,5 @@
 /*
-   Copyright (c) 2012, 2015, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -209,7 +209,7 @@ static struct my_option my_help_command_options[]=
 
 my_bool
 my_program_get_one_option(int optid,
-                          const struct my_option *opt __attribute__((unused)),
+                          const struct my_option *opt MY_ATTRIBUTE((unused)),
                           char *argument)
 {
   switch(optid) {
@@ -230,7 +230,7 @@ my_program_get_one_option(int optid,
 
 my_bool
 my_set_command_get_one_option(int optid,
-                              const struct my_option *opt __attribute__((unused)),
+                              const struct my_option *opt MY_ATTRIBUTE((unused)),
                               char *argument)
 {
   switch(optid) {
@@ -257,7 +257,7 @@ my_set_command_get_one_option(int optid,
 
 my_bool
 my_remove_command_get_one_option(int optid,
-                                 const struct my_option *opt __attribute__((unused)),
+                                 const struct my_option *opt MY_ATTRIBUTE((unused)),
                                  char *argument)
 {
   switch(optid) {
@@ -281,7 +281,7 @@ my_remove_command_get_one_option(int optid,
 
 my_bool
 my_print_command_get_one_option(int optid,
-                                const struct my_option *opt __attribute__((unused)),
+                                const struct my_option *opt MY_ATTRIBUTE((unused)),
                                 char *argument)
 {
   switch(optid) {
@@ -305,7 +305,7 @@ my_print_command_get_one_option(int optid,
 
 my_bool
 my_reset_command_get_one_option(int optid,
-                                const struct my_option *opt __attribute__((unused)),
+                                const struct my_option *opt MY_ATTRIBUTE((unused)),
                                 char *argument)
 {
   switch(optid) {
--- a/client/mysql_plugin.c
+++ b/client/mysql_plugin.c
@@ -1,5 +1,5 @@
 /*
-   Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -406,7 +406,7 @@ exit:
 static void usage(void)
 {
   PRINT_VERSION;
-  puts("Copyright (c) 2011, 2015, Oracle and/or its affiliates. "
+  puts("Copyright (c) 2011, 2016, Oracle and/or its affiliates. "
        "All rights reserved.\n");
   puts("Enable or disable plugins.");
   printf("\nUsage: %s [options] <plugin> ENABLE|DISABLE\n\nOptions:\n",
@@ -471,7 +471,7 @@ static void print_default_values(void)
 
 static my_bool
 get_one_option(int optid,
-               const struct my_option *opt __attribute__((unused)),
+               const struct my_option *opt MY_ATTRIBUTE((unused)),
                char *argument)
 {
   switch(optid) {
--- a/client/mysqladmin.cc
+++ b/client/mysqladmin.cc
@@ -237,7 +237,7 @@ static struct my_option my_long_options[] =
 static const char *load_default_groups[]= { "mysqladmin","client",0 };
 
 my_bool
-get_one_option(int optid, const struct my_option *opt __attribute__((unused)),
+get_one_option(int optid, const struct my_option *opt MY_ATTRIBUTE((unused)),
 	       char *argument)
 {
   int error = 0;
@@ -528,7 +528,7 @@ int main(int argc,char *argv[])
 }
 
 
-sig_handler endprog(int signal_number __attribute__((unused)))
+sig_handler endprog(int signal_number MY_ATTRIBUTE((unused)))
 {
   interrupted=1;
 }
@@ -1416,7 +1416,7 @@ static void print_top(MYSQL_RES *result)
 
 /* 3.rd argument, uint row, is not in use. Don't remove! */
 static void print_row(MYSQL_RES *result, MYSQL_ROW cur,
-		      uint row __attribute__((unused)))
+		      uint row MY_ATTRIBUTE((unused)))
 {
   uint i,length;
   MYSQL_FIELD *field;
@@ -1451,9 +1451,9 @@ static void print_relative_row(MYSQL_RES *result, MYSQL_ROW cur, uint row)
 }
 
 
-static void print_relative_row_vert(MYSQL_RES *result __attribute__((unused)),
+static void print_relative_row_vert(MYSQL_RES *result MY_ATTRIBUTE((unused)),
 				    MYSQL_ROW cur,
-				    uint row __attribute__((unused)))
+				    uint row MY_ATTRIBUTE((unused)))
 {
   uint length;
   ulonglong tmp;
--- a/client/mysqlbinlog.cc
+++ b/client/mysqlbinlog.cc
@@ -1,5 +1,5 @@
 /*
-   Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -1819,7 +1819,7 @@ static my_time_t convert_str_to_timestamp(const char* str)
 
 
 extern "C" my_bool
-get_one_option(int optid, const struct my_option *opt __attribute__((unused)),
+get_one_option(int optid, const struct my_option *opt MY_ATTRIBUTE((unused)),
 	       char *argument)
 {
   bool tty_password=0;
--- a/client/mysqlcheck.c
+++ b/client/mysqlcheck.c
@@ -270,7 +270,7 @@ static void usage(void)
 
 
 static my_bool
-get_one_option(int optid, const struct my_option *opt __attribute__((unused)),
+get_one_option(int optid, const struct my_option *opt MY_ATTRIBUTE((unused)),
 	       char *argument)
 {
   int orig_what_to_do= what_to_do;
--- a/client/mysqldump.c
+++ b/client/mysqldump.c
@@ -762,7 +762,7 @@ static void write_footer(FILE *sql_file)
 
 
 uchar* get_table_key(const char *entry, size_t *length,
-                     my_bool not_used __attribute__((unused)))
+                     my_bool not_used MY_ATTRIBUTE((unused)))
 {
   *length= strlen(entry);
   return (uchar*) entry;
@@ -770,7 +770,7 @@ uchar* get_table_key(const char *entry, size_t *length,
 
 
 static my_bool
-get_one_option(int optid, const struct my_option *opt __attribute__((unused)),
+get_one_option(int optid, const struct my_option *opt MY_ATTRIBUTE((unused)),
                char *argument)
 {
   switch (optid) {
@@ -1921,7 +1921,7 @@ static void print_xml_row(FILE *xml_file, const char *row_name,
                           const char *str_create)
 {
   uint i;
-  my_bool body_found __attribute__((unused)) = 0;
+  my_bool body_found MY_ATTRIBUTE((unused)) = 0;
   char *create_stmt_ptr= NULL;
   ulong create_stmt_len= 0;
   MYSQL_FIELD *field;
@@ -4281,7 +4281,7 @@ RETURN VALUES
   0        Success.
   1        Failure.
 */
-int init_dumping_views(char *qdatabase __attribute__((unused)))
+int init_dumping_views(char *qdatabase MY_ATTRIBUTE((unused)))
 {
     return 0;
 } /* init_dumping_views */
--- a/client/mysqlimport.c
+++ b/client/mysqlimport.c
@@ -222,7 +222,7 @@ file. The SQL command 'LOAD DATA INFILE' is used to import the rows.\n");
 
 
 static my_bool
-get_one_option(int optid, const struct my_option *opt __attribute__((unused)),
+get_one_option(int optid, const struct my_option *opt MY_ATTRIBUTE((unused)),
 	       char *argument)
 {
   switch(optid) {
--- a/client/mysqlshow.c
+++ b/client/mysqlshow.c
@@ -314,7 +314,7 @@ are shown.");
 
 
 static my_bool
-get_one_option(int optid, const struct my_option *opt __attribute__((unused)),
+get_one_option(int optid, const struct my_option *opt MY_ATTRIBUTE((unused)),
 	       char *argument)
 {
   switch(optid) {
--- a/client/mysqlslap.c
+++ b/client/mysqlslap.c
@@ -736,7 +736,7 @@ static void usage(void)
 
 
 static my_bool
-get_one_option(int optid, const struct my_option *opt __attribute__((unused)),
+get_one_option(int optid, const struct my_option *opt MY_ATTRIBUTE((unused)),
                char *argument)
 {
   DBUG_ENTER("get_one_option");
--- a/client/mysqltest.cc
+++ b/client/mysqltest.cc
@@ -547,12 +547,12 @@ struct st_replace *glob_replace= 0;
 void replace_strings_append(struct st_replace *rep, DYNAMIC_STRING* ds,
 const char *from, int len);
 
-static void cleanup_and_exit(int exit_code) __attribute__((noreturn));
+static void cleanup_and_exit(int exit_code) MY_ATTRIBUTE((noreturn));
 
 void die(const char *fmt, ...)
-  ATTRIBUTE_FORMAT(printf, 1, 2) __attribute__((noreturn));
+  ATTRIBUTE_FORMAT(printf, 1, 2) MY_ATTRIBUTE((noreturn));
 void abort_not_supported_test(const char *fmt, ...)
-  ATTRIBUTE_FORMAT(printf, 1, 2) __attribute__((noreturn));
+  ATTRIBUTE_FORMAT(printf, 1, 2) MY_ATTRIBUTE((noreturn));
 void verbose_msg(const char *fmt, ...)
   ATTRIBUTE_FORMAT(printf, 1, 2);
 void log_msg(const char *fmt, ...)
@@ -2121,7 +2121,7 @@ static void strip_parentheses(struct st_command *command)
 C_MODE_START
 
 static uchar *get_var_key(const uchar* var, size_t *len,
-                          my_bool __attribute__((unused)) t)
+                          my_bool MY_ATTRIBUTE((unused)) t)
 {
   register char* key;
   key = ((VAR*)var)->name;
@@ -4320,7 +4320,7 @@ int do_echo(struct st_command *command)
 }
 
 
-void do_wait_for_slave_to_stop(struct st_command *c __attribute__((unused)))
+void do_wait_for_slave_to_stop(struct st_command *c MY_ATTRIBUTE((unused)))
 {
   static int SLAVE_POLL_INTERVAL= 300000;
   MYSQL* mysql = &cur_con->mysql;
@@ -8418,7 +8418,7 @@ void update_expected_errors(struct st_command* command)
 
 */
 
-void mark_progress(struct st_command* command __attribute__((unused)),
+void mark_progress(struct st_command* command MY_ATTRIBUTE((unused)),
                    int line)
 {
   static ulonglong progress_start= 0; // < Beware
@@ -9465,7 +9465,7 @@ typedef struct st_replace_found {
 
 void replace_strings_append(REPLACE *rep, DYNAMIC_STRING* ds,
                             const char *str,
-                            int len __attribute__((unused)))
+                            int len MY_ATTRIBUTE((unused)))
 {
   reg1 REPLACE *rep_pos;
   reg2 REPLACE_STRING *rep_str;
--- a/cmake/build_configurations/compiler_options.cmake
+++ b/cmake/build_configurations/compiler_options.cmake
@@ -1,4 +1,4 @@
-# Copyright (c) 2012, 2014, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.
 # 
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
@@ -66,11 +66,9 @@ IF(UNIX)
       SET(SUNPRO_CXX_LIBRARY "stlport4" CACHE STRING
         "What C++ library to use. The server needs stlport4. It is possible to build the client libraries with -DWITHOUT_SERVER=1 -DSUNPRO_CXX_LIBRARY=Cstd")
 
-      MESSAGE(STATUS "SUNPRO_CXX_LIBRARY ${SUNPRO_CXX_LIBRARY}")
-
       IF(CMAKE_SYSTEM_PROCESSOR MATCHES "i386")
         SET(COMMON_C_FLAGS                   "-g -mt -fsimple=1 -ftrap=%none -nofstore -xbuiltin=%all -xlibmil -xlibmopt -xtarget=generic")
-        SET(COMMON_CXX_FLAGS                 "-g0 -mt -fsimple=1 -ftrap=%none -nofstore -xbuiltin=%all -xlibmil -xlibmopt -xtarget=generic -library=${SUNPRO_CXX_LIBRARY}")
+        SET(COMMON_CXX_FLAGS                 "-g0 -mt -fsimple=1 -ftrap=%none -nofstore -xbuiltin=%all -xlibmil -xlibmopt -xtarget=generic")
         # We have to specify "-xO1" for DEBUG flags here,
         # see http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6879978
         SET(CMAKE_C_FLAGS_DEBUG              "-xO1 ${COMMON_C_FLAGS}")
@@ -85,7 +83,7 @@ IF(UNIX)
       ELSE() 
         # Assume !x86 is SPARC
         SET(COMMON_C_FLAGS                 "-g -Xa -xstrconst -mt")
-        SET(COMMON_CXX_FLAGS               "-g0 -mt -library=${SUNPRO_CXX_LIBRARY}")
+        SET(COMMON_CXX_FLAGS               "-g0 -mt")
         IF(32BIT)
           SET(COMMON_C_FLAGS               "${COMMON_C_FLAGS} -xarch=sparc")
           SET(COMMON_CXX_FLAGS             "${COMMON_CXX_FLAGS} -xarch=sparc")

--- a/dbug/tests.c
+++ b/dbug/tests.c
@@ -73,7 +73,7 @@ int main (int argc, char *argv[])
             DBUG_EVALUATE_IF("evaluate_if", "ON", "OFF"));
     DBUG_EXECUTE_IF("pop",  DBUG_POP(); );
     {
-      char s[1000] __attribute__((unused));
+      char s[1000] MY_ATTRIBUTE((unused));
       DBUG_EXPLAIN(s, sizeof(s)-1);
       DBUG_PRINT("explain", ("dbug explained: %s", s));
     }
--- a/extra/comp_err.c
+++ b/extra/comp_err.c
@@ -1,5 +1,5 @@
 /*
-   Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -1023,8 +1023,8 @@ static void print_version(void)
 
 
 static my_bool
-get_one_option(int optid, const struct my_option *opt __attribute__ ((unused)),
-	       char *argument __attribute__ ((unused)))
+get_one_option(int optid, const struct my_option *opt MY_ATTRIBUTE ((unused)),
+	       char *argument MY_ATTRIBUTE ((unused)))
 {
   DBUG_ENTER("get_one_option");
   switch (optid) {
--- a/extra/innochecksum.cc
+++ b/extra/innochecksum.cc
@@ -1,5 +1,5 @@
 /*
-   Copyright (c) 2005, 2013, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2005, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -235,8 +235,8 @@ extern "C" my_bool
 innochecksum_get_one_option(
 /*========================*/
   int optid,
-  const struct my_option *opt __attribute__((unused)),
-  char *argument __attribute__((unused)))
+  const struct my_option *opt MY_ATTRIBUTE((unused)),
+  char *argument MY_ATTRIBUTE((unused)))
 {
   switch (optid) {
   case 'd':
--- a/extra/my_print_defaults.c
+++ b/extra/my_print_defaults.c
@@ -1,6 +1,6 @@
 
 /*
-   Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -118,8 +118,8 @@ static void usage(my_bool version)
 
 
 static my_bool
-get_one_option(int optid, const struct my_option *opt __attribute__((unused)),
-	       char *argument __attribute__((unused)))
+get_one_option(int optid, const struct my_option *opt MY_ATTRIBUTE((unused)),
+	       char *argument MY_ATTRIBUTE((unused)))
 {
   switch (optid) {
     case 'c':
--- a/extra/mysql_waitpid.c
+++ b/extra/mysql_waitpid.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2003, 2014, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2003, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -43,8 +43,8 @@ static struct my_option my_long_options[] =
 };
 
 static my_bool
-get_one_option(int optid, const struct my_option *opt __attribute__((unused)),
-	       char *argument __attribute__((unused)))
+get_one_option(int optid, const struct my_option *opt MY_ATTRIBUTE((unused)),
+	       char *argument MY_ATTRIBUTE((unused)))
 {
   switch(optid) {
   case 'V':
--- a/extra/perror.c
+++ b/extra/perror.c
@@ -1,5 +1,5 @@
 /*
-   Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -94,8 +94,8 @@ static void usage(void)
 
 
 static my_bool
-get_one_option(int optid, const struct my_option *opt __attribute__((unused)),
-	       char *argument __attribute__((unused)))
+get_one_option(int optid, const struct my_option *opt MY_ATTRIBUTE((unused)),
+	       char *argument MY_ATTRIBUTE((unused)))
 {
   switch (optid) {
   case 's':
--- a/extra/resolve_stack_dump.cc
+++ b/extra/resolve_stack_dump.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2001, 2015, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2001, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -51,7 +51,7 @@ static char* dump_fname = 0, *sym_fname = 0;
 static std::vector<sym_entry> sym_table;
 static FILE* fp_dump, *fp_sym = 0, *fp_out; 
 static void die(const char* fmt, ...)
-  __attribute__((noreturn)) __attribute__((format(printf, 1, 2)));
+  MY_ATTRIBUTE((noreturn)) MY_ATTRIBUTE((format(printf, 1, 2)));
 
 static struct my_option my_long_options[] =
 {
@@ -107,8 +107,8 @@ static void die(const char* fmt, ...)
 
 
 static my_bool
-get_one_option(int optid, const struct my_option *opt __attribute__((unused)),
-	       char *argument __attribute__((unused)))
+get_one_option(int optid, const struct my_option *opt MY_ATTRIBUTE((unused)),
+	       char *argument MY_ATTRIBUTE((unused)))
 {
   switch(optid) {
   case 'V':
--- a/extra/resolveip.c
+++ b/extra/resolveip.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2010, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -72,8 +72,8 @@ static void usage(void)
 
 
 static my_bool
-get_one_option(int optid, const struct my_option *opt __attribute__((unused)),
-	       char *argument __attribute__((unused)))
+get_one_option(int optid, const struct my_option *opt MY_ATTRIBUTE((unused)),
+	       char *argument MY_ATTRIBUTE((unused)))
 {
   switch (optid) {
   case 'V': print_version(); exit(0);
--- a/extra/yassl/taocrypt/CMakeLists.txt
+++ b/extra/yassl/taocrypt/CMakeLists.txt
@@ -1,4 +1,4 @@
-# Copyright (c) 2006, 2014, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2006, 2016, Oracle and/or its affiliates. All rights reserved.
 # 
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
@@ -13,6 +13,8 @@
 # along with this program; if not, write to the Free Software
 # Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 
+INCLUDE(${MYSQL_CMAKE_SCRIPT_DIR}/compile_flags.cmake)
+
 INCLUDE_DIRECTORIES(${CMAKE_SOURCE_DIR}/extra/yassl/taocrypt/mySTL
                     ${CMAKE_SOURCE_DIR}/extra/yassl/taocrypt/include)
 
@@ -29,6 +31,14 @@ SET(TAOCRYPT_SOURCES		src/aes.cpp src/aestables.cpp src/algebra.cpp src/arc4.cpp
 				include/random.hpp include/ripemd.hpp include/rsa.hpp include/sha.hpp
 				include/rabbit.hpp include/hc128.hpp)
 
+# Segfaults with SIGILL at high optimization levels in:
+# ModularArithmetic::SimultaneousExponentiate
+IF(CMAKE_CXX_COMPILER_ID MATCHES "SunPro")
+  IF(CMAKE_CXX_FLAGS MATCHES "-std=")
+    ADD_COMPILE_FLAGS(src/integer.cpp COMPILE_FLAGS "-xO1")
+  ENDIF()
+ENDIF()
+
 IF(HAVE_EXPLICIT_TEMPLATE_INSTANTIATION)
   SET(TAOCRYPT_SOURCES ${TAOCRYPT_SOURCES} src/template_instnt.cpp)
 ENDIF()
--- a/include/atomic/nolock.h
+++ b/include/atomic/nolock.h
@@ -1,7 +1,7 @@
 #ifndef ATOMIC_NOLOCK_INCLUDED
 #define ATOMIC_NOLOCK_INCLUDED
 
-/* Copyright (c) 2006, 2014, Oracle and/or its affiliates. All rights reserved. reserved.
+/* Copyright (c) 2006, 2016, Oracle and/or its affiliates. All rights reserved. reserved.
    reserved.
 
    This program is free software; you can redistribute it and/or modify
@@ -44,7 +44,7 @@
   Type not used so minimal size (emptry struct has different size between C
   and C++, zero-length array is gcc-specific).
 */
-typedef char my_atomic_rwlock_t __attribute__ ((unused));
+typedef char my_atomic_rwlock_t MY_ATTRIBUTE ((unused));
 #define my_atomic_rwlock_destroy(name)
 #define my_atomic_rwlock_init(name)
 #define my_atomic_rwlock_rdlock(name)
--- a/include/lf.h
+++ b/include/lf.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2007, 2015, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2007, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -138,7 +138,7 @@ typedef struct {
 #if defined(__GNUC__) && defined(MY_LF_EXTRA_DEBUG)
 #define LF_REQUIRE_PINS(N)                                      \
   static const char require_pins[LF_PINBOX_PINS-N]              \
-                             __attribute__ ((unused));          \
+                             MY_ATTRIBUTE ((unused));          \
   static const int LF_NUM_PINS_IN_THIS_FILE= N;
 #define _lf_pin(PINS, PIN, ADDR)                                \
   (                                                             \
--- a/include/m_ctype.h
+++ b/include/m_ctype.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -658,10 +658,10 @@ int my_wildcmp_mb_bin(const CHARSET_INFO *cs,
                       const char *wildstr,const char *wildend,
                       int escape, int w_one, int w_many);
 
-int my_strcasecmp_mb_bin(const CHARSET_INFO * cs __attribute__((unused)),
+int my_strcasecmp_mb_bin(const CHARSET_INFO * cs MY_ATTRIBUTE((unused)),
                          const char *s, const char *t);
 
-void my_hash_sort_mb_bin(const CHARSET_INFO *cs __attribute__((unused)),
+void my_hash_sort_mb_bin(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                          const uchar *key, size_t len,ulong *nr1, ulong *nr2);
 
 size_t my_strnxfrm_mb(const CHARSET_INFO *,
--- a/include/my_atomic.h
+++ b/include/my_atomic.h
@@ -1,7 +1,7 @@
 #ifndef MY_ATOMIC_INCLUDED
 #define MY_ATOMIC_INCLUDED
 
-/* Copyright (c) 2006, 2012, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2006, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -121,11 +121,11 @@
         typedef union {                                         \
           int  ## S  i;                                         \
           uint ## S  u;                                         \
-        } U_ ## S   __attribute__ ((transparent_union));        \
+        } U_ ## S   MY_ATTRIBUTE ((transparent_union));        \
         typedef union {                                         \
           int  ## S volatile *i;                                \
           uint ## S volatile *u;                                \
-        } Uv_ ## S   __attribute__ ((transparent_union));
+        } Uv_ ## S   MY_ATTRIBUTE ((transparent_union));
 #define uintptr intptr
 make_transparent_unions(8)
 make_transparent_unions(16)
--- a/include/my_attribute.h
+++ b/include/my_attribute.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2010, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -28,41 +28,30 @@
 #endif
 
 /*
-  Disable __attribute__() on gcc < 2.7, g++ < 3.4, and non-gcc compilers.
+  Disable MY_ATTRIBUTE() on g++ < 3.4, and non-gcc compilers.
   Some forms of __attribute__ are actually supported in earlier versions of
   g++, but we just disable them all because we only use them to generate
   compilation warnings.
 */
-#ifndef __attribute__
-# if !defined(__GNUC__)
-#  define __attribute__(A)
-# elif GCC_VERSION < 2008
-#  define __attribute__(A)
-# elif defined(__cplusplus) && GCC_VERSION < 3004
-#  define __attribute__(A)
-# endif
+#ifndef MY_ATTRIBUTE
+#if defined(__GNUC__) && GCC_VERSION > 3003
+#  define MY_ATTRIBUTE(A) __attribute__(A)
+#else
+#  define MY_ATTRIBUTE(A)
+#endif
 #endif
 
 /*
-  __attribute__((format(...))) is only supported in gcc >= 2.8 and g++ >= 3.4
-  But that's already covered by the __attribute__ tests above, so this is
+  __attribute__((format(...))) is only supported in g++ >= 3.4
+  But that's already covered by the MY_ATTRIBUTE tests above, so this is
   just a convenience macro.
 */
 #ifndef ATTRIBUTE_FORMAT
-# define ATTRIBUTE_FORMAT(style, m, n) __attribute__((format(style, m, n)))
+#  define ATTRIBUTE_FORMAT(style, m, n) MY_ATTRIBUTE((format(style, m, n)))
 #endif
 
-/*
-
-   __attribute__((format(...))) on a function pointer is not supported
-   until  gcc 3.1
-*/
 #ifndef ATTRIBUTE_FORMAT_FPTR
-# if (GCC_VERSION >= 3001)
 #  define ATTRIBUTE_FORMAT_FPTR(style, m, n) ATTRIBUTE_FORMAT(style, m, n)
-# else
-#  define ATTRIBUTE_FORMAT_FPTR(style, m, n)
-# endif /* GNUC >= 3.1 */
 #endif
 
 
--- a/include/my_global.h
+++ b/include/my_global.h
@@ -1,5 +1,5 @@
 /*
-   Copyright (c) 2001, 2013, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2001, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -184,7 +184,7 @@
   other reason to use them is for documentation
 */
 
-#if !defined(__GNUC__) || (__GNUC__ == 2 && __GNUC_MINOR__ < 96)
+#if !defined(__builtin_expect)
 #define __builtin_expect(x, expected_value) (x)
 #endif
 
@@ -374,7 +374,7 @@ C_MODE_END
 #define compile_time_assert(X)                                  \
   do                                                            \
   {                                                             \
-    typedef char compile_time_assert[(X) ? 1 : -1] __attribute__((unused)); \
+    typedef char compile_time_assert[(X) ? 1 : -1] MY_ATTRIBUTE((unused)); \
   } while(0)
 #endif
 
--- a/include/my_pthread.h
+++ b/include/my_pthread.h
@@ -860,7 +860,7 @@ struct st_my_thread_var
 #endif
 };
 
-extern struct st_my_thread_var *_my_thread_var(void) __attribute__ ((const));
+extern struct st_my_thread_var *_my_thread_var(void) MY_ATTRIBUTE ((const));
 extern int set_mysys_var(struct st_my_thread_var *mysys_var);
 extern void **my_thread_var_dbug();
 extern uint my_thread_end_wait_time;
--- a/include/mysql/psi/mysql_file.h
+++ b/include/mysql/psi/mysql_file.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
 
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
@@ -511,9 +511,9 @@ static inline void inline_mysql_file_register(
   PSI_file_info *info,
   int count
 #else
-  const char *category __attribute__ ((unused)),
-  void *info __attribute__ ((unused)),
-  int count __attribute__ ((unused))
+  const char *category MY_ATTRIBUTE ((unused)),
+  void *info MY_ATTRIBUTE ((unused)),
+  int count MY_ATTRIBUTE ((unused))
 #endif
 )
 {
--- a/include/mysql/psi/mysql_socket.h
+++ b/include/mysql/psi/mysql_socket.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010, 2012, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 
 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License as
@@ -114,9 +114,9 @@ mysql_socket_set_address(
   const struct sockaddr *addr,
   socklen_t addr_len
 #else
-  MYSQL_SOCKET socket __attribute__ ((unused)),
-  const struct sockaddr *addr __attribute__ ((unused)),
-  socklen_t addr_len __attribute__ ((unused))
+  MYSQL_SOCKET socket MY_ATTRIBUTE ((unused)),
+  const struct sockaddr *addr MY_ATTRIBUTE ((unused)),
+  socklen_t addr_len MY_ATTRIBUTE ((unused))
 #endif
 )
 {
@@ -136,7 +136,7 @@ mysql_socket_set_thread_owner(
 #ifdef HAVE_PSI_SOCKET_INTERFACE
 MYSQL_SOCKET socket
 #else
-MYSQL_SOCKET socket __attribute__ ((unused))
+MYSQL_SOCKET socket MY_ATTRIBUTE ((unused))
 #endif
 )
 {
--- a/include/mysql/psi/mysql_thread.h
+++ b/include/mysql/psi/mysql_thread.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
 
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
@@ -587,9 +587,9 @@ static inline void inline_mysql_mutex_register(
   PSI_mutex_info *info,
   int count
 #else
-  const char *category __attribute__ ((unused)),
-  void *info __attribute__ ((unused)),
-  int count __attribute__ ((unused))
+  const char *category MY_ATTRIBUTE ((unused)),
+  void *info MY_ATTRIBUTE ((unused)),
+  int count MY_ATTRIBUTE ((unused))
 #endif
 )
 {
@@ -771,9 +771,9 @@ static inline void inline_mysql_rwlock_register(
   PSI_rwlock_info *info,
   int count
 #else
-  const char *category __attribute__ ((unused)),
-  void *info __attribute__ ((unused)),
-  int count __attribute__ ((unused))
+  const char *category MY_ATTRIBUTE ((unused)),
+  void *info MY_ATTRIBUTE ((unused)),
+  int count MY_ATTRIBUTE ((unused))
 #endif
 )
 {
@@ -1089,9 +1089,9 @@ static inline void inline_mysql_cond_register(
   PSI_cond_info *info,
   int count
 #else
-  const char *category __attribute__ ((unused)),
-  void *info __attribute__ ((unused)),
-  int count __attribute__ ((unused))
+  const char *category MY_ATTRIBUTE ((unused)),
+  void *info MY_ATTRIBUTE ((unused)),
+  int count MY_ATTRIBUTE ((unused))
 #endif
 )
 {
@@ -1231,9 +1231,9 @@ static inline void inline_mysql_thread_register(
   PSI_thread_info *info,
   int count
 #else
-  const char *category __attribute__ ((unused)),
-  void *info __attribute__ ((unused)),
-  int count __attribute__ ((unused))
+  const char *category MY_ATTRIBUTE ((unused)),
+  void *info MY_ATTRIBUTE ((unused)),
+  int count MY_ATTRIBUTE ((unused))
 #endif
 )
 {
--- a/libmysql/libmysql.c
+++ b/libmysql/libmysql.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -111,9 +111,9 @@ typedef struct st_mysql_stmt_extension
     1  could not initialize environment (out of memory or thread keys)
 */
 
-int STDCALL mysql_server_init(int argc __attribute__((unused)),
-			      char **argv __attribute__((unused)),
-			      char **groups __attribute__((unused)))
+int STDCALL mysql_server_init(int argc MY_ATTRIBUTE((unused)),
+			      char **argv MY_ATTRIBUTE((unused)),
+			      char **groups MY_ATTRIBUTE((unused)))
 {
   int result= 0;
   if (!mysql_client_init)
@@ -128,7 +128,7 @@ int STDCALL mysql_server_init(int argc __attribute__((unused)),
     if (!mysql_port)
     {
       char *env;
-      struct servent *serv_ptr __attribute__((unused));
+      struct servent *serv_ptr MY_ATTRIBUTE((unused));
 
       mysql_port = MYSQL_PORT;
 
@@ -264,7 +264,7 @@ append_wild(char *to, char *end, const char *wild)
 **************************************************************************/
 
 void STDCALL
-mysql_debug(const char *debug __attribute__((unused)))
+mysql_debug(const char *debug MY_ATTRIBUTE((unused)))
 {
 #ifndef DBUG_OFF
   char	*env;
@@ -299,7 +299,7 @@ mysql_debug(const char *debug __attribute__((unused)))
 **************************************************************************/
 
 sig_handler
-my_pipe_sig_handler(int sig __attribute__((unused)))
+my_pipe_sig_handler(int sig MY_ATTRIBUTE((unused)))
 {
   DBUG_PRINT("info",("Hit by signal %d",sig));
 #ifdef SIGNAL_HANDLER_RESET_ON_DELIVERY
@@ -559,7 +559,7 @@ typedef struct st_default_local_infile
 */
 
 static int default_local_infile_init(void **ptr, const char *filename,
-             void *userdata __attribute__ ((unused)))
+             void *userdata MY_ATTRIBUTE ((unused)))
 {
   default_local_infile_data *data;
   char tmp_name[FN_REFLEN];
@@ -2341,15 +2341,15 @@ stmt_read_row_from_cursor(MYSQL_STMT *stmt, unsigned char **row)
 */
 
 static int
-stmt_read_row_no_data(MYSQL_STMT *stmt  __attribute__((unused)),
-                      unsigned char **row  __attribute__((unused)))
+stmt_read_row_no_data(MYSQL_STMT *stmt  MY_ATTRIBUTE((unused)),
+                      unsigned char **row  MY_ATTRIBUTE((unused)))
 {
   return MYSQL_NO_DATA;
 }
 
 static int
-stmt_read_row_no_result_set(MYSQL_STMT *stmt  __attribute__((unused)),
-                      unsigned char **row  __attribute__((unused)))
+stmt_read_row_no_result_set(MYSQL_STMT *stmt  MY_ATTRIBUTE((unused)),
+                      unsigned char **row  MY_ATTRIBUTE((unused)))
 {
   set_stmt_error(stmt, CR_NO_RESULT_SET, unknown_sqlstate, NULL);
   return 1;
@@ -3708,7 +3708,7 @@ static void fetch_result_short(MYSQL_BIND *param, MYSQL_FIELD *field,
 }
 
 static void fetch_result_int32(MYSQL_BIND *param,
-                               MYSQL_FIELD *field __attribute__((unused)),
+                               MYSQL_FIELD *field MY_ATTRIBUTE((unused)),
                                uchar **row)
 {
   my_bool field_is_unsigned= MY_TEST(field->flags & UNSIGNED_FLAG);
@@ -3719,7 +3719,7 @@ static void fetch_result_int32(MYSQL_BIND *param,
 }
 
 static void fetch_result_int64(MYSQL_BIND *param,
-                               MYSQL_FIELD *field __attribute__((unused)),
+                               MYSQL_FIELD *field MY_ATTRIBUTE((unused)),
                                uchar **row)
 {
   my_bool field_is_unsigned= MY_TEST(field->flags & UNSIGNED_FLAG);
@@ -3730,7 +3730,7 @@ static void fetch_result_int64(MYSQL_BIND *param,
 }
 
 static void fetch_result_float(MYSQL_BIND *param,
-                               MYSQL_FIELD *field __attribute__((unused)),
+                               MYSQL_FIELD *field MY_ATTRIBUTE((unused)),
                                uchar **row)
 {
   float value;
@@ -3740,7 +3740,7 @@ static void fetch_result_float(MYSQL_BIND *param,
 }
 
 static void fetch_result_double(MYSQL_BIND *param,
-                                MYSQL_FIELD *field __attribute__((unused)),
+                                MYSQL_FIELD *field MY_ATTRIBUTE((unused)),
                                 uchar **row)
 {
   double value;
@@ -3750,7 +3750,7 @@ static void fetch_result_double(MYSQL_BIND *param,
 }
 
 static void fetch_result_time(MYSQL_BIND *param,
-                              MYSQL_FIELD *field __attribute__((unused)),
+                              MYSQL_FIELD *field MY_ATTRIBUTE((unused)),
                               uchar **row)
 {
   MYSQL_TIME *tm= (MYSQL_TIME *)param->buffer;
@@ -3758,7 +3758,7 @@ static void fetch_result_time(MYSQL_BIND *param,
 }
 
 static void fetch_result_date(MYSQL_BIND *param,
-                              MYSQL_FIELD *field __attribute__((unused)),
+                              MYSQL_FIELD *field MY_ATTRIBUTE((unused)),
                               uchar **row)
 {
   MYSQL_TIME *tm= (MYSQL_TIME *)param->buffer;
@@ -3766,7 +3766,7 @@ static void fetch_result_date(MYSQL_BIND *param,
 }
 
 static void fetch_result_datetime(MYSQL_BIND *param,
-                                  MYSQL_FIELD *field __attribute__((unused)),
+                                  MYSQL_FIELD *field MY_ATTRIBUTE((unused)),
                                   uchar **row)
 {
   MYSQL_TIME *tm= (MYSQL_TIME *)param->buffer;
@@ -3774,7 +3774,7 @@ static void fetch_result_datetime(MYSQL_BIND *param,
 }
 
 static void fetch_result_bin(MYSQL_BIND *param,
-                             MYSQL_FIELD *field __attribute__((unused)),
+                             MYSQL_FIELD *field MY_ATTRIBUTE((unused)),
                              uchar **row)
 {
   ulong length= net_field_length(row);
@@ -3786,7 +3786,7 @@ static void fetch_result_bin(MYSQL_BIND *param,
 }
 
 static void fetch_result_str(MYSQL_BIND *param,
-                             MYSQL_FIELD *field __attribute__((unused)),
+                             MYSQL_FIELD *field MY_ATTRIBUTE((unused)),
                              uchar **row)
 {
   ulong length= net_field_length(row);
@@ -3807,7 +3807,7 @@ static void fetch_result_str(MYSQL_BIND *param,
 */
 
 static void skip_result_fixed(MYSQL_BIND *param,
-			      MYSQL_FIELD *field __attribute__((unused)),
+			      MYSQL_FIELD *field MY_ATTRIBUTE((unused)),
 			      uchar **row)
 
 {
@@ -3815,8 +3815,8 @@ static void skip_result_fixed(MYSQL_BIND *param,
 }
 
 
-static void skip_result_with_length(MYSQL_BIND *param __attribute__((unused)),
-				    MYSQL_FIELD *field __attribute__((unused)),
+static void skip_result_with_length(MYSQL_BIND *param MY_ATTRIBUTE((unused)),
+				    MYSQL_FIELD *field MY_ATTRIBUTE((unused)),
 				    uchar **row)
 
 {
@@ -3825,7 +3825,7 @@ static void skip_result_with_length(MYSQL_BIND *param __attribute__((unused)),
 }
 
 
-static void skip_result_string(MYSQL_BIND *param __attribute__((unused)),
+static void skip_result_string(MYSQL_BIND *param MY_ATTRIBUTE((unused)),
 			       MYSQL_FIELD *field,
 			       uchar **row)
 
--- a/libmysqld/lib_sql.cc
+++ b/libmysqld/lib_sql.cc
@@ -2,7 +2,7 @@
  * Copyright (c)  2000
  * SWsoft  company
  *
- * Modifications copyright (c) 2001, 2015. Oracle and/or its affiliates.
+ * Modifications copyright (c) 2001, 2016. Oracle and/or its affiliates.
  * All rights reserved.
  *
  * This material is provided "as is", with absolutely no warranty expressed
@@ -213,8 +213,8 @@ static void emb_flush_use_result(MYSQL *mysql, my_bool)
 */
 
 static MYSQL_DATA *
-emb_read_rows(MYSQL *mysql, MYSQL_FIELD *mysql_fields __attribute__((unused)),
-	      unsigned int fields __attribute__((unused)))
+emb_read_rows(MYSQL *mysql, MYSQL_FIELD *mysql_fields MY_ATTRIBUTE((unused)),
+	      unsigned int fields MY_ATTRIBUTE((unused)))
 {
   MYSQL_DATA *result= ((THD*)mysql->thd)->cur_data;
   ((THD*)mysql->thd)->cur_data= 0;
@@ -1426,7 +1426,7 @@ bool Protocol::net_store_data(const uchar *from, size_t length)
 #define vsnprintf _vsnprintf
 #endif
 
-int vprint_msg_to_log(enum loglevel level __attribute__((unused)),
+int vprint_msg_to_log(enum loglevel level MY_ATTRIBUTE((unused)),
                        const char *format, va_list argsi)
 {
   my_vsnprintf(mysql_server_last_error, sizeof(mysql_server_last_error),
--- a/mysql-test/r/mysql_plugin.result
+++ b/mysql-test/r/mysql_plugin.result
@@ -105,7 +105,7 @@ ERROR: Missing --plugin_dir option.
 # Show the help.
 #
 mysql_plugin  Ver V.V.VV Distrib XX.XX.XX
-Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved.
+Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 
 Enable or disable plugins.
 
--- a/mysys/charset-def.c
+++ b/mysys/charset-def.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2010, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -161,7 +161,7 @@ extern CHARSET_INFO my_charset_utf8mb4_vietnamese_ci;
 
 #endif /* HAVE_UCA_COLLATIONS */
 
-my_bool init_compiled_charsets(myf flags __attribute__((unused)))
+my_bool init_compiled_charsets(myf flags MY_ATTRIBUTE((unused)))
 {
   CHARSET_INFO *cs;
 
--- a/mysys/charset.c
+++ b/mysys/charset.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -357,8 +357,8 @@ static int add_collation(CHARSET_INFO *cs)
   Be silent by default: no warnings on the client side.
 */
 static void
-default_reporter(enum loglevel level  __attribute__ ((unused)),
-                 const char *format  __attribute__ ((unused)),
+default_reporter(enum loglevel level  MY_ATTRIBUTE ((unused)),
+                 const char *format  MY_ATTRIBUTE ((unused)),
                  ...)
 {
 }
--- a/mysys/mf_cache.c
+++ b/mysys/mf_cache.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2010, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -26,7 +26,7 @@
 	  this, just remember the file name for later removal
 	*/
 
-static my_bool cache_remove_open_tmp(IO_CACHE *cache __attribute__((unused)),
+static my_bool cache_remove_open_tmp(IO_CACHE *cache MY_ATTRIBUTE((unused)),
 				     const char *name)
 {
 #if O_TEMPORARY == 0
--- a/mysys/mf_iocache.c
+++ b/mysys/mf_iocache.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -323,7 +323,7 @@ static void my_aiowait(my_aio_result *result)
 
 my_bool reinit_io_cache(IO_CACHE *info, enum cache_type type,
 			my_off_t seek_offset,
-			pbool use_async_io __attribute__((unused)),
+			pbool use_async_io MY_ATTRIBUTE((unused)),
 			pbool clear_cache)
 {
   DBUG_ENTER("reinit_io_cache");
@@ -1129,7 +1129,7 @@ static void copy_to_read_buffer(IO_CACHE *write_cache,
   while (write_length)
   {
     size_t copy_length= MY_MIN(write_length, write_cache->buffer_length);
-    int  __attribute__((unused)) rc;
+    int  MY_ATTRIBUTE((unused)) rc;
 
     rc= lock_io_cache(write_cache, write_cache->pos_in_file);
     /* The writing thread does always have the lock when it awakes. */
@@ -1732,7 +1732,7 @@ int my_block_write(register IO_CACHE *info, const uchar *Buffer, size_t Count,
   unlock_append_buffer(info);
 
 int my_b_flush_io_cache(IO_CACHE *info,
-                        int need_append_buffer_lock __attribute__((unused)))
+                        int need_append_buffer_lock MY_ATTRIBUTE((unused)))
 {
   size_t length;
   my_off_t pos_in_file;
--- a/mysys/mf_keycache.c
+++ b/mysys/mf_keycache.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -2498,8 +2498,8 @@ static void read_block(KEY_CACHE *keycache,
 uchar *key_cache_read(KEY_CACHE *keycache,
                       File file, my_off_t filepos, int level,
                       uchar *buff, uint length,
-                      uint block_length __attribute__((unused)),
-                      int return_buffer __attribute__((unused)))
+                      uint block_length MY_ATTRIBUTE((unused)),
+                      int return_buffer MY_ATTRIBUTE((unused)))
 {
   my_bool locked_and_incremented= FALSE;
   int error=0;
@@ -2979,7 +2979,7 @@ int key_cache_insert(KEY_CACHE *keycache,
 int key_cache_write(KEY_CACHE *keycache,
                     File file, my_off_t filepos, int level,
                     uchar *buff, uint length,
-                    uint block_length  __attribute__((unused)),
+                    uint block_length  MY_ATTRIBUTE((unused)),
                     int dont_write)
 {
   my_bool locked_and_incremented= FALSE;
@@ -4206,7 +4206,7 @@ static int flush_all_key_blocks(KEY_CACHE *keycache)
     0 on success (always because it can't fail)
 */
 
-int reset_key_cache_counters(const char *name __attribute__((unused)),
+int reset_key_cache_counters(const char *name MY_ATTRIBUTE((unused)),
                              KEY_CACHE *key_cache)
 {
   DBUG_ENTER("reset_key_cache_counters");
@@ -4230,9 +4230,9 @@ int reset_key_cache_counters(const char *name __attribute__((unused)),
 /*
   Test if disk-cache is ok
 */
-static void test_key_cache(KEY_CACHE *keycache __attribute__((unused)),
-                           const char *where __attribute__((unused)),
-                           my_bool lock __attribute__((unused)))
+static void test_key_cache(KEY_CACHE *keycache MY_ATTRIBUTE((unused)),
+                           const char *where MY_ATTRIBUTE((unused)),
+                           my_bool lock MY_ATTRIBUTE((unused)))
 {
   /* TODO */
 }
--- a/mysys/mf_keycaches.c
+++ b/mysys/mf_keycaches.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2003, 2011, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2003, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -77,7 +77,7 @@ static void safe_hash_entry_free(SAFE_HASH_ENTRY *entry)
 /* Get key and length for a SAFE_HASH_ENTRY */
 
 static uchar *safe_hash_entry_get(SAFE_HASH_ENTRY *entry, size_t *length,
-                                  my_bool not_used __attribute__((unused)))
+                                  my_bool not_used MY_ATTRIBUTE((unused)))
 {
   *length=entry->length;
   return (uchar*) entry->key;
--- a/mysys/mf_tempfile.c
+++ b/mysys/mf_tempfile.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -55,8 +55,8 @@
 */
 
 File create_temp_file(char *to, const char *dir, const char *prefix,
-		      int mode __attribute__((unused)),
-		      myf MyFlags __attribute__((unused)))
+		      int mode MY_ATTRIBUTE((unused)),
+		      myf MyFlags MY_ATTRIBUTE((unused)))
 {
   File file= -1;
 #ifdef __WIN__
--- a/mysys/mf_unixpath.c
+++ b/mysys/mf_unixpath.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2010, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -24,7 +24,7 @@
   @param to   A pathname.
 */
 
-void to_unix_path(char *to __attribute__((unused)))
+void to_unix_path(char *to MY_ATTRIBUTE((unused)))
 {
 #if FN_LIBCHAR != '/'
   {
--- a/mysys/my_access.c
+++ b/mysys/my_access.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -187,9 +187,9 @@ static my_bool does_drive_exists(char drive_letter)
  
   @return TRUE if the file name is allowed, FALSE otherwise.
 */
-my_bool is_filename_allowed(const char *name __attribute__((unused)),
-                            size_t length __attribute__((unused)),
-                            my_bool allow_current_dir __attribute__((unused)))
+my_bool is_filename_allowed(const char *name MY_ATTRIBUTE((unused)),
+                            size_t length MY_ATTRIBUTE((unused)),
+                            my_bool allow_current_dir MY_ATTRIBUTE((unused)))
 {
   /* 
     For Windows, check if the file name contains : character.
--- a/mysys/my_alarm.c
+++ b/mysys/my_alarm.c
@@ -1,5 +1,4 @@
-/* Copyright (C) 2000 MySQL AB
-   Use is subject to license terms
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -12,7 +11,7 @@
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA */
+   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */
 
 /* Function to set a varible when we got a alarm */
 /* Used by my_lock samt functions in m_alarm.h */
@@ -24,7 +23,7 @@
 #ifdef HAVE_ALARM
 
 	/* ARGSUSED */
-sig_handler my_set_alarm_variable(int signo __attribute__((unused)))
+sig_handler my_set_alarm_variable(int signo MY_ATTRIBUTE((unused)))
 {
   my_have_got_alarm=1;			/* Tell program that time expired */
   return;
--- a/mysys/my_alloc.c
+++ b/mysys/my_alloc.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -44,7 +44,7 @@
 */
 
 void init_alloc_root(MEM_ROOT *mem_root, size_t block_size,
-		     size_t pre_alloc_size __attribute__((unused)))
+		     size_t pre_alloc_size MY_ATTRIBUTE((unused)))
 {
   DBUG_ENTER("init_alloc_root");
   DBUG_PRINT("enter",("root: 0x%lx", (long) mem_root));
@@ -94,7 +94,7 @@ void init_alloc_root(MEM_ROOT *mem_root, size_t block_size,
 */
 
 void reset_root_defaults(MEM_ROOT *mem_root, size_t block_size,
-                         size_t pre_alloc_size __attribute__((unused)))
+                         size_t pre_alloc_size MY_ATTRIBUTE((unused)))
 {
   DBUG_ASSERT(alloc_root_inited(mem_root));
 
--- a/mysys/my_bitmap.c
+++ b/mysys/my_bitmap.c
@@ -1,5 +1,5 @@
 /*
-   Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2001, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -81,14 +81,14 @@ void create_last_word_mask(MY_BITMAP *map)
 }
 
 
-static inline void bitmap_lock(MY_BITMAP *map __attribute__((unused)))
+static inline void bitmap_lock(MY_BITMAP *map MY_ATTRIBUTE((unused)))
 {
   if (map->mutex)
     mysql_mutex_lock(map->mutex);
 }
 
 
-static inline void bitmap_unlock(MY_BITMAP *map __attribute__((unused)))
+static inline void bitmap_unlock(MY_BITMAP *map MY_ATTRIBUTE((unused)))
 {
   if (map->mutex)
     mysql_mutex_unlock(map->mutex);
@@ -136,7 +136,7 @@ static inline uint get_first_not_set(uint32 value, uint word_pos)
 
 
 my_bool bitmap_init(MY_BITMAP *map, my_bitmap_map *buf, uint n_bits,
-		    my_bool thread_safe __attribute__((unused)))
+		    my_bool thread_safe MY_ATTRIBUTE((unused)))
 {
   DBUG_ENTER("bitmap_init");
   if (!buf)
--- a/mysys/my_fopen.c
+++ b/mysys/my_fopen.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -147,7 +147,7 @@ static FILE *my_win_freopen(const char *path, const char *mode, FILE *stream)
 
 /* No close operation hook. */
 
-static int no_close(void *cookie __attribute__((unused)))
+static int no_close(void *cookie MY_ATTRIBUTE((unused)))
 {
   return 0;
 }
--- a/mysys/my_fstream.c
+++ b/mysys/my_fstream.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -171,7 +171,7 @@ size_t my_fwrite(FILE *stream, const uchar *Buffer, size_t Count, myf MyFlags)
 /* Seek to position in file */
 
 my_off_t my_fseek(FILE *stream, my_off_t pos, int whence,
-		  myf MyFlags __attribute__((unused)))
+		  myf MyFlags MY_ATTRIBUTE((unused)))
 {
   DBUG_ENTER("my_fseek");
   DBUG_PRINT("my",("stream: 0x%lx  pos: %lu  whence: %d  MyFlags: %d",
@@ -183,7 +183,7 @@ my_off_t my_fseek(FILE *stream, my_off_t pos, int whence,
 
 /* Tell current position of file */
 
-my_off_t my_ftell(FILE *stream, myf MyFlags __attribute__((unused)))
+my_off_t my_ftell(FILE *stream, myf MyFlags MY_ATTRIBUTE((unused)))
 {
   off_t pos;
   DBUG_ENTER("my_ftell");
--- a/mysys/my_gethwaddr.c
+++ b/mysys/my_gethwaddr.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2004, 2013, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2004, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -228,14 +228,14 @@ my_bool my_gethwaddr(uchar *to)
 
 #else /* __FreeBSD__ || __linux__ || __WIN__ */
 /* just fail */
-my_bool my_gethwaddr(uchar *to __attribute__((unused)))
+my_bool my_gethwaddr(uchar *to MY_ATTRIBUTE((unused)))
 {
   return 1;
 }
 #endif
 
 #else /* MAIN */
-int main(int argc __attribute__((unused)),char **argv)
+int main(int argc MY_ATTRIBUTE((unused)),char **argv)
 {
   uchar mac[6];
   uint i;
--- a/mysys/my_getsystime.c
+++ b/mysys/my_getsystime.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2004, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -170,7 +170,7 @@ ulonglong my_micro_time_and_time(time_t *time_arg)
   @retval current time.
 */
 
-time_t my_time_possible_from_micro(ulonglong microtime __attribute__((unused)))
+time_t my_time_possible_from_micro(ulonglong microtime MY_ATTRIBUTE((unused)))
 {
 #ifdef _WIN32
   time_t t;
--- a/mysys/my_lib.c
+++ b/mysys/my_lib.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -390,7 +390,7 @@ error:
 
 
 int my_fstat(File Filedes, MY_STAT *stat_area,
-             myf MyFlags __attribute__((unused)))
+             myf MyFlags MY_ATTRIBUTE((unused)))
 {
   DBUG_ENTER("my_fstat");
   DBUG_PRINT("my",("fd: %d  MyFlags: %d", Filedes, MyFlags));
--- a/mysys/my_mess.c
+++ b/mysys/my_mess.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2010, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -15,7 +15,7 @@
 
 #include "mysys_priv.h"
 
-void my_message_stderr(uint error __attribute__((unused)),
+void my_message_stderr(uint error MY_ATTRIBUTE((unused)),
                        const char *str, myf MyFlags)
 {
   DBUG_ENTER("my_message_stderr");
--- a/mysys/my_static.c
+++ b/mysys/my_static.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -74,12 +74,12 @@ void (*error_handler_hook)(uint error, const char *str, myf MyFlags)=
 void (*fatal_error_handler_hook)(uint error, const char *str, myf MyFlags)=
   my_message_stderr;
 
-static void proc_info_dummy(void *a __attribute__((unused)),
-                            const PSI_stage_info *b __attribute__((unused)),
-                            PSI_stage_info *c __attribute__((unused)),
-                            const char *d __attribute__((unused)),
-                            const char *e __attribute__((unused)),
-                            const unsigned int f __attribute__((unused)))
+static void proc_info_dummy(void *a MY_ATTRIBUTE((unused)),
+                            const PSI_stage_info *b MY_ATTRIBUTE((unused)),
+                            PSI_stage_info *c MY_ATTRIBUTE((unused)),
+                            const char *d MY_ATTRIBUTE((unused)),
+                            const char *e MY_ATTRIBUTE((unused)),
+                            const unsigned int f MY_ATTRIBUTE((unused)))
 {
   return;
 }
--- a/mysys/my_symlink.c
+++ b/mysys/my_symlink.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2001, 2010, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2001, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -107,7 +107,7 @@ int my_symlink(const char *content, const char *linkname, myf MyFlags)
 #endif
 
 
-int my_is_symlink(const char *filename __attribute__((unused)))
+int my_is_symlink(const char *filename MY_ATTRIBUTE((unused)))
 {
 #if defined (HAVE_LSTAT) && defined (S_ISLNK)
   struct stat stat_buff;
--- a/mysys/my_sync.c
+++ b/mysys/my_sync.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2003, 2015, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2003, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -159,8 +159,8 @@ int my_sync_dir(const char *dir_name, myf my_flags)
 
 #else /* NEED_EXPLICIT_SYNC_DIR */
 
-int my_sync_dir(const char *dir_name __attribute__((unused)),
-                myf my_flags __attribute__((unused)))
+int my_sync_dir(const char *dir_name MY_ATTRIBUTE((unused)),
+                myf my_flags MY_ATTRIBUTE((unused)))
 {
   return 0;
 }
@@ -192,8 +192,8 @@ int my_sync_dir_by_file(const char *file_name, myf my_flags)
 
 #else /* NEED_EXPLICIT_SYNC_DIR */
 
-int my_sync_dir_by_file(const char *file_name __attribute__((unused)),
-                        myf my_flags __attribute__((unused)))
+int my_sync_dir_by_file(const char *file_name MY_ATTRIBUTE((unused)),
+                        myf my_flags MY_ATTRIBUTE((unused)))
 {
   return 0;
 }
--- a/mysys/psi_noop.c
+++ b/mysys/psi_noop.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
@@ -27,7 +27,7 @@
 
 C_MODE_START
 
-#define NNN __attribute__((unused))
+#define NNN MY_ATTRIBUTE((unused))
 
 static void register_mutex_noop(const char *category NNN,
                                 PSI_mutex_info *info NNN,
@@ -637,9 +637,9 @@ digest_end_noop(PSI_digest_locker *locker NNN,
 }
 
 static int
-set_thread_connect_attrs_noop(const char *buffer __attribute__((unused)),
-                             uint length  __attribute__((unused)),
-                             const void *from_cs __attribute__((unused)))
+set_thread_connect_attrs_noop(const char *buffer MY_ATTRIBUTE((unused)),
+                             uint length  MY_ATTRIBUTE((unused)),
+                             const void *from_cs MY_ATTRIBUTE((unused)))
 {
   return 0;
 }
--- a/mysys/ptr_cmp.c
+++ b/mysys/ptr_cmp.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -45,9 +45,9 @@ static int native_compare(size_t *length, unsigned char **a, unsigned char **b)
   Special case for ORDER BY / GROUP BY CHAR(0) NOT NULL
  */
 static
-int ptr_compare_zero_length(size_t *compare_length __attribute__((unused)),
-                            uchar **a __attribute__((unused)),
-                            uchar **b __attribute__((unused)))
+int ptr_compare_zero_length(size_t *compare_length MY_ATTRIBUTE((unused)),
+                            uchar **a MY_ATTRIBUTE((unused)),
+                            uchar **b MY_ATTRIBUTE((unused)))
 {
   return 0;
 }
@@ -61,7 +61,7 @@ static int ptr_compare_3(size_t *compare_length, uchar **a, uchar **b);
 	/* Get a pointer to a optimal byte-compare function for a given size */
 
 #ifdef __sun
-qsort2_cmp get_ptr_compare (size_t size __attribute__((unused)))
+qsort2_cmp get_ptr_compare (size_t size MY_ATTRIBUTE((unused)))
 {
   return (qsort2_cmp) native_compare;
 }
--- a/mysys/stacktrace.c
+++ b/mysys/stacktrace.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2001, 2011, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2001, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -159,8 +159,8 @@ void my_safe_print_str(const char* val, int max_len)
 /* Use Solaris' symbolic stack trace routine. */
 #include <ucontext.h>
 
-void my_print_stacktrace(uchar* stack_bottom __attribute__((unused)), 
-                         ulong thread_stack __attribute__((unused)))
+void my_print_stacktrace(uchar* stack_bottom MY_ATTRIBUTE((unused)), 
+                         ulong thread_stack MY_ATTRIBUTE((unused)))
 {
   if (printstack(fileno(stderr)) == -1)
     my_safe_printf_stderr("%s",
@@ -178,9 +178,9 @@ void my_print_stacktrace(uchar* stack_bottom __attribute__((unused)),
 
 #if BACKTRACE_DEMANGLE
 
-char __attribute__ ((weak)) *
-my_demangle(const char *mangled_name __attribute__((unused)),
-            int *status __attribute__((unused)))
+char MY_ATTRIBUTE ((weak)) *
+my_demangle(const char *mangled_name MY_ATTRIBUTE((unused)),
+            int *status MY_ATTRIBUTE((unused)))
 {
   return NULL;
 }
--- a/mysys/testhash.c
+++ b/mysys/testhash.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -39,7 +39,7 @@ my_bool hash_check(HASH *hash);
 void free_record(void *record);
 
 static uchar *hash2_key(const uchar *rec,uint *length,
-		       my_bool not_used __attribute__((unused)))
+		       my_bool not_used MY_ATTRIBUTE((unused)))
 {
   *length=(uint) (uchar) rec[reclength-1];
   return (uchar*) rec;
--- a/mysys/thr_alarm.c
+++ b/mysys/thr_alarm.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -60,9 +60,9 @@ static void *alarm_handler(void *arg);
 #define reschedule_alarms() pthread_kill(alarm_thread,THR_SERVER_ALARM)
 #endif
 
-static sig_handler thread_alarm(int sig __attribute__((unused)));
+static sig_handler thread_alarm(int sig MY_ATTRIBUTE((unused)));
 
-static int compare_ulong(void *not_used __attribute__((unused)),
+static int compare_ulong(void *not_used MY_ATTRIBUTE((unused)),
 			 uchar *a_ptr,uchar* b_ptr)
 {
   ulong a=*((ulong*) a_ptr),b= *((ulong*) b_ptr);
@@ -274,7 +274,7 @@ void thr_end_alarm(thr_alarm_t *alarmed)
   every second.
 */
 
-sig_handler process_alarm(int sig __attribute__((unused)))
+sig_handler process_alarm(int sig MY_ATTRIBUTE((unused)))
 {
   sigset_t old_mask;
 /*
@@ -304,7 +304,7 @@ sig_handler process_alarm(int sig __attribute__((unused)))
 }
 
 
-static sig_handler process_alarm_part2(int sig __attribute__((unused)))
+static sig_handler process_alarm_part2(int sig MY_ATTRIBUTE((unused)))
 {
   ALARM *alarm_data;
   DBUG_ENTER("process_alarm");
@@ -492,7 +492,7 @@ void thr_alarm_info(ALARM_INFO *info)
 */
 
 
-static sig_handler thread_alarm(int sig __attribute__((unused)))
+static sig_handler thread_alarm(int sig MY_ATTRIBUTE((unused)))
 {
 #ifdef MAIN
   printf("thread_alarm\n"); fflush(stdout);
@@ -511,7 +511,7 @@ static sig_handler thread_alarm(int sig __attribute__((unused)))
 /* set up a alarm thread with uses 'sleep' to sleep between alarms */
 
 #ifdef USE_ALARM_THREAD
-static void *alarm_handler(void *arg __attribute__((unused)))
+static void *alarm_handler(void *arg MY_ATTRIBUTE((unused)))
 {
   int error;
   struct timespec abstime;
@@ -580,7 +580,7 @@ void thr_alarm_kill(my_thread_id thread_id)
   /* Can't do this yet */
 }
 
-sig_handler process_alarm(int sig __attribute__((unused)))
+sig_handler process_alarm(int sig MY_ATTRIBUTE((unused)))
 {
   /* Can't do this yet */
 }
@@ -774,7 +774,7 @@ static sig_handler print_signal_warning(int sig)
 #endif /* USE_ONE_SIGNAL_HAND */
 
 
-static void *signal_hand(void *arg __attribute__((unused)))
+static void *signal_hand(void *arg MY_ATTRIBUTE((unused)))
 {
   sigset_t set;
   int sig,error,err_count=0;;
@@ -842,7 +842,7 @@ static void *signal_hand(void *arg __attribute__((unused)))
 }
 
 
-int main(int argc __attribute__((unused)),char **argv __attribute__((unused)))
+int main(int argc MY_ATTRIBUTE((unused)),char **argv MY_ATTRIBUTE((unused)))
 {
   pthread_t tid;
   pthread_attr_t thr_attr;
@@ -931,7 +931,7 @@ int main(int argc __attribute__((unused)),char **argv __attribute__((unused)))
 
 #else /* !defined(DONT_USE_ALARM_THREAD) */
 
-int main(int argc __attribute__((unused)),char **argv __attribute__((unused)))
+int main(int argc MY_ATTRIBUTE((unused)),char **argv MY_ATTRIBUTE((unused)))
 {
   printf("thr_alarm disabled with DONT_USE_THR_ALARM\n");
   exit(1);
--- a/mysys/thr_lock.c
+++ b/mysys/thr_lock.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -1512,21 +1512,21 @@ static ulong sum=0;
 
 /* The following functions is for WRITE_CONCURRENT_INSERT */
 
-static void test_get_status(void* param __attribute__((unused)),
-                            int concurrent_insert __attribute__((unused)))
+static void test_get_status(void* param MY_ATTRIBUTE((unused)),
+                            int concurrent_insert MY_ATTRIBUTE((unused)))
 {
 }
 
-static void test_update_status(void* param __attribute__((unused)))
+static void test_update_status(void* param MY_ATTRIBUTE((unused)))
 {
 }
 
-static void test_copy_status(void* to __attribute__((unused)) ,
-			     void *from __attribute__((unused)))
+static void test_copy_status(void* to MY_ATTRIBUTE((unused)) ,
+			     void *from MY_ATTRIBUTE((unused)))
 {
 }
 
-static my_bool test_check_status(void* param __attribute__((unused)))
+static my_bool test_check_status(void* param MY_ATTRIBUTE((unused)))
 {
   return 0;
 }
@@ -1583,7 +1583,7 @@ static void *test_thread(void *arg)
 }
 
 
-int main(int argc __attribute__((unused)),char **argv __attribute__((unused)))
+int main(int argc MY_ATTRIBUTE((unused)),char **argv MY_ATTRIBUTE((unused)))
 {
   pthread_t tid;
   pthread_attr_t thr_attr;
--- a/mysys/thr_mutex.c
+++ b/mysys/thr_mutex.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -53,7 +53,7 @@ void safe_mutex_global_init(void)
 
 
 int safe_mutex_init(safe_mutex_t *mp,
-		    const pthread_mutexattr_t *attr __attribute__((unused)),
+		    const pthread_mutexattr_t *attr MY_ATTRIBUTE((unused)),
 		    const char *file,
 		    uint line)
 {
@@ -370,7 +370,7 @@ int safe_mutex_destroy(safe_mutex_t *mp, const char *file, uint line)
    This is ok, as this thread may not yet have been exited.
 */
 
-void safe_mutex_end(FILE *file __attribute__((unused)))
+void safe_mutex_end(FILE *file MY_ATTRIBUTE((unused)))
 {
   if (!safe_mutex_count)			/* safetly */
     pthread_mutex_destroy(&THR_LOCK_mutex);
--- a/mysys/waiting_threads.c
+++ b/mysys/waiting_threads.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008, 2015, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -295,9 +295,9 @@ uint32 wt_cycle_stats[2][WT_CYCLE_STATS+1];
 uint32 wt_success_stats;
 
 static my_atomic_rwlock_t
-  cycle_stats_lock __attribute__((unused)),
-  wait_stats_lock __attribute__((unused)),
-  success_stats_lock __attribute__((unused));
+  cycle_stats_lock MY_ATTRIBUTE((unused)),
+  wait_stats_lock MY_ATTRIBUTE((unused)),
+  success_stats_lock MY_ATTRIBUTE((unused));
 
 #ifdef SAFE_STATISTICS
 #define incr(VAR, LOCK)                           \
--- a/mysys_ssl/my_default.cc
+++ b/mysys_ssl/my_default.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -1279,7 +1279,7 @@ static int add_directory(MEM_ROOT *alloc, const char *dir, const char **dirs)
   char buf[FN_REFLEN];
   size_t len;
   char *p;
-  my_bool err __attribute__((unused));
+  my_bool err MY_ATTRIBUTE((unused));
 
   len= normalize_dirname(buf, dir);
   if (!(p= strmake_root(alloc, buf, len)))
--- a/mysys_ssl/my_getopt.cc
+++ b/mysys_ssl/my_getopt.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2002, 2015, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2002, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -1370,7 +1370,7 @@ static void init_one_value(const struct my_option *option, void *variable,
 */
 
 static void fini_one_value(const struct my_option *option, void *variable,
-			   longlong value __attribute__ ((unused)))
+			   longlong value MY_ATTRIBUTE ((unused)))
 {
   DBUG_ENTER("fini_one_value");
   switch ((option->var_type & GET_TYPE_MASK)) {
--- a/plugin/audit_null/audit_null.c
+++ b/plugin/audit_null/audit_null.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2009, 2011, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2009, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License as
@@ -18,9 +18,7 @@
 #include <mysql/plugin.h>
 #include <mysql/plugin_audit.h>
 
-#if !defined(__attribute__) && (defined(__cplusplus) || !defined(__GNUC__)  || __GNUC__ == 2 && __GNUC_MINOR__ < 8)
-#define __attribute__(A)
-#endif
+#include "my_attribute.h"
 
 static volatile int number_of_calls; /* for SHOW STATUS, see below */
 /* Count MYSQL_AUDIT_GENERAL_CLASS event instances */
@@ -48,7 +46,7 @@ static volatile int number_of_calls_connection_change_user;
     1                    failure (cannot happen)
 */
 
-static int audit_null_plugin_init(void *arg __attribute__((unused)))
+static int audit_null_plugin_init(void *arg MY_ATTRIBUTE((unused)))
 {
   number_of_calls= 0;
   number_of_calls_general_log= 0;
@@ -75,7 +73,7 @@ static int audit_null_plugin_init(void *arg __attribute__((unused)))
 
 */
 
-static int audit_null_plugin_deinit(void *arg __attribute__((unused)))
+static int audit_null_plugin_deinit(void *arg MY_ATTRIBUTE((unused)))
 {
   return(0);
 }
@@ -91,7 +89,7 @@ static int audit_null_plugin_deinit(void *arg __attribute__((unused)))
   DESCRIPTION
 */
 
-static void audit_null_notify(MYSQL_THD thd __attribute__((unused)),
+static void audit_null_notify(MYSQL_THD thd MY_ATTRIBUTE((unused)),
                               unsigned int event_class,
                               const void *event)
 {
--- a/plugin/auth/dialog.c
+++ b/plugin/auth/dialog.c
@@ -1,4 +1,4 @@
-/*  Copyright (c) 2010, 2011, Oracle and/or its affiliates. All rights reserved.
+/*  Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 
     This program is free software; you can redistribute it and/or
     modify it under the terms of the GNU General Public License as
@@ -207,8 +207,8 @@ typedef char *(*mysql_authentication_dialog_ask_t)(struct st_mysql *mysql,
 
 static mysql_authentication_dialog_ask_t ask;
 
-static char *builtin_ask(MYSQL *mysql __attribute__((unused)),
-                         int type __attribute__((unused)),
+static char *builtin_ask(MYSQL *mysql MY_ATTRIBUTE((unused)),
+                         int type MY_ATTRIBUTE((unused)),
                          const char *prompt,
                          char *buf, int buf_len)
 {
@@ -309,10 +309,10 @@ static int perform_dialog(MYSQL_PLUGIN_VIO *vio, MYSQL *mysql)
   or fall back to the default implementation.
 */
 
-static int init_dialog(char *unused1   __attribute__((unused)), 
-                       size_t unused2  __attribute__((unused)), 
-                       int unused3     __attribute__((unused)), 
-                       va_list unused4 __attribute__((unused)))
+static int init_dialog(char *unused1   MY_ATTRIBUTE((unused)), 
+                       size_t unused2  MY_ATTRIBUTE((unused)), 
+                       int unused3     MY_ATTRIBUTE((unused)), 
+                       va_list unused4 MY_ATTRIBUTE((unused)))
 {
   void *sym= dlsym(RTLD_DEFAULT, "mysql_authentication_dialog_ask");
   ask= sym ? (mysql_authentication_dialog_ask_t) sym : builtin_ask;
--- a/plugin/auth/mysql_no_login.c
+++ b/plugin/auth/mysql_no_login.c
@@ -1,4 +1,4 @@
-/*  Copyright (c) 2014, 2015 Oracle and/or its affiliates. All rights reserved.
+/*  Copyright (c) 2014, 2016 Oracle and/or its affiliates. All rights reserved.
 
     This program is free software; you can redistribute it and/or
     modify it under the terms of the GNU General Public License as
@@ -32,8 +32,8 @@
 #include <stdlib.h>
 
 static int mysql_no_login(
-    MYSQL_PLUGIN_VIO *vio __attribute__((unused)),
-    MYSQL_SERVER_AUTH_INFO *info __attribute__((unused)))
+    MYSQL_PLUGIN_VIO *vio MY_ATTRIBUTE((unused)),
+    MYSQL_SERVER_AUTH_INFO *info MY_ATTRIBUTE((unused)))
 {
   return CR_ERROR;
 }
--- a/plugin/daemon_example/daemon_example.cc
+++ b/plugin/daemon_example/daemon_example.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2006, 2010, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2006, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -26,10 +26,10 @@
 #include "sql_plugin.h"                         // st_plugin_int
 
 /*
-  Disable __attribute__() on non-gcc compilers.
+  Disable MY_ATTRIBUTE() on non-gcc compilers.
 */
-#if !defined(__attribute__) && !defined(__GNUC__)
-#define __attribute__(A)
+#if !defined(MY_ATTRIBUTE) && !defined(__GNUC__)
+#define MY_ATTRIBUTE(A)
 #endif
 
 
--- a/plugin/fulltext/plugin_example.c
+++ b/plugin/fulltext/plugin_example.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2005, 2011, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2005, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -17,9 +17,7 @@
 #include <ctype.h>
 #include <mysql/plugin.h>
 
-#if !defined(__attribute__) && (defined(__cplusplus) || !defined(__GNUC__)  || __GNUC__ == 2 && __GNUC_MINOR__ < 8)
-#define __attribute__(A)
-#endif
+#include "my_attribute.h"
 
 static long number_of_calls= 0; /* for SHOW STATUS, see below */
 
@@ -62,7 +60,7 @@ static long number_of_calls= 0; /* for SHOW STATUS, see below */
     1                    failure (cannot happen)
 */
 
-static int simple_parser_plugin_init(void *arg __attribute__((unused)))
+static int simple_parser_plugin_init(void *arg MY_ATTRIBUTE((unused)))
 {
   return(0);
 }
@@ -81,7 +79,7 @@ static int simple_parser_plugin_init(void *arg __attribute__((unused)))
 
 */
 
-static int simple_parser_plugin_deinit(void *arg __attribute__((unused)))
+static int simple_parser_plugin_deinit(void *arg MY_ATTRIBUTE((unused)))
 {
   return(0);
 }
@@ -102,7 +100,7 @@ static int simple_parser_plugin_deinit(void *arg __attribute__((unused)))
 */
 
 static int simple_parser_init(MYSQL_FTPARSER_PARAM *param
-                              __attribute__((unused)))
+                              MY_ATTRIBUTE((unused)))
 {
   return(0);
 }
@@ -123,7 +121,7 @@ static int simple_parser_init(MYSQL_FTPARSER_PARAM *param
 */
 
 static int simple_parser_deinit(MYSQL_FTPARSER_PARAM *param
-                                __attribute__((unused)))
+                                MY_ATTRIBUTE((unused)))
 {
   return(0);
 }
--- a/plugin/password_validation/validate_password.cc
+++ b/plugin/password_validation/validate_password.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012, 2015, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -24,12 +24,12 @@
 
 
 /*  
-  __attribute__(A) needs to be defined for Windows else complier
+  MY_ATTRIBUTE(A) needs to be defined for Windows else complier
   do not recognise it. Argument in plugin_init and plugin_deinit
   Used in other plugins as well.
 */
-#if !defined(__attribute__) && (defined(__cplusplus) || !defined(__GNUC__)  || __GNUC__ == 2 && __GNUC_MINOR__ < 8)
-#define __attribute__(A)
+#if !defined(MY_ATTRIBUTE) && (defined(__cplusplus) || !defined(__GNUC__)  || __GNUC__ == 2 && __GNUC_MINOR__ < 8)
+#define MY_ATTRIBUTE(A)
 #endif
 
 #define MAX_DICTIONARY_FILE_LENGTH    1024 * 1024
@@ -367,7 +367,7 @@ static int validate_password_init(MYSQL_PLUGIN plugin_info)
   It empty the std::set and returns 0
 */
 
-static int validate_password_deinit(void *arg __attribute__((unused)))
+static int validate_password_deinit(void *arg MY_ATTRIBUTE((unused)))
 {
   free_dictionary_file();
   mysql_rwlock_destroy(&LOCK_dict_file);
@@ -380,8 +380,8 @@ static int validate_password_deinit(void *arg __attribute__((unused)))
   the cache and re-load the new dictionary file.
 */
 static void
-dictionary_update(MYSQL_THD thd __attribute__((unused)),
-                  struct st_mysql_sys_var *var __attribute__((unused)),
+dictionary_update(MYSQL_THD thd MY_ATTRIBUTE((unused)),
+                  struct st_mysql_sys_var *var MY_ATTRIBUTE((unused)),
                   void *var_ptr, const void *save)
 {
   *(const char**)var_ptr= *(const char**)save;
@@ -396,8 +396,8 @@ dictionary_update(MYSQL_THD thd __attribute__((unused)),
   4. validate_password_special_char_count
 */
 static void
-length_update(MYSQL_THD thd __attribute__((unused)),
-              struct st_mysql_sys_var *var __attribute__((unused)),
+length_update(MYSQL_THD thd MY_ATTRIBUTE((unused)),
+              struct st_mysql_sys_var *var MY_ATTRIBUTE((unused)),
               void *var_ptr, const void *save)
 {
   int new_validate_password_length;
--- a/regex/regcomp.c
+++ b/regex/regcomp.c
@@ -3,7 +3,7 @@
 
    This file was modified by Oracle on 2015-05-18 for 32-bit compatibility.
 
-   Modifications copyright (c) 2015, Oracle and/or its affiliates. All rights
+   Modifications copyright (c) 2015, 2016, Oracle and/or its affiliates. All rights
    reserved. */
 
 #include <my_global.h>
@@ -1258,8 +1258,8 @@ register char *cp;
  */
 static void
 mcinvert(p, cs)
-  register struct parse *p __attribute__((unused));
-  register cset *cs __attribute__((unused));
+  register struct parse *p MY_ATTRIBUTE((unused));
+  register cset *cs MY_ATTRIBUTE((unused));
 {
 	assert(cs->multis == NULL);	/* xxx */
 }
@@ -1273,8 +1273,8 @@ mcinvert(p, cs)
  */
 static void
 mccase(p, cs)
-register struct parse *p __attribute__((unused));
-register cset *cs __attribute__((unused));
+register struct parse *p MY_ATTRIBUTE((unused));
+register cset *cs MY_ATTRIBUTE((unused));
 {
 	assert(cs->multis == NULL);	/* xxx */
 }
--- a/sql-common/client.c
+++ b/sql-common/client.c
@@ -1741,12 +1741,12 @@ mysql_init(MYSQL *mysql)
 #define strdup_if_not_null(A) (A) == 0 ? 0 : my_strdup((A),MYF(MY_WME))
 
 my_bool STDCALL
-mysql_ssl_set(MYSQL *mysql __attribute__((unused)) ,
-	      const char *key __attribute__((unused)),
-	      const char *cert __attribute__((unused)),
-	      const char *ca __attribute__((unused)),
-	      const char *capath __attribute__((unused)),
-	      const char *cipher __attribute__((unused)))
+mysql_ssl_set(MYSQL *mysql MY_ATTRIBUTE((unused)) ,
+	      const char *key MY_ATTRIBUTE((unused)),
+	      const char *cert MY_ATTRIBUTE((unused)),
+	      const char *ca MY_ATTRIBUTE((unused)),
+	      const char *capath MY_ATTRIBUTE((unused)),
+	      const char *cipher MY_ATTRIBUTE((unused)))
 {
   my_bool result= 0;
   DBUG_ENTER("mysql_ssl_set");
@@ -1771,7 +1771,7 @@ mysql_ssl_set(MYSQL *mysql __attribute__((unused)) ,
 #if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)
 
 static void
-mysql_ssl_free(MYSQL *mysql __attribute__((unused)))
+mysql_ssl_free(MYSQL *mysql MY_ATTRIBUTE((unused)))
 {
   struct st_VioSSLFd *ssl_fd= (struct st_VioSSLFd*) mysql->connector_fd;
   DBUG_ENTER("mysql_ssl_free");
@@ -1817,7 +1817,7 @@ mysql_ssl_free(MYSQL *mysql __attribute__((unused)))
 */
 
 const char * STDCALL
-mysql_get_ssl_cipher(MYSQL *mysql __attribute__((unused)))
+mysql_get_ssl_cipher(MYSQL *mysql MY_ATTRIBUTE((unused)))
 {
   DBUG_ENTER("mysql_get_ssl_cipher");
 #if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)
@@ -4085,8 +4085,8 @@ static void mysql_prune_stmt_list(MYSQL *mysql)
     should also be reflected there.
 */
 
-void mysql_detach_stmt_list(LIST **stmt_list __attribute__((unused)),
-                            const char *func_name __attribute__((unused)))
+void mysql_detach_stmt_list(LIST **stmt_list MY_ATTRIBUTE((unused)),
+                            const char *func_name MY_ATTRIBUTE((unused)))
 {
 #ifdef MYSQL_CLIENT
   /* Reset connection handle in all prepared statements. */
@@ -4598,7 +4598,7 @@ mysql_options(MYSQL *mysql,enum mysql_option option, const void *arg)
 */
 uchar *
 get_attr_key(LEX_STRING *part, size_t *length,
-             my_bool not_used __attribute__((unused)))
+             my_bool not_used MY_ATTRIBUTE((unused)))
 {
   *length= part[0].length;
   return (uchar *) part[0].str;
--- a/sql/binlog.cc
+++ b/sql/binlog.cc
@@ -8613,7 +8613,7 @@ template <class RowsEventT> Rows_log_event*
 THD::binlog_prepare_pending_rows_event(TABLE* table, uint32 serv_id,
                                        size_t needed,
                                        bool is_transactional,
-				       RowsEventT *hint __attribute__((unused)),
+				       RowsEventT *hint MY_ATTRIBUTE((unused)),
                                        const uchar* extra_row_info)
 {
   DBUG_ENTER("binlog_prepare_pending_rows_event");
--- a/sql/binlog.h
+++ b/sql/binlog.h
@@ -1,5 +1,5 @@
 #ifndef BINLOG_H_INCLUDED
-/* Copyright (c) 2010, 2015, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -86,7 +86,7 @@ public:
 
     /** Lock for protecting the queue. */
     mysql_mutex_t m_lock;
-  } __attribute__((aligned(CPU_LEVEL1_DCACHE_LINESIZE)));
+  } MY_ATTRIBUTE((aligned(CPU_LEVEL1_DCACHE_LINESIZE)));
 
 public:
   Stage_manager()
--- a/sql/field.cc
+++ b/sql/field.cc
@@ -1,5 +1,5 @@
 /*
-   Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -1290,7 +1290,7 @@ out_of_range:
 */
 type_conversion_status
 Field_num::store_time(MYSQL_TIME *ltime,
-                      uint8 dec_arg __attribute__((unused)))
+                      uint8 dec_arg MY_ATTRIBUTE((unused)))
 {
   longlong nr= TIME_to_ulonglong_round(ltime);
   return store(ltime->neg ? -nr : nr, 0);
@@ -1444,8 +1444,8 @@ bool Field::send_binary(Protocol *protocol)
    master's field size, @c false otherwise.
 */
 bool Field::compatible_field_size(uint field_metadata,
-                                  Relay_log_info *rli_arg __attribute__((unused)),
-                                  uint16 mflags __attribute__((unused)),
+                                  Relay_log_info *rli_arg MY_ATTRIBUTE((unused)),
+                                  uint16 mflags MY_ATTRIBUTE((unused)),
                                   int *order_var)
 {
   uint const source_size= pack_length_from_metadata(field_metadata);
@@ -1508,7 +1508,7 @@ Field::store(const char *to, uint length, const CHARSET_INFO *cs,
 */
 uchar *
 Field::pack(uchar *to, const uchar *from, uint max_length,
-            bool low_byte_first __attribute__((unused)))
+            bool low_byte_first MY_ATTRIBUTE((unused)))
 {
   uint32 length= pack_length();
   set_if_smaller(length, max_length);
@@ -1548,7 +1548,7 @@ Field::pack(uchar *to, const uchar *from, uint max_length,
 */
 const uchar *
 Field::unpack(uchar* to, const uchar *from, uint param_data,
-              bool low_byte_first __attribute__((unused)))
+              bool low_byte_first MY_ATTRIBUTE((unused)))
 {
   uint length=pack_length();
   int from_type= 0;
@@ -1860,7 +1860,7 @@ bool Field::optimize_range(uint idx, uint part)
 
 
 Field *Field::new_field(MEM_ROOT *root, TABLE *new_table,
-                        bool keep_type __attribute__((unused)))
+                        bool keep_type MY_ATTRIBUTE((unused)))
 {
   Field *tmp= clone(root);
   if (tmp == NULL)
@@ -2435,7 +2435,7 @@ longlong Field_decimal::val_int(void)
 }
 
 
-String *Field_decimal::val_str(String *val_buffer __attribute__((unused)),
+String *Field_decimal::val_str(String *val_buffer MY_ATTRIBUTE((unused)),
 			       String *val_ptr)
 {
   ASSERT_COLUMN_MARKED_FOR_READ;
@@ -2806,7 +2806,7 @@ Field_new_decimal::store_decimal(const my_decimal *decimal_value)
 
 type_conversion_status
 Field_new_decimal::store_time(MYSQL_TIME *ltime,
-                                  uint8 dec_arg __attribute__((unused)))
+                                  uint8 dec_arg MY_ATTRIBUTE((unused)))
 {
   my_decimal decimal_value;
   return store_value(date2my_decimal(ltime, &decimal_value));
@@ -2847,7 +2847,7 @@ my_decimal* Field_new_decimal::val_decimal(my_decimal *decimal_value)
 
 
 String *Field_new_decimal::val_str(String *val_buffer,
-                                   String *val_ptr __attribute__((unused)))
+                                   String *val_ptr MY_ATTRIBUTE((unused)))
 {
   ASSERT_COLUMN_MARKED_FOR_READ;
   my_decimal decimal_value;
@@ -2960,8 +2960,8 @@ uint Field_new_decimal::pack_length_from_metadata(uint field_metadata)
    @return @c true
 */
 bool Field_new_decimal::compatible_field_size(uint field_metadata,
-                                              Relay_log_info * __attribute__((unused)),
-                                              uint16 mflags __attribute__((unused)),
+                                              Relay_log_info * MY_ATTRIBUTE((unused)),
+                                              uint16 mflags MY_ATTRIBUTE((unused)),
                                               int *order_var)
 {
   uint const source_precision= (field_metadata >> 8U) & 0x00ff;
@@ -3161,7 +3161,7 @@ longlong Field_tiny::val_int(void)
 
 
 String *Field_tiny::val_str(String *val_buffer,
-			    String *val_ptr __attribute__((unused)))
+			    String *val_ptr MY_ATTRIBUTE((unused)))
 {
   ASSERT_COLUMN_MARKED_FOR_READ;
   const CHARSET_INFO *cs= &my_charset_numeric;
@@ -3376,7 +3376,7 @@ longlong Field_short::val_int(void)
 
 
 String *Field_short::val_str(String *val_buffer,
-			     String *val_ptr __attribute__((unused)))
+			     String *val_ptr MY_ATTRIBUTE((unused)))
 {
   ASSERT_COLUMN_MARKED_FOR_READ;
   const CHARSET_INFO *cs= &my_charset_numeric;
@@ -3596,7 +3596,7 @@ longlong Field_medium::val_int(void)
 
 
 String *Field_medium::val_str(String *val_buffer,
-			      String *val_ptr __attribute__((unused)))
+			      String *val_ptr MY_ATTRIBUTE((unused)))
 {
   ASSERT_COLUMN_MARKED_FOR_READ;
   const CHARSET_INFO *cs= &my_charset_numeric;
@@ -3830,7 +3830,7 @@ longlong Field_long::val_int(void)
 }
 
 String *Field_long::val_str(String *val_buffer,
-			    String *val_ptr __attribute__((unused)))
+			    String *val_ptr MY_ATTRIBUTE((unused)))
 {
   ASSERT_COLUMN_MARKED_FOR_READ;
   const CHARSET_INFO *cs= &my_charset_numeric;
@@ -4079,7 +4079,7 @@ longlong Field_longlong::val_int(void)
 
 
 String *Field_longlong::val_str(String *val_buffer,
-				String *val_ptr __attribute__((unused)))
+				String *val_ptr MY_ATTRIBUTE((unused)))
 {
   const CHARSET_INFO *cs= &my_charset_numeric;
   uint length;
@@ -4199,7 +4199,7 @@ Field_real::unpack(uchar *to, const uchar *from,
 
 type_conversion_status
 Field_real::store_time(MYSQL_TIME *ltime,
-                       uint8 dec_arg __attribute__((unused)))
+                       uint8 dec_arg MY_ATTRIBUTE((unused)))
 {
   double nr= TIME_to_double(ltime);
   return store(ltime->neg ? -nr : nr);
@@ -4289,7 +4289,7 @@ longlong Field_float::val_int(void)
 
 
 String *Field_float::val_str(String *val_buffer,
-			     String *val_ptr __attribute__((unused)))
+			     String *val_ptr MY_ATTRIBUTE((unused)))
 {
   ASSERT_COLUMN_MARKED_FOR_READ;
   DBUG_ASSERT(!zerofill || field_length <= MAX_FIELD_CHARLENGTH);
@@ -4625,7 +4625,7 @@ bool Field_real::get_time(MYSQL_TIME *ltime)
 
 
 String *Field_double::val_str(String *val_buffer,
-			      String *val_ptr __attribute__((unused)))
+			      String *val_ptr MY_ATTRIBUTE((unused)))
 {
   ASSERT_COLUMN_MARKED_FOR_READ;
   DBUG_ASSERT(!zerofill || field_length <= MAX_FIELD_CHARLENGTH);
@@ -5089,7 +5089,7 @@ Field_temporal_with_date::convert_number_to_TIME(longlong nr,
 
 type_conversion_status
 Field_temporal_with_date::store_time(MYSQL_TIME *ltime,
-                                     uint8 dec_arg __attribute__((unused)))
+                                     uint8 dec_arg MY_ATTRIBUTE((unused)))
 {
   ASSERT_COLUMN_MARKED_FOR_WRITE;
   type_conversion_status error;
@@ -5480,7 +5480,7 @@ int Field_timestamp::cmp(const uchar *a_ptr, const uchar *b_ptr)
 }
 
 
-void Field_timestamp::make_sort_key(uchar *to,uint length __attribute__((unused)))
+void Field_timestamp::make_sort_key(uchar *to,uint length MY_ATTRIBUTE((unused)))
 {
 #ifdef WORDS_BIGENDIAN
   if (!table || !table->s->db_low_byte_first)
@@ -5699,7 +5699,7 @@ Field_time_common::convert_number_to_TIME(longlong nr, bool unsigned_val,
 
 type_conversion_status
 Field_time_common::store_time(MYSQL_TIME *ltime,
-                              uint8 dec_arg __attribute__((unused)))
+                              uint8 dec_arg MY_ATTRIBUTE((unused)))
 {
   /* Check if seconds or minutes are out of range */
   if (ltime->second >= 60 || ltime->minute >= 60)
@@ -5725,7 +5725,7 @@ Field_time_common::store_internal_with_round(MYSQL_TIME *ltime, int *warnings)
 
 
 String *Field_time_common::val_str(String *val_buffer,
-                                   String *val_ptr __attribute__((unused)))
+                                   String *val_ptr MY_ATTRIBUTE((unused)))
 {
   ASSERT_COLUMN_MARKED_FOR_READ;
   MYSQL_TIME ltime;
@@ -6039,7 +6039,7 @@ type_conversion_status Field_year::store(double nr)
 
 type_conversion_status
 Field_year::store_time(MYSQL_TIME *ltime,
-                       uint8 dec_arg __attribute__((unused)))
+                       uint8 dec_arg MY_ATTRIBUTE((unused)))
 {
   if (ltime->time_type != MYSQL_TIMESTAMP_DATETIME &&
       ltime->time_type != MYSQL_TIMESTAMP_DATE)
@@ -6103,7 +6103,7 @@ longlong Field_year::val_int(void)
 
 
 String *Field_year::val_str(String *val_buffer,
-			    String *val_ptr __attribute__((unused)))
+			    String *val_ptr MY_ATTRIBUTE((unused)))
 {
   DBUG_ASSERT(field_length < 5);
   val_buffer->alloc(5);
@@ -6203,7 +6203,7 @@ longlong Field_newdate::val_time_temporal()
 
 
 String *Field_newdate::val_str(String *val_buffer,
-			       String *val_ptr __attribute__((unused)))
+			       String *val_ptr MY_ATTRIBUTE((unused)))
 {
   ASSERT_COLUMN_MARKED_FOR_READ;
   val_buffer->alloc(field_length);
@@ -6393,7 +6393,7 @@ longlong Field_datetime::val_int()
   Using my_datetime_number_to_str() instead of my_datetime_to_str().
 */
 String *Field_datetime::val_str(String *val_buffer,
-				String *val_ptr __attribute__((unused)))
+				String *val_ptr MY_ATTRIBUTE((unused)))
 {
   ASSERT_COLUMN_MARKED_FOR_READ;
   val_buffer->alloc(field_length + 1);
@@ -6787,7 +6787,7 @@ longlong Field_string::val_int(void)
 }
 
 
-String *Field_string::val_str(String *val_buffer __attribute__((unused)),
+String *Field_string::val_str(String *val_buffer MY_ATTRIBUTE((unused)),
 			      String *val_ptr)
 {
   ASSERT_COLUMN_MARKED_FOR_READ;
@@ -6845,7 +6845,7 @@ check_field_for_37426(const void *param_arg)
 bool
 Field_string::compatible_field_size(uint field_metadata,
                                     Relay_log_info *rli_arg,
-                                    uint16 mflags __attribute__((unused)),
+                                    uint16 mflags MY_ATTRIBUTE((unused)),
                                     int *order_var)
 {
 #ifdef HAVE_REPLICATION
@@ -6883,7 +6883,7 @@ int Field_string::cmp(const uchar *a_ptr, const uchar *b_ptr)
 
 void Field_string::make_sort_key(uchar *to, uint length)
 {
-  uint tmp __attribute__((unused))=
+  uint tmp MY_ATTRIBUTE((unused))=
     field_charset->coll->strnxfrm(field_charset,
                                   to, length, char_length(),
                                   ptr, field_length,
@@ -6915,7 +6915,7 @@ void Field_string::sql_type(String &res) const
 
 uchar *Field_string::pack(uchar *to, const uchar *from,
                           uint max_length,
-                          bool low_byte_first __attribute__((unused)))
+                          bool low_byte_first MY_ATTRIBUTE((unused)))
 {
   uint length=      min(field_length,max_length);
   uint local_char_length= max_length/field_charset->mbmaxlen;
@@ -6974,7 +6974,7 @@ const uchar *
 Field_string::unpack(uchar *to,
                      const uchar *from,
                      uint param_data,
-                     bool low_byte_first __attribute__((unused)))
+                     bool low_byte_first MY_ATTRIBUTE((unused)))
 {
   uint from_length, length;
 
@@ -7229,7 +7229,7 @@ longlong Field_varstring::val_int(void)
   return result;
 }
 
-String *Field_varstring::val_str(String *val_buffer __attribute__((unused)),
+String *Field_varstring::val_str(String *val_buffer MY_ATTRIBUTE((unused)),
 				 String *val_ptr)
 {
   ASSERT_COLUMN_MARKED_FOR_READ;
@@ -7391,7 +7391,7 @@ uint32 Field_varstring::data_length()
 
 uchar *Field_varstring::pack(uchar *to, const uchar *from,
                              uint max_length,
-                             bool low_byte_first __attribute__((unused)))
+                             bool low_byte_first MY_ATTRIBUTE((unused)))
 {
   uint length= length_bytes == 1 ? (uint) *from : uint2korr(from);
   set_if_smaller(max_length, field_length);
@@ -7428,7 +7428,7 @@ uchar *Field_varstring::pack(uchar *to, const uchar *from,
 const uchar *
 Field_varstring::unpack(uchar *to, const uchar *from,
                         uint param_data,
-                        bool low_byte_first __attribute__((unused)))
+                        bool low_byte_first MY_ATTRIBUTE((unused)))
 {
   uint length;
   uint l_bytes= (param_data && (param_data < field_length)) ? 
@@ -7887,7 +7887,7 @@ longlong Field_blob::val_int(void)
   return my_strntoll(charset(),blob,length,10,NULL,&not_used);
 }
 
-String *Field_blob::val_str(String *val_buffer __attribute__((unused)),
+String *Field_blob::val_str(String *val_buffer MY_ATTRIBUTE((unused)),
 			    String *val_ptr)
 {
   ASSERT_COLUMN_MARKED_FOR_READ;
@@ -8539,7 +8539,7 @@ int Field_enum::do_save_field_metadata(uchar *metadata_ptr)
 }
 
 
-String *Field_enum::val_str(String *val_buffer __attribute__((unused)),
+String *Field_enum::val_str(String *val_buffer MY_ATTRIBUTE((unused)),
 			    String *val_ptr)
 {
   uint tmp=(uint) Field_enum::val_int();
@@ -8683,7 +8683,7 @@ type_conversion_status Field_set::store(longlong nr, bool unsigned_val)
 
 
 String *Field_set::val_str(String *val_buffer,
-			   String *val_ptr __attribute__((unused)))
+			   String *val_ptr MY_ATTRIBUTE((unused)))
 {
   ulonglong tmp=(ulonglong) Field_enum::val_int();
   uint bitnr=0;
@@ -9148,7 +9148,7 @@ longlong Field_bit::val_int(void)
 
 
 String *Field_bit::val_str(String *val_buffer,
-                           String *val_ptr __attribute__((unused)))
+                           String *val_ptr MY_ATTRIBUTE((unused)))
 {
   ASSERT_COLUMN_MARKED_FOR_READ;
   char buff[sizeof(longlong)];
@@ -9308,7 +9308,7 @@ uint Field_bit::pack_length_from_metadata(uint field_metadata)
 */
 bool
 Field_bit::compatible_field_size(uint field_metadata,
-                                 Relay_log_info * __attribute__((unused)),
+                                 Relay_log_info * MY_ATTRIBUTE((unused)),
                                  uint16 mflags,
                                  int *order_var)
 {
@@ -9348,7 +9348,7 @@ void Field_bit::sql_type(String &res) const
 
 uchar *
 Field_bit::pack(uchar *to, const uchar *from, uint max_length,
-                bool low_byte_first __attribute__((unused)))
+                bool low_byte_first MY_ATTRIBUTE((unused)))
 {
   DBUG_ASSERT(max_length > 0);
   uint length;
@@ -9396,7 +9396,7 @@ Field_bit::pack(uchar *to, const uchar *from, uint max_length,
 */
 const uchar *
 Field_bit::unpack(uchar *to, const uchar *from, uint param_data,
-                  bool low_byte_first __attribute__((unused)))
+                  bool low_byte_first MY_ATTRIBUTE((unused)))
 {
   DBUG_ENTER("Field_bit::unpack");
   DBUG_PRINT("enter", ("to: %p, from: %p, param_data: 0x%x",
--- a/sql/field.h
+++ b/sql/field.h
@@ -1,7 +1,7 @@
 #ifndef FIELD_INCLUDED
 #define FIELD_INCLUDED
 
-/* Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -1889,13 +1889,13 @@ public:
     return new Field_long(*this);
   }
   virtual uchar *pack(uchar* to, const uchar *from,
-                      uint max_length __attribute__((unused)),
+                      uint max_length MY_ATTRIBUTE((unused)),
                       bool low_byte_first)
   {
     return pack_int32(to, from, low_byte_first);
   }
   virtual const uchar *unpack(uchar* to, const uchar *from,
-                              uint param_data __attribute__((unused)),
+                              uint param_data MY_ATTRIBUTE((unused)),
                               bool low_byte_first)
   {
     return unpack_int32(to, from, low_byte_first);
@@ -1954,13 +1954,13 @@ public:
     return new Field_longlong(*this);
   }
   virtual uchar *pack(uchar* to, const uchar *from,
-                      uint max_length  __attribute__((unused)),
+                      uint max_length  MY_ATTRIBUTE((unused)),
                       bool low_byte_first)
   {
     return pack_int64(to, from, low_byte_first);
   }
   virtual const uchar *unpack(uchar* to, const uchar *from,
-                              uint param_data __attribute__((unused)),
+                              uint param_data MY_ATTRIBUTE((unused)),
                               bool low_byte_first)
   {
     return unpack_int64(to, from, low_byte_first);
@@ -2560,12 +2560,12 @@ public:
     return new Field_timestamp(*this);
   }
   uchar *pack(uchar *to, const uchar *from,
-              uint max_length __attribute__((unused)), bool low_byte_first)
+              uint max_length MY_ATTRIBUTE((unused)), bool low_byte_first)
   {
     return pack_int32(to, from, low_byte_first);
   }
   const uchar *unpack(uchar* to, const uchar *from,
-                      uint param_data __attribute__((unused)),
+                      uint param_data MY_ATTRIBUTE((unused)),
                       bool low_byte_first)
   {
     return unpack_int32(to, from, low_byte_first);
@@ -2998,12 +2998,12 @@ public:
     return new Field_datetime(*this);
   }
   uchar *pack(uchar* to, const uchar *from,
-              uint max_length __attribute__((unused)), bool low_byte_first)
+              uint max_length MY_ATTRIBUTE((unused)), bool low_byte_first)
   {
     return pack_int64(to, from, low_byte_first);
   }
   const uchar *unpack(uchar* to, const uchar *from,
-                      uint param_data __attribute__((unused)),
+                      uint param_data MY_ATTRIBUTE((unused)),
                       bool low_byte_first)
   {
     return unpack_int64(to, from, low_byte_first);
--- a/sql/field_conv.cc
+++ b/sql/field_conv.cc
@@ -195,7 +195,7 @@ set_field_to_null_with_conversions(Field *field, bool no_conversions)
 }
 
 
-static void do_skip(Copy_field *copy __attribute__((unused)))
+static void do_skip(Copy_field *copy MY_ATTRIBUTE((unused)))
 {
 }
 
--- a/sql/filesort.cc
+++ b/sql/filesort.cc
@@ -1,5 +1,5 @@
 /*
-   Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -1040,7 +1040,7 @@ void make_sortkey(Sort_param *param, uchar *to, uchar *ref_pos)
         if (sort_field->need_strxnfrm)
         {
           char *from=(char*) res->ptr();
-          uint tmp_length __attribute__((unused));
+          uint tmp_length MY_ATTRIBUTE((unused));
           if ((uchar*) from == to)
           {
             DBUG_ASSERT(sort_field->length >= length);
--- a/sql/ha_ndb_index_stat.cc
+++ b/sql/ha_ndb_index_stat.cc
@@ -1,5 +1,5 @@
 /*
-   Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -1727,7 +1727,7 @@ ndb_index_stat_stop_listener(Ndb_index_stat_proc &pr)
 }
 
 pthread_handler_t
-ndb_index_stat_thread_func(void *arg __attribute__((unused)))
+ndb_index_stat_thread_func(void *arg MY_ATTRIBUTE((unused)))
 {
   THD *thd; /* needs to be first for thread_stack */
   struct timespec abstime;
--- a/sql/ha_ndbcluster.cc
+++ b/sql/ha_ndbcluster.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2004, 2015, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2004, 2016, Oracle and/or its affiliates. All rights reserved.
 
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
@@ -417,7 +417,7 @@ pthread_mutex_t ndbcluster_mutex;
 HASH ndbcluster_open_tables;
 
 static uchar *ndbcluster_get_key(NDB_SHARE *share, size_t *length,
-                                my_bool not_used __attribute__((unused)));
+                                my_bool not_used MY_ATTRIBUTE((unused)));
 
 static void modify_shared_stats(NDB_SHARE *share,
                                 Ndb_local_table_statistics *local_stat);
@@ -1293,7 +1293,7 @@ typedef struct st_thd_ndb_share {
 } THD_NDB_SHARE;
 static
 uchar *thd_ndb_share_get_key(THD_NDB_SHARE *thd_ndb_share, size_t *length,
-                            my_bool not_used __attribute__((unused)))
+                            my_bool not_used MY_ATTRIBUTE((unused)))
 {
   *length= sizeof(thd_ndb_share->key);
   return (uchar*) &thd_ndb_share->key;
@@ -11106,7 +11106,7 @@ int ndbcluster_table_exists_in_engine(handlerton *hton, THD* thd,
 
 
 extern "C" uchar* tables_get_key(const char *entry, size_t *length,
-                                my_bool not_used __attribute__((unused)))
+                                my_bool not_used MY_ATTRIBUTE((unused)))
 {
   *length= strlen(entry);
   return (uchar*) entry;
@@ -12657,7 +12657,7 @@ ha_ndbcluster::register_query_cache_table(THD *thd,
 */
 
 static uchar *ndbcluster_get_key(NDB_SHARE *share, size_t *length,
-                                my_bool not_used __attribute__((unused)))
+                                my_bool not_used MY_ATTRIBUTE((unused)))
 {
   *length= share->key_length;
   return (uchar*) share->key;
@@ -14539,7 +14539,7 @@ ha_ndbcluster::update_table_comment(
 /**
   Utility thread main loop.
 */
-pthread_handler_t ndb_util_thread_func(void *arg __attribute__((unused)))
+pthread_handler_t ndb_util_thread_func(void *arg MY_ATTRIBUTE((unused)))
 {
   THD *thd; /* needs to be first for thread_stack */
   struct timespec abstime;
--- a/sql/ha_ndbcluster_binlog.cc
+++ b/sql/ha_ndbcluster_binlog.cc
@@ -1,5 +1,5 @@
 /*
-  Copyright (c) 2006, 2015, Oracle and/or its affiliates. All rights reserved.
+  Copyright (c) 2006, 2016, Oracle and/or its affiliates. All rights reserved.
 
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
@@ -6252,7 +6252,7 @@ private:
 static uchar *
 ndb_schema_objects_get_key(NDB_SCHEMA_OBJECT *schema_object,
                            size_t *length,
-                           my_bool not_used __attribute__((unused)))
+                           my_bool not_used MY_ATTRIBUTE((unused)))
 {
   *length= schema_object->key_length;
   return (uchar*) schema_object->key;
--- a/sql/ha_partition.cc
+++ b/sql/ha_partition.cc
@@ -1,5 +1,5 @@
 /*
-   Copyright (c) 2005, 2015, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2005, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -222,7 +222,7 @@ static uint partition_flags()
   return HA_CAN_PARTITION;
 }
 
-static uint alter_table_flags(uint flags __attribute__((unused)))
+static uint alter_table_flags(uint flags MY_ATTRIBUTE((unused)))
 {
   return (HA_PARTITION_FUNCTION_SUPPORTED |
           HA_FAST_CHANGE_PARTITION);
@@ -1670,9 +1670,9 @@ int ha_partition::change_partitions(HA_CREATE_INFO *create_info,
                                     ulonglong * const copied,
                                     ulonglong * const deleted,
                                     const uchar *pack_frm_data
-                                    __attribute__((unused)),
+                                    MY_ATTRIBUTE((unused)),
                                     size_t pack_frm_len
-                                    __attribute__((unused)))
+                                    MY_ATTRIBUTE((unused)))
 {
   List_iterator<partition_element> part_it(m_part_info->partitions);
   List_iterator <partition_element> t_it(m_part_info->temp_partitions);
@@ -2956,7 +2956,7 @@ bool ha_partition::get_from_handler_file(const char *name, MEM_ROOT *mem_root,
 */
 
 static uchar *get_part_name(PART_NAME_DEF *part, size_t *length,
-                            my_bool not_used __attribute__((unused)))
+                            my_bool not_used MY_ATTRIBUTE((unused)))
 {
   *length= part->length;
   return part->partition_name;
--- a/sql/handler.cc
+++ b/sql/handler.cc
@@ -6278,7 +6278,7 @@ end:
 ha_rows DsMrr_impl::dsmrr_info(uint keyno, uint n_ranges, uint rows,
                                uint *bufsz, uint *flags, Cost_estimate *cost)
 {  
-  ha_rows res __attribute__((unused));
+  ha_rows res MY_ATTRIBUTE((unused));
   uint def_flags= *flags;
   uint def_bufsz= *bufsz;
 
--- a/sql/handler.h
+++ b/sql/handler.h
@@ -3067,7 +3067,7 @@ private:
   */
   virtual int rnd_init(bool scan)= 0;
   virtual int rnd_end() { return 0; }
-  virtual int write_row(uchar *buf __attribute__((unused)))
+  virtual int write_row(uchar *buf MY_ATTRIBUTE((unused)))
   {
     return HA_ERR_WRONG_COMMAND;
   }
@@ -3080,13 +3080,13 @@ private:
     the columns required for the error message are not read, the error
     message will contain garbage.
   */
-  virtual int update_row(const uchar *old_data __attribute__((unused)),
-                         uchar *new_data __attribute__((unused)))
+  virtual int update_row(const uchar *old_data MY_ATTRIBUTE((unused)),
+                         uchar *new_data MY_ATTRIBUTE((unused)))
   {
     return HA_ERR_WRONG_COMMAND;
   }
 
-  virtual int delete_row(const uchar *buf __attribute__((unused)))
+  virtual int delete_row(const uchar *buf MY_ATTRIBUTE((unused)))
   {
     return HA_ERR_WRONG_COMMAND;
   }
@@ -3119,8 +3119,8 @@ private:
     @return  non-0 in case of failure, 0 in case of success.
     When lock_type is F_UNLCK, the return value is ignored.
   */
-  virtual int external_lock(THD *thd __attribute__((unused)),
-                            int lock_type __attribute__((unused)))
+  virtual int external_lock(THD *thd MY_ATTRIBUTE((unused)),
+                            int lock_type MY_ATTRIBUTE((unused)))
   {
     return 0;
   }
--- a/sql/hostname.cc
+++ b/sql/hostname.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -413,7 +413,7 @@ int ip_to_hostname(struct sockaddr_storage *ip_storage,
 {
   const struct sockaddr *ip= (const sockaddr *) ip_storage;
   int err_code;
-  bool err_status __attribute__((unused));
+  bool err_status MY_ATTRIBUTE((unused));
   Host_errors errors;
 
   DBUG_ENTER("ip_to_hostname");
--- a/sql/init.h
+++ b/sql/init.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2006, 2010, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2006, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -19,6 +19,6 @@
 #include "my_global.h"                          /* ulong */
 
 void unireg_init(ulong options);
-void unireg_end(void) __attribute__((noreturn));
+void unireg_end(void) MY_ATTRIBUTE((noreturn));
 
 #endif /* INIT_INCLUDED */
--- a/sql/item.cc
+++ b/sql/item.cc
@@ -3413,8 +3413,8 @@ Item *Item_null::safe_charset_converter(const CHARSET_INFO *tocs)
 
 static void
 default_set_param_func(Item_param *param,
-                       uchar **pos __attribute__((unused)),
-                       ulong len __attribute__((unused)))
+                       uchar **pos MY_ATTRIBUTE((unused)),
+                       ulong len MY_ATTRIBUTE((unused)))
 {
   param->set_null();
 }
--- a/sql/item_func.cc
+++ b/sql/item_func.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -3985,7 +3985,7 @@ public:
 };
 
 uchar *ull_get_key(const User_level_lock *ull, size_t *length,
-                   my_bool not_used __attribute__((unused)))
+                   my_bool not_used MY_ATTRIBUTE((unused)))
 {
   *length= ull->key_length;
   return ull->key;
--- a/sql/item_sum.cc
+++ b/sql/item_sum.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
    rights reserved.
 
    This program is free software; you can redistribute it and/or modify
@@ -3070,7 +3070,7 @@ int group_concat_key_cmp_with_order(const void* arg, const void* key1,
 */
 
 extern "C"
-int dump_leaf_key(void* key_arg, element_count count __attribute__((unused)),
+int dump_leaf_key(void* key_arg, element_count count MY_ATTRIBUTE((unused)),
                   void* item_arg)
 {
   Item_func_group_concat *item= (Item_func_group_concat *) item_arg;
--- a/sql/item_sum.h
+++ b/sql/item_sum.h
@@ -1,7 +1,7 @@
 #ifndef ITEM_SUM_INCLUDED
 #define ITEM_SUM_INCLUDED
 
-/* Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved. reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved. reserved.
    reserved.
 
    This program is free software; you can redistribute it and/or modify
@@ -1417,7 +1417,7 @@ int group_concat_key_cmp_with_distinct(const void* arg, const void* key1,
 int group_concat_key_cmp_with_order(const void* arg, const void* key1,
                                     const void* key2);
 int dump_leaf_key(void* key_arg,
-                  element_count count __attribute__((unused)),
+                  element_count count MY_ATTRIBUTE((unused)),
                   void* item_arg);
 C_MODE_END
 
@@ -1463,7 +1463,7 @@ class Item_func_group_concat : public Item_sum
                                              const void* key1,
 					     const void* key2);
   friend int dump_leaf_key(void* key_arg,
-                           element_count count __attribute__((unused)),
+                           element_count count MY_ATTRIBUTE((unused)),
 			   void* item_arg);
 
 public:
--- a/sql/item_timefunc.cc
+++ b/sql/item_timefunc.cc
@@ -1,5 +1,5 @@
 /*
-   Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -1902,7 +1902,7 @@ Item_func_now::save_in_field(Field *to, bool no_conversions)
     time zone. Defines time zone (local) used for whole SYSDATE function.
 */
 bool Item_func_sysdate_local::get_date(MYSQL_TIME *now_time,
-                                       uint fuzzy_date __attribute__((unused)))
+                                       uint fuzzy_date MY_ATTRIBUTE((unused)))
 {
   THD *thd= current_thd;
   ulonglong tmp= my_micro_time();
@@ -2138,7 +2138,7 @@ void Item_func_from_unixtime::fix_length_and_dec()
 
 
 bool Item_func_from_unixtime::get_date(MYSQL_TIME *ltime,
-				       uint fuzzy_date __attribute__((unused)))
+				       uint fuzzy_date MY_ATTRIBUTE((unused)))
 {
   lldiv_t lld;
   if (decimals)
@@ -2177,7 +2177,7 @@ void Item_func_convert_tz::fix_length_and_dec()
 
 
 bool Item_func_convert_tz::get_date(MYSQL_TIME *ltime,
-                                    uint fuzzy_date __attribute__((unused)))
+                                    uint fuzzy_date MY_ATTRIBUTE((unused)))
 {
   my_time_t my_time_tmp;
   String str;
--- a/sql/log_event.cc
+++ b/sql/log_event.cc
@@ -1740,7 +1740,7 @@ Log_event* Log_event::read_log_event(const char* buf, uint event_len,
 
 void Log_event::print_header(IO_CACHE* file,
                              PRINT_EVENT_INFO* print_event_info,
-                             bool is_more __attribute__((unused)))
+                             bool is_more MY_ATTRIBUTE((unused)))
 {
   char llbuff[22];
   my_off_t hexdump_from= print_event_info->hexdump_from;
@@ -2724,7 +2724,7 @@ Slave_worker *Log_event::get_slave_worker(Relay_log_info *rli)
   {
     if (!rli->curr_group_seen_gtid && !rli->curr_group_seen_begin)
     {
-      ulong gaq_idx __attribute__((unused));
+      ulong gaq_idx MY_ATTRIBUTE((unused));
       rli->mts_groups_assigned++;
 
       rli->curr_group_isolated= FALSE;
--- a/sql/log_event.h
+++ b/sql/log_event.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -1311,7 +1311,7 @@ public:
   }
   virtual bool write_data_header(IO_CACHE* file)
   { return 0; }
-  virtual bool write_data_body(IO_CACHE* file __attribute__((unused)))
+  virtual bool write_data_body(IO_CACHE* file MY_ATTRIBUTE((unused)))
   { return 0; }
   inline time_t get_time()
   {
@@ -4520,7 +4520,7 @@ public:
   static bool binlog_row_logging_function(THD *thd, TABLE *table,
                                           bool is_transactional,
                                           const uchar *before_record
-                                          __attribute__((unused)),
+                                          MY_ATTRIBUTE((unused)),
                                           const uchar *after_record)
   {
     return thd->binlog_write_row(table, is_transactional,
@@ -4660,7 +4660,7 @@ public:
                                           bool is_transactional,
                                           const uchar *before_record,
                                           const uchar *after_record
-                                          __attribute__((unused)))
+                                          MY_ATTRIBUTE((unused)))
   {
     return thd->binlog_delete_row(table, is_transactional,
                                   before_record, NULL);
--- a/sql/log_event_old.h
+++ b/sql/log_event_old.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2007, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -369,7 +369,7 @@ public:
   static bool binlog_row_logging_function(THD *thd, TABLE *table,
                                           bool is_transactional,
                                           const uchar *before_record
-                                          __attribute__((unused)),
+                                          MY_ATTRIBUTE((unused)),
                                           const uchar *after_record)
   {
     return thd->binlog_write_row(table, is_transactional,
@@ -518,7 +518,7 @@ public:
                                           bool is_transactional,
                                           const uchar *before_record,
                                           const uchar *after_record
-                                          __attribute__((unused)))
+                                          MY_ATTRIBUTE((unused)))
   {
     return thd->binlog_delete_row(table, is_transactional,
                                   before_record, NULL);
--- a/sql/mdl.cc
+++ b/sql/mdl.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2007, 2015, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2007, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -94,7 +94,7 @@ void MDL_key::init_psi_keys()
 {
   int i;
   int count;
-  PSI_stage_info *info __attribute__((unused));
+  PSI_stage_info *info MY_ATTRIBUTE((unused));
 
   count= array_elements(MDL_key::m_namespace_to_wait_state_name);
   for (i= 0; i<count; i++)
@@ -651,7 +651,7 @@ extern "C"
 {
 static uchar *
 mdl_locks_key(const uchar *record, size_t *length,
-              my_bool not_used __attribute__((unused)))
+              my_bool not_used MY_ATTRIBUTE((unused)))
 {
   MDL_lock *lock=(MDL_lock*) record;
   *length= lock->key.length();
--- a/sql/mf_iocache.cc
+++ b/sql/mf_iocache.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2010, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -49,7 +49,7 @@ extern "C" {
 
 
 int _my_b_net_read(register IO_CACHE *info, uchar *Buffer,
-		   size_t Count __attribute__((unused)))
+		   size_t Count MY_ATTRIBUTE((unused)))
 {
   ulong read_length;
   NET *net= &(current_thd)->net;
--- a/sql/mysqld.cc
+++ b/sql/mysqld.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights
    reserved.
 
    This program is free software; you can redistribute it and/or modify
@@ -1303,7 +1303,7 @@ static void close_server_sock();
 static void clean_up_mutexes(void);
 static void wait_for_signal_thread_to_end(void);
 static void create_pid_file();
-static void mysqld_exit(int exit_code) __attribute__((noreturn));
+static void mysqld_exit(int exit_code) MY_ATTRIBUTE((noreturn));
 #endif
 static void delete_pid_file(myf flags);
 static void end_ssl();
@@ -1715,7 +1715,7 @@ static void __cdecl kill_server(int sig_ptr)
 
 
 #if defined(USE_ONE_SIGNAL_HAND)
-pthread_handler_t kill_server_thread(void *arg __attribute__((unused)))
+pthread_handler_t kill_server_thread(void *arg MY_ATTRIBUTE((unused)))
 {
   my_thread_init();       // Initialize new thread
   kill_server(0);
@@ -2619,7 +2619,7 @@ void close_connection(THD *thd, uint sql_errno)
 
 /** Called when a thread is aborted. */
 /* ARGSUSED */
-extern "C" sig_handler end_thread_signal(int sig __attribute__((unused)))
+extern "C" sig_handler end_thread_signal(int sig MY_ATTRIBUTE((unused)))
 {
   THD *thd=current_thd;
   my_safe_printf_stderr("end_thread_signal %p", thd);
@@ -2824,7 +2824,7 @@ void kill_blocked_pthreads()
   @todo
     One should have to fix that thr_alarm know about this thread too.
 */
-extern "C" sig_handler abort_thread(int sig __attribute__((unused)))
+extern "C" sig_handler abort_thread(int sig MY_ATTRIBUTE((unused)))
 {
   THD *thd=current_thd;
   DBUG_ENTER("abort_thread");
@@ -3135,7 +3135,7 @@ static void start_signal_handler(void)
 
 /** This threads handles all signals and alarms. */
 /* ARGSUSED */
-pthread_handler_t signal_hand(void *arg __attribute__((unused)))
+pthread_handler_t signal_hand(void *arg MY_ATTRIBUTE((unused)))
 {
   sigset_t set;
   int sig;
@@ -8384,7 +8384,7 @@ static int mysql_init_variables(void)
 
 my_bool
 mysqld_get_one_option(int optid,
-                      const struct my_option *opt __attribute__((unused)),
+                      const struct my_option *opt MY_ATTRIBUTE((unused)),
                       char *argument)
 {
   switch(optid) {
--- a/sql/mysqld.h
+++ b/sql/mysqld.h
@@ -710,10 +710,10 @@ typedef int64 query_id_t;
 extern query_id_t global_query_id;
 extern my_atomic_rwlock_t global_query_id_lock;
 
-void unireg_end(void) __attribute__((noreturn));
+void unireg_end(void) MY_ATTRIBUTE((noreturn));
 
 /* increment query_id and return it.  */
-inline __attribute__((warn_unused_result)) query_id_t next_query_id()
+inline MY_ATTRIBUTE((warn_unused_result)) query_id_t next_query_id()
 {
   query_id_t id;
   my_atomic_rwlock_wrlock(&global_query_id_lock);
@@ -726,7 +726,7 @@ inline __attribute__((warn_unused_result)) query_id_t next_query_id()
   TODO: Replace this with an inline function.
  */
 #ifndef EMBEDDED_LIBRARY
-extern "C" void unireg_abort(int exit_code) __attribute__((noreturn));
+extern "C" void unireg_abort(int exit_code) MY_ATTRIBUTE((noreturn));
 #else
 extern "C" void unireg_clear(int exit_code);
 #define unireg_abort(exit_code) do { unireg_clear(exit_code); DBUG_RETURN(exit_code); } while(0)
--- a/sql/net_serv.cc
+++ b/sql/net_serv.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -191,7 +191,7 @@ my_bool net_realloc(NET *net, size_t length)
 */
 
 void net_clear(NET *net,
-               my_bool check_buffer __attribute__((unused)))
+               my_bool check_buffer MY_ATTRIBUTE((unused)))
 {
   DBUG_ENTER("net_clear");
 
@@ -238,7 +238,7 @@ my_bool net_flush(NET *net)
 */
 
 static my_bool
-net_should_retry(NET *net, uint *retry_count __attribute__((unused)))
+net_should_retry(NET *net, uint *retry_count MY_ATTRIBUTE((unused)))
 {
   my_bool retry;
 
--- a/sql/partition_info.cc
+++ b/sql/partition_info.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2006, 2015, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2006, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -945,7 +945,7 @@ partition_element *partition_info::get_part_elem(const char *partition_name,
 */
 
 static const char *get_part_name_from_elem(const char *name, size_t *length,
-                                      my_bool not_used __attribute__((unused)))
+                                      my_bool not_used MY_ATTRIBUTE((unused)))
 {
   *length= strlen(name);
   return name;
--- a/sql/rpl_filter.cc
+++ b/sql/rpl_filter.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -508,7 +508,7 @@ extern "C" uchar *get_table_key(const uchar *, size_t *, my_bool);
 extern "C" void free_table_ent(void* a);
 
 uchar *get_table_key(const uchar* a, size_t *len,
-                     my_bool __attribute__((unused)))
+                     my_bool MY_ATTRIBUTE((unused)))
 {
   TABLE_RULE_ENT *e= (TABLE_RULE_ENT *) a;
 
--- a/sql/rpl_info_dummy.cc
+++ b/sql/rpl_info_dummy.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010, 2012, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -21,7 +21,7 @@ Rpl_info_dummy::Rpl_info_dummy(const int nparam)
 {
 }
 
-int Rpl_info_dummy::do_init_info(uint instance __attribute__((unused)))
+int Rpl_info_dummy::do_init_info(uint instance MY_ATTRIBUTE((unused)))
 {
   return 0;
 }
@@ -51,13 +51,13 @@ enum_return_check Rpl_info_dummy::do_check_info()
   return REPOSITORY_DOES_NOT_EXIST;
 }
 
-enum_return_check Rpl_info_dummy::do_check_info(uint instance __attribute__((unused)))
+enum_return_check Rpl_info_dummy::do_check_info(uint instance MY_ATTRIBUTE((unused)))
 {
   DBUG_ASSERT(!abort);
   return REPOSITORY_DOES_NOT_EXIST;
 }
 
-int Rpl_info_dummy::do_flush_info(const bool force __attribute__((unused)))
+int Rpl_info_dummy::do_flush_info(const bool force MY_ATTRIBUTE((unused)))
 {
   DBUG_ASSERT(!abort);
   return 0;
@@ -85,105 +85,105 @@ uint Rpl_info_dummy::do_get_rpl_info_type()
   return INFO_REPOSITORY_DUMMY;
 }
 
-bool Rpl_info_dummy::do_set_info(const int pos __attribute__((unused)),
-                                const char *value __attribute__((unused)))
+bool Rpl_info_dummy::do_set_info(const int pos MY_ATTRIBUTE((unused)),
+                                const char *value MY_ATTRIBUTE((unused)))
 {
   DBUG_ASSERT(!abort);
 
   return FALSE;
 }
 
-bool Rpl_info_dummy::do_set_info(const int pos __attribute__((unused)),
-                                const uchar *value __attribute__((unused)),
-                                const size_t size __attribute__((unused)))
+bool Rpl_info_dummy::do_set_info(const int pos MY_ATTRIBUTE((unused)),
+                                const uchar *value MY_ATTRIBUTE((unused)),
+                                const size_t size MY_ATTRIBUTE((unused)))
 {
   DBUG_ASSERT(!abort);
 
   return FALSE;
 }
 
-bool Rpl_info_dummy::do_set_info(const int pos __attribute__((unused)),
-                                const ulong value __attribute__((unused)))
+bool Rpl_info_dummy::do_set_info(const int pos MY_ATTRIBUTE((unused)),
+                                const ulong value MY_ATTRIBUTE((unused)))
 {
   DBUG_ASSERT(!abort);
 
   return FALSE;
 }
 
-bool Rpl_info_dummy::do_set_info(const int pos __attribute__((unused)),
-                                const int value __attribute__((unused)))
+bool Rpl_info_dummy::do_set_info(const int pos MY_ATTRIBUTE((unused)),
+                                const int value MY_ATTRIBUTE((unused)))
 {
   DBUG_ASSERT(!abort);
 
   return FALSE;
 }
 
-bool Rpl_info_dummy::do_set_info(const int pos __attribute__((unused)),
-                                const float value __attribute__((unused)))
+bool Rpl_info_dummy::do_set_info(const int pos MY_ATTRIBUTE((unused)),
+                                const float value MY_ATTRIBUTE((unused)))
 {
   DBUG_ASSERT(!abort);
 
   return FALSE;
 }
 
-bool Rpl_info_dummy::do_set_info(const int pos __attribute__((unused)),
-                                const Dynamic_ids *value __attribute__((unused)))
+bool Rpl_info_dummy::do_set_info(const int pos MY_ATTRIBUTE((unused)),
+                                const Dynamic_ids *value MY_ATTRIBUTE((unused)))
 {
   DBUG_ASSERT(!abort);
 
   return FALSE;
 }
 
-bool Rpl_info_dummy::do_get_info(const int pos __attribute__((unused)),
-                                char *value __attribute__((unused)),
-                                const size_t size __attribute__((unused)),
-                                const char *default_value __attribute__((unused)))
+bool Rpl_info_dummy::do_get_info(const int pos MY_ATTRIBUTE((unused)),
+                                char *value MY_ATTRIBUTE((unused)),
+                                const size_t size MY_ATTRIBUTE((unused)),
+                                const char *default_value MY_ATTRIBUTE((unused)))
 {
     DBUG_ASSERT(!abort);
 
   return FALSE;
 }
 
-bool Rpl_info_dummy::do_get_info(const int pos __attribute__((unused)),
-                                uchar *value __attribute__((unused)),
-                                const size_t size __attribute__((unused)),
-                                const uchar *default_value __attribute__((unused)))
+bool Rpl_info_dummy::do_get_info(const int pos MY_ATTRIBUTE((unused)),
+                                uchar *value MY_ATTRIBUTE((unused)),
+                                const size_t size MY_ATTRIBUTE((unused)),
+                                const uchar *default_value MY_ATTRIBUTE((unused)))
 {
   DBUG_ASSERT(!abort);
 
   return FALSE;
 }
 
-bool Rpl_info_dummy::do_get_info(const int pos __attribute__((unused)),
-                                ulong *value __attribute__((unused)),
-                                const ulong default_value __attribute__((unused)))
+bool Rpl_info_dummy::do_get_info(const int pos MY_ATTRIBUTE((unused)),
+                                ulong *value MY_ATTRIBUTE((unused)),
+                                const ulong default_value MY_ATTRIBUTE((unused)))
 {
   DBUG_ASSERT(!abort);
 
   return FALSE;
 }
 
-bool Rpl_info_dummy::do_get_info(const int pos __attribute__((unused)),
-                                int *value __attribute__((unused)),
-                                const int default_value __attribute__((unused)))
+bool Rpl_info_dummy::do_get_info(const int pos MY_ATTRIBUTE((unused)),
+                                int *value MY_ATTRIBUTE((unused)),
+                                const int default_value MY_ATTRIBUTE((unused)))
 {
   DBUG_ASSERT(!abort);
 
   return FALSE;
 }
 
-bool Rpl_info_dummy::do_get_info(const int pos __attribute__((unused)),
-                                float *value __attribute__((unused)),
-                                const float default_value __attribute__((unused)))
+bool Rpl_info_dummy::do_get_info(const int pos MY_ATTRIBUTE((unused)),
+                                float *value MY_ATTRIBUTE((unused)),
+                                const float default_value MY_ATTRIBUTE((unused)))
 {
   DBUG_ASSERT(!abort);
 
   return FALSE;
 }
 
-bool Rpl_info_dummy::do_get_info(const int pos __attribute__((unused)),
-                                Dynamic_ids *value __attribute__((unused)),
-                                const Dynamic_ids *default_value __attribute__((unused)))
+bool Rpl_info_dummy::do_get_info(const int pos MY_ATTRIBUTE((unused)),
+                                Dynamic_ids *value MY_ATTRIBUTE((unused)),
+                                const Dynamic_ids *default_value MY_ATTRIBUTE((unused)))
 {
   DBUG_ASSERT(!abort);
 
--- a/sql/rpl_info_file.cc
+++ b/sql/rpl_info_file.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010, 2011, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -438,7 +438,7 @@ bool Rpl_info_file::do_get_info(const int pos, float *value,
 }
 
 bool Rpl_info_file::do_get_info(const int pos, Dynamic_ids *value,
-                                const Dynamic_ids *default_value __attribute__((unused)))
+                                const Dynamic_ids *default_value MY_ATTRIBUTE((unused)))
 {
   /*
     Static buffer to use most of the times. However, if it is not big
--- a/sql/rpl_info_table.cc
+++ b/sql/rpl_info_table.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -600,7 +600,7 @@ bool Rpl_info_table::do_get_info(const int pos, char *value, const size_t size,
 }
 
 bool Rpl_info_table::do_get_info(const int pos, uchar *value, const size_t size,
-                                 const uchar *default_value __attribute__((unused)))
+                                 const uchar *default_value MY_ATTRIBUTE((unused)))
 {
   if (field_values->value[pos].length() == size)
     return (!memcpy((char *) value, (char *)
@@ -661,7 +661,7 @@ bool Rpl_info_table::do_get_info(const int pos, float *value,
 }
 
 bool Rpl_info_table::do_get_info(const int pos, Dynamic_ids *value,
-                                 const Dynamic_ids *default_value __attribute__((unused)))
+                                 const Dynamic_ids *default_value MY_ATTRIBUTE((unused)))
 {
   if (value->unpack_dynamic_ids(field_values->value[pos].c_ptr_safe()))
     return TRUE;
--- a/sql/rpl_master.cc
+++ b/sql/rpl_master.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010, 2015, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -62,7 +62,7 @@ extern TYPELIB binlog_checksum_typelib;
 
 extern "C" uint32
 *slave_list_key(SLAVE_INFO* si, size_t *len,
-		my_bool not_used __attribute__((unused)))
+		my_bool not_used MY_ATTRIBUTE((unused)))
 {
   *len = 4;
   return &si->server_id;
--- a/sql/rpl_mi.cc
+++ b/sql/rpl_mi.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2006, 2013, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2006, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -542,7 +542,7 @@ bool Master_info::write_info(Rpl_info_handler *to)
 }
 
 bool Master_info::set_password(const char* password_arg,
-                               int password_arg_size __attribute__((unused)))
+                               int password_arg_size MY_ATTRIBUTE((unused)))
 {
   bool ret= true;
   DBUG_ENTER("Master_info::set_password");
--- a/sql/rpl_rli_pdb.cc
+++ b/sql/rpl_rli_pdb.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -629,7 +629,7 @@ static  mysql_cond_t slave_worker_hash_cond;
 
 
 extern "C" uchar *get_key(const uchar *record, size_t *length,
-                          my_bool not_used __attribute__((unused)))
+                          my_bool not_used MY_ATTRIBUTE((unused)))
 {
   DBUG_ENTER("get_key");
 
@@ -1490,7 +1490,7 @@ ulong Slave_committed_queue::move_queue_head(DYNAMIC_ARRAY *ws)
     Slave_worker *w_i;
     Slave_job_group *ptr_g, g;
     char grl_name[FN_REFLEN];
-    ulong ind __attribute__((unused));
+    ulong ind MY_ATTRIBUTE((unused));
 
 #ifndef DBUG_OFF
     if (DBUG_EVALUATE_IF("check_slave_debug_group", 1, 0) &&
--- a/sql/rpl_slave.cc
+++ b/sql/rpl_slave.cc
@@ -1384,7 +1384,7 @@ terminate_slave_thread(THD *thd,
 
   while (*slave_running)                        // Should always be true
   {
-    int error __attribute__((unused));
+    int error MY_ATTRIBUTE((unused));
     DBUG_PRINT("loop", ("killing slave thread"));
 
     mysql_mutex_lock(&thd->LOCK_thd_data);
@@ -1394,7 +1394,7 @@ terminate_slave_thread(THD *thd,
       EINVAL: invalid signal number (can't happen)
       ESRCH: thread already killed (can happen, should be ignored)
     */
-    int err __attribute__((unused))= pthread_kill(thd->real_id, thr_client_alarm);
+    int err MY_ATTRIBUTE((unused))= pthread_kill(thd->real_id, thr_client_alarm);
     DBUG_ASSERT(err != EINVAL);
 #endif
     thd->awake(THD::NOT_KILLED);
--- a/sql/rpl_utility.cc
+++ b/sql/rpl_utility.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2006, 2014, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2006, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -1243,7 +1243,7 @@ bool event_checksum_test(uchar *event_buf, ulong event_len, uint8 alg)
 static uchar*
 hash_slave_rows_get_key(const uchar *record,
                         size_t *length,
-                        my_bool not_used __attribute__((unused)))
+                        my_bool not_used MY_ATTRIBUTE((unused)))
 {
   DBUG_ENTER("get_key");
 
--- a/sql/sql_acl.cc
+++ b/sql/sql_acl.cc
@@ -625,7 +625,7 @@ public:
 
 
 static uchar* acl_entry_get_key(acl_entry *entry, size_t *length,
-                                my_bool not_used __attribute__((unused)))
+                                my_bool not_used MY_ATTRIBUTE((unused)))
 {
   *length=(uint) entry->length;
   return (uchar*) entry->key;
@@ -1673,7 +1673,7 @@ bool acl_getroot(Security_context *sctx, char *user, char *host,
 }
 
 static uchar* check_get_key(ACL_USER *buff, size_t *length,
-                            my_bool not_used __attribute__((unused)))
+                            my_bool not_used MY_ATTRIBUTE((unused)))
 {
   *length=buff->host.get_host_len();
   return (uchar*) buff->host.get_host();
@@ -3607,7 +3607,7 @@ public:
 
 
 static uchar* get_key_column(GRANT_COLUMN *buff, size_t *length,
-			    my_bool not_used __attribute__((unused)))
+			    my_bool not_used MY_ATTRIBUTE((unused)))
 {
   *length=buff->key_length;
   return (uchar*) buff->column;
@@ -3800,7 +3800,7 @@ GRANT_TABLE::~GRANT_TABLE()
 
 
 static uchar* get_grant_table(GRANT_NAME *buff, size_t *length,
-			     my_bool not_used __attribute__((unused)))
+			     my_bool not_used MY_ATTRIBUTE((unused)))
 {
   *length=buff->key_length;
   return (uchar*) buff->hash_key;
--- a/sql/sql_analyse.cc
+++ b/sql/sql_analyse.cc
@@ -1,5 +1,5 @@
 /*
-   Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -34,25 +34,25 @@
 using std::min;
 using std::max;
 
-int sortcmp2(void* cmp_arg __attribute__((unused)),
+int sortcmp2(void* cmp_arg MY_ATTRIBUTE((unused)),
 	     const String *a,const String *b)
 {
   return sortcmp(a,b,a->charset());
 }
 
-int compare_double2(void* cmp_arg __attribute__((unused)),
+int compare_double2(void* cmp_arg MY_ATTRIBUTE((unused)),
 		    const double *s, const double *t)
 {
   return compare_double(s,t);
 }
 
-int compare_longlong2(void* cmp_arg __attribute__((unused)),
+int compare_longlong2(void* cmp_arg MY_ATTRIBUTE((unused)),
 		      const longlong *s, const longlong *t)
 {
   return compare_longlong(s,t);
 }
 
-int compare_ulonglong2(void* cmp_arg __attribute__((unused)),
+int compare_ulonglong2(void* cmp_arg MY_ATTRIBUTE((unused)),
 		       const ulonglong *s, const ulonglong *t)
 {
   return compare_ulonglong(s,t);
@@ -835,7 +835,7 @@ void field_str::get_opt_type(String *answer, ha_rows total_rows)
 
 
 void field_real::get_opt_type(String *answer,
-			      ha_rows total_rows __attribute__((unused)))
+			      ha_rows total_rows MY_ATTRIBUTE((unused)))
 {
   char buff[MAX_FIELD_WIDTH];
 
@@ -888,7 +888,7 @@ void field_real::get_opt_type(String *answer,
 
 
 void field_longlong::get_opt_type(String *answer,
-				  ha_rows total_rows __attribute__((unused)))
+				  ha_rows total_rows MY_ATTRIBUTE((unused)))
 {
   char buff[MAX_FIELD_WIDTH];
 
@@ -919,7 +919,7 @@ void field_longlong::get_opt_type(String *answer,
 
 
 void field_ulonglong::get_opt_type(String *answer,
-				   ha_rows total_rows __attribute__((unused)))
+				   ha_rows total_rows MY_ATTRIBUTE((unused)))
 {
   char buff[MAX_FIELD_WIDTH];
 
@@ -944,7 +944,7 @@ void field_ulonglong::get_opt_type(String *answer,
 
 
 void field_decimal::get_opt_type(String *answer,
-                                 ha_rows total_rows __attribute__((unused)))
+                                 ha_rows total_rows MY_ATTRIBUTE((unused)))
 {
   my_decimal zero;
   char buff[MAX_FIELD_WIDTH];
@@ -1022,7 +1022,7 @@ String *field_decimal::std(String *s, ha_rows rows)
 
 
 int collect_string(String *element,
-		   element_count count __attribute__((unused)),
+		   element_count count MY_ATTRIBUTE((unused)),
 		   TREE_INFO *info)
 {
   if (info->found)
@@ -1037,7 +1037,7 @@ int collect_string(String *element,
 } // collect_string
 
 
-int collect_real(double *element, element_count count __attribute__((unused)),
+int collect_real(double *element, element_count count MY_ATTRIBUTE((unused)),
 		 TREE_INFO *info)
 {
   char buff[MAX_FIELD_WIDTH];
@@ -1078,7 +1078,7 @@ int collect_decimal(uchar *element, element_count count,
 
 
 int collect_longlong(longlong *element,
-		     element_count count __attribute__((unused)),
+		     element_count count MY_ATTRIBUTE((unused)),
 		     TREE_INFO *info)
 {
   char buff[MAX_FIELD_WIDTH];
@@ -1097,7 +1097,7 @@ int collect_longlong(longlong *element,
 
 
 int collect_ulonglong(ulonglong *element,
-		      element_count count __attribute__((unused)),
+		      element_count count MY_ATTRIBUTE((unused)),
 		      TREE_INFO *info)
 {
   char buff[MAX_FIELD_WIDTH];
--- a/sql/sql_analyse.h
+++ b/sql/sql_analyse.h
@@ -1,7 +1,7 @@
 #ifndef SQL_ANALYSE_INCLUDED
 #define SQL_ANALYSE_INCLUDED
 
-/* Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -53,13 +53,13 @@ uint check_ulonglong(const char *str, uint length);
 bool get_ev_num_info(EV_NUM_INFO *ev_info, NUM_INFO *info, const char *num);
 bool test_if_number(NUM_INFO *info, const char *str, uint str_len);
 int compare_double(const double *s, const double *t);
-int compare_double2(void* cmp_arg __attribute__((unused)),
+int compare_double2(void* cmp_arg MY_ATTRIBUTE((unused)),
 		    const double *s, const double *t);
 int compare_longlong(const longlong *s, const longlong *t);
-int compare_longlong2(void* cmp_arg __attribute__((unused)),
+int compare_longlong2(void* cmp_arg MY_ATTRIBUTE((unused)),
 		      const longlong *s, const longlong *t);
 int compare_ulonglong(const ulonglong *s, const ulonglong *t);
-int compare_ulonglong2(void* cmp_arg __attribute__((unused)),
+int compare_ulonglong2(void* cmp_arg MY_ATTRIBUTE((unused)),
 		       const ulonglong *s, const ulonglong *t);
 int compare_decimal2(int* len, const char *s, const char *t);
 void free_string(String*);
@@ -97,7 +97,7 @@ public:
 int collect_string(String *element, element_count count,
 		   TREE_INFO *info);
 
-int sortcmp2(void* cmp_arg __attribute__((unused)),
+int sortcmp2(void* cmp_arg MY_ATTRIBUTE((unused)),
 	     const String *a,const String *b);
 
 class field_str :public field_info
@@ -120,9 +120,9 @@ public:
 
   void	 add();
   void	 get_opt_type(String*, ha_rows);
-  String *get_min_arg(String *not_used __attribute__((unused)))
+  String *get_min_arg(String *not_used MY_ATTRIBUTE((unused)))
   { return &min_arg; }
-  String *get_max_arg(String *not_used __attribute__((unused)))
+  String *get_max_arg(String *not_used MY_ATTRIBUTE((unused)))
   { return &max_arg; }
   String *avg(String *s, ha_rows rows)
   {
@@ -137,8 +137,8 @@ public:
 			    TREE_INFO *info);
   tree_walk_action collect_enum()
   { return (tree_walk_action) collect_string; }
-  String *std(String *s __attribute__((unused)),
-	      ha_rows rows __attribute__((unused)))
+  String *std(String *s MY_ATTRIBUTE((unused)),
+	      ha_rows rows MY_ATTRIBUTE((unused)))
   { return (String*) 0; }
 };
 
--- a/sql/sql_audit.cc
+++ b/sql/sql_audit.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2007, 2015, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2007, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -494,7 +494,7 @@ static void event_class_dispatch(THD *thd, unsigned int event_class,
 
 
 /**  There's at least one active audit plugin tracking the general events */
-bool is_any_audit_plugin_active(THD *thd __attribute__((unused)))
+bool is_any_audit_plugin_active(THD *thd MY_ATTRIBUTE((unused)))
 {
   return (mysql_global_audit_mask[0] & MYSQL_AUDIT_GENERAL_CLASSMASK);
 }
--- a/sql/sql_audit.h
+++ b/sql/sql_audit.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2007, 2015, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2007, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -37,7 +37,7 @@ extern void mysql_audit_acquire_plugins(THD *thd, uint event_class);
 #ifndef EMBEDDED_LIBRARY
 extern void mysql_audit_notify(THD *thd, uint event_class,
                                uint event_subtype, ...);
-bool is_any_audit_plugin_active(THD *thd __attribute__((unused)));
+bool is_any_audit_plugin_active(THD *thd MY_ATTRIBUTE((unused)));
 #else
 #define mysql_audit_notify(...)
 #endif
--- a/sql/sql_base.cc
+++ b/sql/sql_base.cc
@@ -330,7 +330,7 @@ uint get_table_def_key(const TABLE_LIST *table_list, const char **key)
 *****************************************************************************/
 
 extern "C" uchar *table_def_key(const uchar *record, size_t *length,
-                               my_bool not_used __attribute__((unused)))
+                               my_bool not_used MY_ATTRIBUTE((unused)))
 {
   TABLE_SHARE *entry=(TABLE_SHARE*) record;
   *length= entry->table_cache_key.length;
@@ -4865,7 +4865,7 @@ end:
 }
 
 extern "C" uchar *schema_set_get_key(const uchar *record, size_t *length,
-                                     my_bool not_used __attribute__((unused)))
+                                     my_bool not_used MY_ATTRIBUTE((unused)))
 {
   TABLE_LIST *table=(TABLE_LIST*) record;
   *length= table->db_length;
--- a/sql/sql_cache.cc
+++ b/sql/sql_cache.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2013, 2015, Oracle and/or its affiliates. All rights
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights
    reserved.
 
    This program is free software; you can redistribute it and/or modify
@@ -729,7 +729,7 @@ inline Query_cache_block_table * Query_cache_block::table(TABLE_COUNTER_TYPE n)
 extern "C"
 {
 uchar *query_cache_table_get_key(const uchar *record, size_t *length,
-				my_bool not_used __attribute__((unused)))
+				my_bool not_used MY_ATTRIBUTE((unused)))
 {
   Query_cache_block* table_block = (Query_cache_block*) record;
   *length = (table_block->used - table_block->headers_len() -
--- a/sql/sql_class.cc
+++ b/sql/sql_class.cc
@@ -83,7 +83,7 @@ const char * const THD::DEFAULT_WHERE= "field list";
 ****************************************************************************/
 
 extern "C" uchar *get_var_key(user_var_entry *entry, size_t *length,
-                              my_bool not_used __attribute__((unused)))
+                              my_bool not_used MY_ATTRIBUTE((unused)))
 {
   *length= entry->entry_name.length();
   return (uchar*) entry->entry_name.ptr();
@@ -3053,7 +3053,7 @@ err:
 
 
 int
-select_dump::prepare(List<Item> &list __attribute__((unused)),
+select_dump::prepare(List<Item> &list MY_ATTRIBUTE((unused)),
 		     SELECT_LEX_UNIT *u)
 {
   unit= u;
@@ -3465,7 +3465,7 @@ C_MODE_START
 
 static uchar *
 get_statement_id_as_hash_key(const uchar *record, size_t *key_length,
-                             my_bool not_used __attribute__((unused)))
+                             my_bool not_used MY_ATTRIBUTE((unused)))
 {
   const Statement *statement= (const Statement *) record; 
   *key_length= sizeof(statement->id);
@@ -3478,7 +3478,7 @@ static void delete_statement_as_hash_key(void *key)
 }
 
 static uchar *get_stmt_name_hash_key(Statement *entry, size_t *length,
-                                    my_bool not_used __attribute__((unused)))
+                                    my_bool not_used MY_ATTRIBUTE((unused)))
 {
   *length= entry->name.length;
   return (uchar*) entry->name.str;
@@ -4779,7 +4779,7 @@ extern "C" uchar *xid_get_hash_key(const uchar *, size_t *, my_bool);
 extern "C" void xid_free_hash(void *);
 
 uchar *xid_get_hash_key(const uchar *ptr, size_t *length,
-                                  my_bool not_used __attribute__((unused)))
+                                  my_bool not_used MY_ATTRIBUTE((unused)))
 {
   *length=((XID_STATE*)ptr)->xid.key_length();
   return ((XID_STATE*)ptr)->xid.key();
--- a/sql/sql_connect.cc
+++ b/sql/sql_connect.cc
@@ -1,5 +1,5 @@
 /*
-   Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2007, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -337,7 +337,7 @@ void release_user_connection(THD *thd)
 */
 
 extern "C" uchar *get_key_conn(user_conn *buff, size_t *length,
-            my_bool not_used __attribute__((unused)))
+            my_bool not_used MY_ATTRIBUTE((unused)))
 {
   *length= buff->len;
   return (uchar*) buff->user;
--- a/sql/sql_cursor.cc
+++ b/sql/sql_cursor.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2005, 2015, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2005, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -47,7 +47,7 @@ public:
 
   int send_result_set_metadata(THD *thd, List<Item> &send_result_set_metadata);
   virtual bool is_open() const { return table != 0; }
-  virtual int open(JOIN *join __attribute__((unused)));
+  virtual int open(JOIN *join MY_ATTRIBUTE((unused)));
   virtual void fetch(ulong num_rows);
   virtual void close();
   virtual ~Materialized_cursor();
@@ -277,7 +277,7 @@ end:
 }
 
 
-int Materialized_cursor::open(JOIN *join __attribute__((unused)))
+int Materialized_cursor::open(JOIN *join MY_ATTRIBUTE((unused)))
 {
   THD *thd= fake_unit.thd;
   int rc;
--- a/sql/sql_db.cc
+++ b/sql/sql_db.cc
@@ -1,5 +1,5 @@
 /*
-   Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -86,7 +86,7 @@ extern "C" uchar* dboptions_get_key(my_dbopt_t *opt, size_t *length,
                                     my_bool not_used);
 
 uchar* dboptions_get_key(my_dbopt_t *opt, size_t *length,
-                         my_bool not_used __attribute__((unused)))
+                         my_bool not_used MY_ATTRIBUTE((unused)))
 {
   *length= opt->name_length;
   return (uchar*) opt->name;
--- a/sql/sql_executor.cc
+++ b/sql/sql_executor.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -484,7 +484,7 @@ init_tmptable_sum_functions(Item_sum **func_ptr)
 
 static void
 update_tmptable_sum_func(Item_sum **func_ptr,
-			 TABLE *tmp_table __attribute__((unused)))
+			 TABLE *tmp_table MY_ATTRIBUTE((unused)))
 {
   Item_sum *func;
   while ((func= *(func_ptr++)))
@@ -2256,7 +2256,7 @@ join_read_last_key(JOIN_TAB *tab)
 
 	/* ARGSUSED */
 static int
-join_no_more_records(READ_RECORD *info __attribute__((unused)))
+join_no_more_records(READ_RECORD *info MY_ATTRIBUTE((unused)))
 {
   return -1;
 }
@@ -2858,7 +2858,7 @@ end_send(JOIN *join, JOIN_TAB *join_tab, bool end_of_records)
 
 	/* ARGSUSED */
 enum_nested_loop_state
-end_send_group(JOIN *join, JOIN_TAB *join_tab __attribute__((unused)),
+end_send_group(JOIN *join, JOIN_TAB *join_tab MY_ATTRIBUTE((unused)),
 	       bool end_of_records)
 {
   int idx= -1;
@@ -3856,7 +3856,7 @@ setup_copy_fields(THD *thd, TMP_TABLE_PARAM *param,
   Item *pos;
   List_iterator_fast<Item> li(all_fields);
   Copy_field *copy= NULL;
-  Copy_field *copy_start __attribute__((unused));
+  Copy_field *copy_start MY_ATTRIBUTE((unused));
   res_selected_fields.empty();
   res_all_fields.empty();
   List_iterator_fast<Item> itr(res_all_fields);
--- a/sql/sql_executor.h
+++ b/sql/sql_executor.h
@@ -1,7 +1,7 @@
 #ifndef SQL_EXECUTOR_INCLUDED
 #define SQL_EXECUTOR_INCLUDED
 
-/* Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights
    reserved.
 
    This program is free software; you can redistribute it and/or modify
@@ -258,7 +258,7 @@ private:
   /** Write function that would be used for saving records in tmp table. */
   Next_select_func write_func;
   enum_nested_loop_state put_record(bool end_of_records);
-  __attribute__((warn_unused_result))
+  MY_ATTRIBUTE((warn_unused_result))
   bool prepare_tmp_table();
 };
 
--- a/sql/sql_handler.cc
+++ b/sql/sql_handler.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2001, 2013, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2001, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -89,7 +89,7 @@ static bool mysql_ha_open_table(THD *thd, TABLE_LIST *table);
 */
 
 static char *mysql_ha_hash_get_key(TABLE_LIST *tables, size_t *key_len_p,
-                                   my_bool first __attribute__((unused)))
+                                   my_bool first MY_ATTRIBUTE((unused)))
 {
   *key_len_p= strlen(tables->alias) + 1 ; /* include '\0' in comparisons */
   return tables->alias;
--- a/sql/sql_load.cc
+++ b/sql/sql_load.cc
@@ -209,7 +209,7 @@ int mysql_load(THD *thd,sql_exchange *ex,TABLE_LIST *table_list,
   */
   char *tdb= thd->db ? thd->db : db;		// Result is never null
   ulong skip_lines= ex->skip_lines;
-  bool transactional_table __attribute__((unused));
+  bool transactional_table MY_ATTRIBUTE((unused));
   DBUG_ENTER("mysql_load");
 
   /*
--- a/sql/sql_manager.cc
+++ b/sql/sql_manager.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -63,7 +63,7 @@ bool mysql_manager_submit(void (*action)())
   return result;
 }
 
-pthread_handler_t handle_manager(void *arg __attribute__((unused)))
+pthread_handler_t handle_manager(void *arg MY_ATTRIBUTE((unused)))
 {
   int error = 0;
   struct timespec abstime;
--- a/sql/sql_optimizer.cc
+++ b/sql/sql_optimizer.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -1121,8 +1121,8 @@ public:
   {
     return (void*) sql_alloc((uint) size);
   }
-  static void operator delete(void *ptr __attribute__((unused)),
-                              size_t size __attribute__((unused)))
+  static void operator delete(void *ptr MY_ATTRIBUTE((unused)),
+                              size_t size MY_ATTRIBUTE((unused)))
   { TRASH(ptr, size); }
 
   Item *and_level;
--- a/sql/sql_parse.cc
+++ b/sql/sql_parse.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -1645,7 +1645,7 @@ bool dispatch_command(enum enum_server_command command, THD *thd,
   {
     STATUS_VAR current_global_status_var;
     ulong uptime;
-    uint length __attribute__((unused));
+    uint length MY_ATTRIBUTE((unused));
     ulonglong queries_per_second1000;
     char buff[250];
     uint buff_len= sizeof(buff);
@@ -1791,7 +1791,7 @@ done:
   /* DTRACE instrumentation, end */
   if (MYSQL_QUERY_DONE_ENABLED() || MYSQL_COMMAND_DONE_ENABLED())
   {
-    int res __attribute__((unused));
+    int res MY_ATTRIBUTE((unused));
     res= (int) thd->is_error();
     if (command == COM_QUERY)
     {
@@ -5919,7 +5919,7 @@ long max_stack_used;
   - Passing to check_stack_overrun() prevents the compiler from removing it.
 */
 bool check_stack_overrun(THD *thd, long margin,
-			 uchar *buf __attribute__((unused)))
+			 uchar *buf MY_ATTRIBUTE((unused)))
 {
   long stack_used;
   DBUG_ASSERT(thd == current_thd);
@@ -6260,7 +6260,7 @@ void mysql_init_multi_delete(LEX *lex)
 void mysql_parse(THD *thd, char *rawbuf, uint length,
                  Parser_state *parser_state)
 {
-  int error __attribute__((unused));
+  int error MY_ATTRIBUTE((unused));
   DBUG_ENTER("mysql_parse");
 
   DBUG_EXECUTE_IF("parser_debug", turn_parser_debug_on(););
--- a/sql/sql_planner.cc
+++ b/sql/sql_planner.cc
@@ -1516,7 +1516,7 @@ bool Optimize_table_order::greedy_search(table_map remaining_tables)
       join state will not be reverted back to its initial state because we
       don't "pop" tables already present in the partial plan.
     */
-    bool is_interleave_error __attribute__((unused))= 
+    bool is_interleave_error MY_ATTRIBUTE((unused))= 
       check_interleaving_with_nj (best_table);
     /* This has been already checked by best_extension_by_limited_search */
     DBUG_ASSERT(!is_interleave_error);
--- a/sql/sql_plugin.cc
+++ b/sql/sql_plugin.cc
@@ -1216,7 +1216,7 @@ extern "C" uchar *get_bookmark_hash_key(const uchar *, size_t *, my_bool);
 
 
 uchar *get_plugin_hash_key(const uchar *buff, size_t *length,
-                           my_bool not_used __attribute__((unused)))
+                           my_bool not_used MY_ATTRIBUTE((unused)))
 {
   struct st_plugin_int *plugin= (st_plugin_int *)buff;
   *length= (uint)plugin->name.length;
@@ -1225,7 +1225,7 @@ uchar *get_plugin_hash_key(const uchar *buff, size_t *length,
 
 
 uchar *get_bookmark_hash_key(const uchar *buff, size_t *length,
-                             my_bool not_used __attribute__((unused)))
+                             my_bool not_used MY_ATTRIBUTE((unused)))
 {
   struct st_bookmark *var= (st_bookmark *)buff;
   *length= var->name_len + 1;
@@ -3396,7 +3396,7 @@ static void plugin_opt_set_limits(struct my_option *options,
 extern "C" my_bool get_one_plugin_option(int optid, const struct my_option *,
                                          char *);
 
-my_bool get_one_plugin_option(int optid __attribute__((unused)),
+my_bool get_one_plugin_option(int optid MY_ATTRIBUTE((unused)),
                               const struct my_option *opt,
                               char *argument)
 {
@@ -3717,7 +3717,7 @@ static my_option *construct_help_options(MEM_ROOT *mem_root,
 
 static my_bool check_if_option_is_deprecated(int optid,
                                              const struct my_option *opt,
-                                             char *argument __attribute__((unused)))
+                                             char *argument MY_ATTRIBUTE((unused)))
 {
   if (optid == -1)
   {
@@ -3767,7 +3767,7 @@ static int test_plugin_options(MEM_ROOT *tmp_root, struct st_plugin_int *tmp,
   LEX_STRING plugin_name;
   char *varname;
   int error;
-  sys_var *v __attribute__((unused));
+  sys_var *v MY_ATTRIBUTE((unused));
   struct st_bookmark *var;
   uint len, count= EXTRA_OPTIONS;
   DBUG_ENTER("test_plugin_options");
--- a/sql/sql_prepare.cc
+++ b/sql/sql_prepare.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2002, 2015, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2002, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -399,7 +399,7 @@ static bool send_prep_stmt(Prepared_statement *stmt, uint columns)
 }
 #else
 static bool send_prep_stmt(Prepared_statement *stmt,
-                           uint columns __attribute__((unused)))
+                           uint columns MY_ATTRIBUTE((unused)))
 {
   THD *thd= stmt->thd;
 
@@ -1183,7 +1183,7 @@ swap_parameter_array(Item_param **param_array_dst,
 
 static bool insert_params_from_vars(Prepared_statement *stmt,
                                     List<LEX_STRING>& varnames,
-                                    String *query __attribute__((unused)))
+                                    String *query MY_ATTRIBUTE((unused)))
 {
   Item_param **begin= stmt->param_array;
   Item_param **end= begin + stmt->param_count;
@@ -4529,7 +4529,7 @@ bool Protocol_local::store(const char *str, size_t length,
 /* Store MYSQL_TIME (in binary format) */
 
 bool Protocol_local::store(MYSQL_TIME *time,
-                           uint precision __attribute__((unused)))
+                           uint precision MY_ATTRIBUTE((unused)))
 {
   return store_column(time, sizeof(MYSQL_TIME));
 }
@@ -4546,7 +4546,7 @@ bool Protocol_local::store_date(MYSQL_TIME *time)
 /** Store MYSQL_TIME (in binary format) */
 
 bool Protocol_local::store_time(MYSQL_TIME *time,
-                                uint precision __attribute__((unused)))
+                                uint precision MY_ATTRIBUTE((unused)))
 {
   return store_column(time, sizeof(MYSQL_TIME));
 }
--- a/sql/sql_select.cc
+++ b/sql/sql_select.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -3075,7 +3075,7 @@ bool JOIN_TAB::and_with_jt_and_sel_condition(Item *add_cond, uint line)
 */
 bool JOIN_TAB::and_with_condition(Item *add_cond, uint line)
 {
-  Item *old_cond __attribute__((unused))= m_condition;
+  Item *old_cond MY_ATTRIBUTE((unused))= m_condition;
   if (and_conditions(&m_condition, add_cond))
     return true;
   DBUG_PRINT("info", ("JOIN_TAB::m_condition extended. Change %p -> %p "
--- a/sql/sql_servers.cc
+++ b/sql/sql_servers.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -86,7 +86,7 @@ static void merge_server_struct(FOREIGN_SERVER *from, FOREIGN_SERVER *to);
 
 
 static uchar *servers_cache_get_key(FOREIGN_SERVER *server, size_t *length,
-			       my_bool not_used __attribute__((unused)))
+			       my_bool not_used MY_ATTRIBUTE((unused)))
 {
   DBUG_ENTER("servers_cache_get_key");
   DBUG_PRINT("info", ("server_name_length %d server_name %s",
--- a/sql/sql_show.cc
+++ b/sql/sql_show.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -369,7 +369,7 @@ ignore_db_dirs_init()
 
 static uchar *
 db_dirs_hash_get_key(const uchar *data, size_t *len_ret,
-                     my_bool __attribute__((unused)))
+                     my_bool MY_ATTRIBUTE((unused)))
 {
   LEX_STRING *e= (LEX_STRING *) data;
 
@@ -2032,8 +2032,8 @@ public:
   {
     return (void*) sql_alloc((uint) size);
   }
-  static void operator delete(void *ptr __attribute__((unused)),
-                              size_t size __attribute__((unused)))
+  static void operator delete(void *ptr MY_ATTRIBUTE((unused)),
+                              size_t size MY_ATTRIBUTE((unused)))
   { TRASH(ptr, size); }
 
   ulong thread_id;
--- a/sql/sql_table.cc
+++ b/sql/sql_table.cc
@@ -5513,7 +5513,7 @@ bool mysql_create_like_table(THD* thd, TABLE_LIST* table, TABLE_LIST* src_table,
           */
           create_info->used_fields|= HA_CREATE_USED_ENGINE;
 
-          int result __attribute__((unused))=
+          int result MY_ATTRIBUTE((unused))=
             store_create_info(thd, table, &query,
                               create_info, TRUE /* show_database */);
 
--- a/sql/sql_time.cc
+++ b/sql/sql_time.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -1187,7 +1187,7 @@ const char *get_date_time_format_str(KNOWN_DATE_TIME_FORMAT *format,
   @param OUT str  String to conver to
   @param dec      Number of fractional digits.
 */
-void make_time(const DATE_TIME_FORMAT *format __attribute__((unused)),
+void make_time(const DATE_TIME_FORMAT *format MY_ATTRIBUTE((unused)),
                const MYSQL_TIME *l_time, String *str, uint dec)
 {
   uint length= (uint) my_time_to_str(l_time, (char*) str->ptr(), dec);
@@ -1202,7 +1202,7 @@ void make_time(const DATE_TIME_FORMAT *format __attribute__((unused)),
   @param l_time   DATE value
   @param OUT str  String to conver to
 */
-void make_date(const DATE_TIME_FORMAT *format __attribute__((unused)),
+void make_date(const DATE_TIME_FORMAT *format MY_ATTRIBUTE((unused)),
                const MYSQL_TIME *l_time, String *str)
 {
   uint length= (uint) my_date_to_str(l_time, (char*) str->ptr());
@@ -1218,7 +1218,7 @@ void make_date(const DATE_TIME_FORMAT *format __attribute__((unused)),
   @param OUT str  String to conver to
   @param dec      Number of fractional digits.
 */
-void make_datetime(const DATE_TIME_FORMAT *format __attribute__((unused)),
+void make_datetime(const DATE_TIME_FORMAT *format MY_ATTRIBUTE((unused)),
                    const MYSQL_TIME *l_time, String *str, uint dec)
 {
   uint length= (uint) my_datetime_to_str(l_time, (char*) str->ptr(), dec);
--- a/sql/sql_udf.cc
+++ b/sql/sql_udf.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -94,7 +94,7 @@ static char *init_syms(udf_func *tmp, char *nm)
 
 
 extern "C" uchar* get_hash_key(const uchar *buff, size_t *length,
-			      my_bool not_used __attribute__((unused)))
+			      my_bool not_used MY_ATTRIBUTE((unused)))
 {
   udf_func *udf=(udf_func*) buff;
   *length=(uint) udf->name.length;
--- a/sql/sql_yacc.yy
+++ b/sql/sql_yacc.yy
@@ -113,18 +113,18 @@ int yylex(void *yylval, void *yythd);
 <pre>
   yyerrlab1:
   #if defined (__GNUC_MINOR__) && 2093 <= (__GNUC__ * 1000 + __GNUC_MINOR__)
-    __attribute__ ((__unused__))
+    MY_ATTRIBUTE ((__unused__))
   #endif
 </pre>
-  This usage of __attribute__ is illegal, so we remove it.
+  This usage of MY_ATTRIBUTE is illegal, so we remove it.
   See the following references for details:
   http://lists.gnu.org/archive/html/bug-bison/2004-02/msg00014.html
   http://gcc.gnu.org/bugzilla/show_bug.cgi?id=14273
 */
 
 #if defined (__GNUC_MINOR__) && 2093 <= (__GNUC__ * 1000 + __GNUC_MINOR__)
-#undef __attribute__
-#define __attribute__(X)
+#undef MY_ATTRIBUTE
+#define MY_ATTRIBUTE(X)
 #endif
 
 
--- a/sql/table.cc
+++ b/sql/table.cc
@@ -1,5 +1,5 @@
 /*
-   Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -210,7 +210,7 @@ View_creation_ctx * View_creation_ctx::create(THD *thd,
 /* Get column name from column hash */
 
 static uchar *get_field_name(Field **buff, size_t *length,
-                             my_bool not_used __attribute__((unused)))
+                             my_bool not_used MY_ATTRIBUTE((unused)))
 {
   *length= (uint) strlen((*buff)->field_name);
   return (uchar*) (*buff)->field_name;
--- a/sql/table_cache.cc
+++ b/sql/table_cache.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -33,7 +33,7 @@ PSI_mutex_info Table_cache::m_mutex_keys[]= {
 
 extern "C" uchar *table_cache_key(const uchar *record,
                                   size_t *length,
-                                  my_bool not_used __attribute__((unused)))
+                                  my_bool not_used MY_ATTRIBUTE((unused)))
 {
   TABLE_SHARE *share= ((Table_cache_element*)record)->get_share();
   *length= share->table_cache_key.length;
--- a/sql/tztime.cc
+++ b/sql/tztime.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2004, 2013, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2004, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -1490,7 +1490,7 @@ public:
 
 extern "C" uchar *
 my_tz_names_get_key(Tz_names_entry *entry, size_t *length,
-                    my_bool not_used __attribute__((unused)))
+                    my_bool not_used MY_ATTRIBUTE((unused)))
 {
   *length= entry->name.length();
   return (uchar*) entry->name.ptr();
@@ -1499,7 +1499,7 @@ my_tz_names_get_key(Tz_names_entry *entry, size_t *length,
 extern "C" uchar *
 my_offset_tzs_get_key(Time_zone_offset *entry,
                       size_t *length,
-                      my_bool not_used __attribute__((unused)))
+                      my_bool not_used MY_ATTRIBUTE((unused)))
 {
   *length= sizeof(long);
   return (uchar*) &entry->offset;
--- a/sql/udf_example.cc
+++ b/sql/udf_example.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -227,7 +227,7 @@ my_bool metaphon_init(UDF_INIT *initid, UDF_ARGS *args, char *message)
 ****************************************************************************/
 
 
-void metaphon_deinit(UDF_INIT *initid __attribute__((unused)))
+void metaphon_deinit(UDF_INIT *initid MY_ATTRIBUTE((unused)))
 {
 }
 
@@ -273,9 +273,9 @@ static char codes[26] =  {
 #define NOGHTOF(x)  (codes[(x) - 'A'] & 16)	/* BDH */
 
 
-char *metaphon(UDF_INIT *initid __attribute__((unused)),
+char *metaphon(UDF_INIT *initid MY_ATTRIBUTE((unused)),
                UDF_ARGS *args, char *result, unsigned long *length,
-               char *is_null, char *error __attribute__((unused)))
+               char *is_null, char *error MY_ATTRIBUTE((unused)))
 {
   const char *word=args->args[0];
   const char *w_end;
@@ -550,8 +550,8 @@ my_bool myfunc_double_init(UDF_INIT *initid, UDF_ARGS *args, char *message)
 }
 
 
-double myfunc_double(UDF_INIT *initid __attribute__((unused)), UDF_ARGS *args,
-                     char *is_null, char *error __attribute__((unused)))
+double myfunc_double(UDF_INIT *initid MY_ATTRIBUTE((unused)), UDF_ARGS *args,
+                     char *is_null, char *error MY_ATTRIBUTE((unused)))
 {
   unsigned long val = 0;
   unsigned long v = 0;
@@ -589,9 +589,9 @@ double myfunc_double(UDF_INIT *initid __attribute__((unused)), UDF_ARGS *args,
 
 /* This function returns the sum of all arguments */
 
-longlong myfunc_int(UDF_INIT *initid __attribute__((unused)), UDF_ARGS *args,
-                    char *is_null __attribute__((unused)),
-                    char *error __attribute__((unused)))
+longlong myfunc_int(UDF_INIT *initid MY_ATTRIBUTE((unused)), UDF_ARGS *args,
+                    char *is_null MY_ATTRIBUTE((unused)),
+                    char *error MY_ATTRIBUTE((unused)))
 {
   longlong val = 0;
   uint i;
@@ -621,9 +621,9 @@ longlong myfunc_int(UDF_INIT *initid __attribute__((unused)), UDF_ARGS *args,
   At least one of _init/_deinit is needed unless the server is started
   with --allow_suspicious_udfs.
 */
-my_bool myfunc_int_init(UDF_INIT *initid __attribute__((unused)),
-                        UDF_ARGS *args __attribute__((unused)),
-                        char *message __attribute__((unused)))
+my_bool myfunc_int_init(UDF_INIT *initid MY_ATTRIBUTE((unused)),
+                        UDF_ARGS *args MY_ATTRIBUTE((unused)),
+                        char *message MY_ATTRIBUTE((unused)))
 {
   return 0;
 }
@@ -663,9 +663,9 @@ void sequence_deinit(UDF_INIT *initid)
     free(initid->ptr);
 }
 
-longlong sequence(UDF_INIT *initid __attribute__((unused)), UDF_ARGS *args,
-                  char *is_null __attribute__((unused)),
-                  char *error __attribute__((unused)))
+longlong sequence(UDF_INIT *initid MY_ATTRIBUTE((unused)), UDF_ARGS *args,
+                  char *is_null MY_ATTRIBUTE((unused)),
+                  char *error MY_ATTRIBUTE((unused)))
 {
   ulonglong val=0;
   if (args->arg_count)
@@ -727,16 +727,16 @@ my_bool lookup_init(UDF_INIT *initid, UDF_ARGS *args, char *message)
   return 0;
 }
 
-void lookup_deinit(UDF_INIT *initid __attribute__((unused)))
+void lookup_deinit(UDF_INIT *initid MY_ATTRIBUTE((unused)))
 {
 #if !defined(HAVE_GETHOSTBYADDR_R) || !defined(HAVE_SOLARIS_STYLE_GETHOST)
   (void) pthread_mutex_destroy(&LOCK_hostname);
 #endif
 }
 
-char *lookup(UDF_INIT *initid __attribute__((unused)), UDF_ARGS *args,
+char *lookup(UDF_INIT *initid MY_ATTRIBUTE((unused)), UDF_ARGS *args,
              char *result, unsigned long *res_length, char *null_value,
-             char *error __attribute__((unused)))
+             char *error MY_ATTRIBUTE((unused)))
 {
   uint length;
   char name_buff[256];
@@ -807,16 +807,16 @@ my_bool reverse_lookup_init(UDF_INIT *initid, UDF_ARGS *args, char *message)
   return 0;
 }
 
-void reverse_lookup_deinit(UDF_INIT *initid __attribute__((unused)))
+void reverse_lookup_deinit(UDF_INIT *initid MY_ATTRIBUTE((unused)))
 {
 #if !defined(HAVE_GETHOSTBYADDR_R) || !defined(HAVE_SOLARIS_STYLE_GETHOST)
   (void) pthread_mutex_destroy(&LOCK_hostname);
 #endif
 }
 
-char *reverse_lookup(UDF_INIT *initid __attribute__((unused)), UDF_ARGS *args,
+char *reverse_lookup(UDF_INIT *initid MY_ATTRIBUTE((unused)), UDF_ARGS *args,
                      char *result, unsigned long *res_length,
-                     char *null_value, char *error __attribute__((unused)))
+                     char *null_value, char *error MY_ATTRIBUTE((unused)))
 {
 #if defined(HAVE_GETHOSTBYADDR_R) && defined(HAVE_SOLARIS_STYLE_GETHOST)
   char name_buff[256];
@@ -970,8 +970,8 @@ avgcost_reset(UDF_INIT* initid, UDF_ARGS* args, char* is_null, char* message)
 /* This is needed to get things to work in MySQL 4.1.1 and above */
 
 void
-avgcost_clear(UDF_INIT* initid, char* is_null __attribute__((unused)),
-              char* message __attribute__((unused)))
+avgcost_clear(UDF_INIT* initid, char* is_null MY_ATTRIBUTE((unused)),
+              char* message MY_ATTRIBUTE((unused)))
 {
   struct avgcost_data* data = (struct avgcost_data*)initid->ptr;
   data->totalprice=	0.0;
@@ -982,8 +982,8 @@ avgcost_clear(UDF_INIT* initid, char* is_null __attribute__((unused)),
 
 void
 avgcost_add(UDF_INIT* initid, UDF_ARGS* args,
-            char* is_null __attribute__((unused)),
-            char* message __attribute__((unused)))
+            char* is_null MY_ATTRIBUTE((unused)),
+            char* message MY_ATTRIBUTE((unused)))
 {
   if (args->args[0] && args->args[1])
   {
@@ -1029,8 +1029,8 @@ avgcost_add(UDF_INIT* initid, UDF_ARGS* args,
 
 
 double
-avgcost( UDF_INIT* initid, UDF_ARGS* args __attribute__((unused)),
-         char* is_null, char* error __attribute__((unused)))
+avgcost( UDF_INIT* initid, UDF_ARGS* args MY_ATTRIBUTE((unused)),
+         char* is_null, char* error MY_ATTRIBUTE((unused)))
 {
   struct avgcost_data* data = (struct avgcost_data*)initid->ptr;
   if (!data->count || !data->totalquantity)
@@ -1063,10 +1063,10 @@ my_bool myfunc_argument_name_init(UDF_INIT *initid, UDF_ARGS *args,
   return 0;
 }
 
-char *myfunc_argument_name(UDF_INIT *initid __attribute__((unused)),
+char *myfunc_argument_name(UDF_INIT *initid MY_ATTRIBUTE((unused)),
                            UDF_ARGS *args, char *result,
                            unsigned long *length, char *null_value,
-                           char *error __attribute__((unused)))
+                           char *error MY_ATTRIBUTE((unused)))
 {
   if (!args->attributes[0])
   {
@@ -1094,9 +1094,9 @@ my_bool is_const_init(UDF_INIT *initid, UDF_ARGS *args, char *message)
   return 0;
 }
 
-char * is_const(UDF_INIT *initid, UDF_ARGS *args __attribute__((unused)),
+char * is_const(UDF_INIT *initid, UDF_ARGS *args MY_ATTRIBUTE((unused)),
                 char *result, unsigned long *length,
-                char *is_null, char *error __attribute__((unused)))
+                char *is_null, char *error MY_ATTRIBUTE((unused)))
 {
   if (initid->ptr != 0) {
     sprintf(result, "const");
@@ -1135,9 +1135,9 @@ my_bool check_const_len_init(UDF_INIT *initid, UDF_ARGS *args, char *message)
 }
 
 extern "C"
-char * check_const_len(UDF_INIT *initid, UDF_ARGS *args __attribute__((unused)),
+char * check_const_len(UDF_INIT *initid, UDF_ARGS *args MY_ATTRIBUTE((unused)),
                 char *result, unsigned long *length,
-                char *is_null, char *error __attribute__((unused)))
+                char *is_null, char *error MY_ATTRIBUTE((unused)))
 {
   strmov(result, initid->ptr);
   *length= (uint) strlen(result);
@@ -1183,8 +1183,8 @@ void my_median_deinit(UDF_INIT* initid)
 }
 
 void my_median_add(UDF_INIT* initid, UDF_ARGS* args,
-                   char* is_null __attribute__((unused)),
-                   char* message __attribute__((unused)))
+                   char* is_null MY_ATTRIBUTE((unused)),
+                   char* message MY_ATTRIBUTE((unused)))
 {
   My_median_data *data=
     static_cast<My_median_data*>(static_cast<void*>(initid->ptr));
@@ -1197,8 +1197,8 @@ void my_median_add(UDF_INIT* initid, UDF_ARGS* args,
 }
 
 void my_median_clear(UDF_INIT* initid, UDF_ARGS* args,
-                     char* is_null __attribute__((unused)),
-                     char* message __attribute__((unused)))
+                     char* is_null MY_ATTRIBUTE((unused)),
+                     char* message MY_ATTRIBUTE((unused)))
 {
   My_median_data *data=
     static_cast<My_median_data*>(static_cast<void*>(initid->ptr));
@@ -1207,7 +1207,7 @@ void my_median_clear(UDF_INIT* initid, UDF_ARGS* args,
 
 longlong my_median(UDF_INIT* initid, UDF_ARGS* args,
                    char* is_null,
-                   char* message __attribute__((unused)))
+                   char* message MY_ATTRIBUTE((unused)))
 {
   My_median_data *data=
     static_cast<My_median_data*>(static_cast<void*>(initid->ptr));
--- a/storage/archive/archive_reader.c
+++ b/storage/archive/archive_reader.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2007, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -22,6 +22,7 @@
 #include <m_string.h>
 #include <my_getopt.h>
 #include <mysql_version.h>
+#include <welcome_copyright_notice.h> // ORACLE_WELCOME_COPYRIGHT_NOTICE
 
 #define BUFFER_LEN 1024
 #define ARCHIVE_ROW_HEADER_SIZE 4
@@ -292,7 +293,7 @@ end:
 
 static my_bool
 get_one_option(int optid,
-	       const struct my_option *opt __attribute__((unused)),
+	       const struct my_option *opt MY_ATTRIBUTE((unused)),
 	       char *argument)
 {
   switch (optid) {
@@ -388,8 +389,8 @@ static struct my_option my_long_options[] =
 static void usage(void)
 {
   print_version();
-  puts("Copyright 2007-2008 MySQL AB, 2008 Sun Microsystems, Inc.");
-  puts("This software comes with ABSOLUTELY NO WARRANTY. This is free software,\nand you are welcome to modify and redistribute it under the GPL license\n");
+  puts(ORACLE_WELCOME_COPYRIGHT_NOTICE("2007"));
+
   puts("Read and modify Archive files directly\n");
   printf("Usage: %s [OPTIONS] file_to_be_looked_at [file_for_backup]\n", my_progname);
   print_defaults("my", load_default_groups);
--- a/storage/blackhole/ha_blackhole.cc
+++ b/storage/blackhole/ha_blackhole.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2005, 2012, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2005, 2016, Oracle and/or its affiliates. All rights reserved.
 
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
@@ -383,7 +383,7 @@ static void blackhole_free_key(st_blackhole_share *share)
 }
 
 static uchar* blackhole_get_key(st_blackhole_share *share, size_t *length,
-                                my_bool not_used __attribute__((unused)))
+                                my_bool not_used MY_ATTRIBUTE((unused)))
 {
   *length= share->table_name_length;
   return (uchar*) share->table_name;
--- a/storage/csv/ha_tina.cc
+++ b/storage/csv/ha_tina.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2004, 2016, Oracle and/or its affiliates. All rights reserved.
 
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
@@ -102,7 +102,7 @@ int sort_set (tina_set *a, tina_set *b)
 }
 
 static uchar* tina_get_key(TINA_SHARE *share, size_t *length,
-                          my_bool not_used __attribute__((unused)))
+                          my_bool not_used MY_ATTRIBUTE((unused)))
 {
   *length=share->table_name_length;
   return (uchar*) share->table_name;
--- a/storage/example/ha_example.cc
+++ b/storage/example/ha_example.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2004, 2013, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2004, 2016, Oracle and/or its affiliates. All rights reserved.
 
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
@@ -436,9 +436,9 @@ int ha_example::delete_row(const uchar *buf)
 */
 
 int ha_example::index_read_map(uchar *buf, const uchar *key,
-                               key_part_map keypart_map __attribute__((unused)),
+                               key_part_map keypart_map MY_ATTRIBUTE((unused)),
                                enum ha_rkey_function find_flag
-                               __attribute__((unused)))
+                               MY_ATTRIBUTE((unused)))
 {
   int rc;
   DBUG_ENTER("ha_example::index_read");
--- a/storage/federated/ha_federated.cc
+++ b/storage/federated/ha_federated.cc
@@ -425,7 +425,7 @@ static handler *federated_create_handler(handlerton *hton,
 /* Function we use in the creation of our hash to get key */
 
 static uchar *federated_get_key(FEDERATED_SHARE *share, size_t *length,
-                                my_bool not_used __attribute__ ((unused)))
+                                my_bool not_used MY_ATTRIBUTE ((unused)))
 {
   *length= share->share_key_length;
   return (uchar*) share->share_key;
@@ -2743,7 +2743,7 @@ int ha_federated::read_next(uchar *buf, MYSQL_RES *result)
   @param[in]  record  record data (unused)
 */
 
-void ha_federated::position(const uchar *record __attribute__ ((unused)))
+void ha_federated::position(const uchar *record MY_ATTRIBUTE ((unused)))
 {
   DBUG_ENTER("ha_federated::position");
   
--- a/storage/heap/hp_hash.c
+++ b/storage/heap/hp_hash.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -867,7 +867,7 @@ uint hp_rb_pack_key(HP_KEYDEF *keydef, uchar *key, const uchar *old,
 
 
 uint hp_rb_key_length(HP_KEYDEF *keydef, 
-		      const uchar *key __attribute__((unused)))
+		      const uchar *key MY_ATTRIBUTE((unused)))
 {
   return keydef->length;
 }
--- a/storage/heap/hp_test2.c
+++ b/storage/heap/hp_test2.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
    reserved
 
    This program is free software; you can redistribute it and/or modify
@@ -660,7 +660,7 @@ static int rnd(int max_value)
 } /* rnd */
 
 
-static sig_handler endprog(int sig_number __attribute__((unused)))
+static sig_handler endprog(int sig_number MY_ATTRIBUTE((unused)))
 {
   {
     hp_panic(HA_PANIC_CLOSE);
--- a/storage/innobase/btr/btr0btr.cc
+++ b/storage/innobase/btr/btr0btr.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1994, 2015, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1994, 2016, Oracle and/or its affiliates. All Rights Reserved.
 Copyright (c) 2012, Facebook Inc.
 
 This program is free software; you can redistribute it and/or modify it under
@@ -1102,7 +1102,7 @@ that the caller has made the reservation for free extents!
 @retval block, rw_lock_x_lock_count(&block->lock) == 1 if allocation succeeded
 (init_mtr == mtr, or the page was not previously freed in mtr)
 @retval block (not allocated or initialized) otherwise */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 buf_block_t*
 btr_page_alloc_low(
 /*===============*/
@@ -1971,7 +1971,7 @@ IBUF_BITMAP_FREE is unaffected by reorganization.
 
 @retval true if the operation was successful
 @retval false if it is a compressed page, and recompression failed */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 bool
 btr_page_reorganize_block(
 /*======================*/
@@ -2500,7 +2500,7 @@ func_exit:
 Returns TRUE if the insert fits on the appropriate half-page with the
 chosen split_rec.
 @return	true if fits */
-static __attribute__((nonnull(1,3,4,6), warn_unused_result))
+static MY_ATTRIBUTE((nonnull(1,3,4,6), warn_unused_result))
 bool
 btr_page_insert_fits(
 /*=================*/
@@ -2643,7 +2643,7 @@ btr_insert_on_non_leaf_level_func(
 /**************************************************************//**
 Attaches the halves of an index page on the appropriate level in an
 index tree. */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 void
 btr_attach_half_pages(
 /*==================*/
@@ -2779,7 +2779,7 @@ btr_attach_half_pages(
 /*************************************************************//**
 Determine if a tuple is smaller than any record on the page.
 @return TRUE if smaller */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 bool
 btr_page_tuple_smaller(
 /*===================*/
@@ -3355,7 +3355,7 @@ Removes a page from the level list of pages.
 
 /*************************************************************//**
 Removes a page from the level list of pages. */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 void
 btr_level_list_remove_func(
 /*=======================*/
--- a/storage/innobase/btr/btr0cur.cc
+++ b/storage/innobase/btr/btr0cur.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1994, 2015, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1994, 2016, Oracle and/or its affiliates. All Rights Reserved.
 Copyright (c) 2008, Google Inc.
 Copyright (c) 2012, Facebook Inc.
 
@@ -1084,7 +1084,7 @@ This has to be done either within the same mini-transaction,
 or by invoking ibuf_reset_free_bits() before mtr_commit().
 
 @return	pointer to inserted record if succeed, else NULL */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 rec_t*
 btr_cur_insert_if_possible(
 /*=======================*/
@@ -1127,7 +1127,7 @@ btr_cur_insert_if_possible(
 /*************************************************************//**
 For an insert, checks the locks and does the undo logging if desired.
 @return	DB_SUCCESS, DB_WAIT_LOCK, DB_FAIL, or error number */
-UNIV_INLINE __attribute__((warn_unused_result, nonnull(2,3,5,6)))
+UNIV_INLINE MY_ATTRIBUTE((warn_unused_result, nonnull(2,3,5,6)))
 dberr_t
 btr_cur_ins_lock_and_undo(
 /*======================*/
@@ -1653,7 +1653,7 @@ btr_cur_pessimistic_insert(
 /*************************************************************//**
 For an update, checks the locks and does the undo logging.
 @return	DB_SUCCESS, DB_WAIT_LOCK, or error number */
-UNIV_INLINE __attribute__((warn_unused_result, nonnull(2,3,6,7)))
+UNIV_INLINE MY_ATTRIBUTE((warn_unused_result, nonnull(2,3,6,7)))
 dberr_t
 btr_cur_upd_lock_and_undo(
 /*======================*/
@@ -4992,7 +4992,7 @@ btr_free_externally_stored_field(
 	ulint		i,		/*!< in: field number of field_ref;
 					ignored if rec == NULL */
 	enum trx_rb_ctx	rb_ctx,		/*!< in: rollback context */
-	mtr_t*		local_mtr __attribute__((unused))) /*!< in: mtr
+	mtr_t*		local_mtr MY_ATTRIBUTE((unused))) /*!< in: mtr
 					containing the latch to data an an
 					X-latch to the index tree */
 {
--- a/storage/innobase/btr/btr0sea.cc
+++ b/storage/innobase/btr/btr0sea.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1996, 2012, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1996, 2016, Oracle and/or its affiliates. All Rights Reserved.
 Copyright (c) 2008, Google Inc.
 
 Portions of this file contain modifications contributed and copyrighted by
@@ -473,7 +473,7 @@ btr_search_update_block_hash_info(
 /*==============================*/
 	btr_search_t*	info,	/*!< in: search info */
 	buf_block_t*	block,	/*!< in: buffer block */
-	btr_cur_t*	cursor __attribute__((unused)))
+	btr_cur_t*	cursor MY_ATTRIBUTE((unused)))
 				/*!< in: cursor */
 {
 #ifdef UNIV_SYNC_DEBUG
--- a/storage/innobase/buf/buf0buddy.cc
+++ b/storage/innobase/buf/buf0buddy.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 2006, 2013, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 2006, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -112,7 +112,7 @@ buf_buddy_mem_invalid(
 /**********************************************************************//**
 Check if a buddy is stamped free.
 @return	whether the buddy is free */
-UNIV_INLINE __attribute__((warn_unused_result))
+UNIV_INLINE MY_ATTRIBUTE((warn_unused_result))
 bool
 buf_buddy_stamp_is_free(
 /*====================*/
@@ -225,7 +225,7 @@ Checks if a buf is free i.e.: in the zip_free[].
 @retval BUF_BUDDY_STATE_FREE if fully free
 @retval BUF_BUDDY_STATE_USED if currently in use
 @retval BUF_BUDDY_STATE_PARTIALLY_USED if partially in use. */
-static  __attribute__((warn_unused_result))
+static  MY_ATTRIBUTE((warn_unused_result))
 buf_buddy_state_t
 buf_buddy_is_free(
 /*==============*/
--- a/storage/innobase/buf/buf0buf.cc
+++ b/storage/innobase/buf/buf0buf.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1995, 2015, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1995, 2016, Oracle and/or its affiliates. All Rights Reserved.
 Copyright (c) 2008, Google Inc.
 
 Portions of this file contain modifications contributed and copyrighted by
@@ -3470,7 +3470,7 @@ buf_page_init_low(
 
 /********************************************************************//**
 Inits a page to the buffer buf_pool. */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 void
 buf_page_init(
 /*==========*/
--- a/storage/innobase/buf/buf0dump.cc
+++ b/storage/innobase/buf/buf0dump.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 2011, 2015, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 2011, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -105,7 +105,7 @@ SELECT variable_value FROM information_schema.global_status WHERE
 variable_name = 'INNODB_BUFFER_POOL_DUMP_STATUS';
 or by:
 SHOW STATUS LIKE 'innodb_buffer_pool_dump_status'; */
-static __attribute__((nonnull, format(printf, 2, 3)))
+static MY_ATTRIBUTE((nonnull, format(printf, 2, 3)))
 void
 buf_dump_status(
 /*============*/
@@ -141,7 +141,7 @@ SELECT variable_value FROM information_schema.global_status WHERE
 variable_name = 'INNODB_BUFFER_POOL_LOAD_STATUS';
 or by:
 SHOW STATUS LIKE 'innodb_buffer_pool_load_status'; */
-static __attribute__((nonnull, format(printf, 2, 3)))
+static MY_ATTRIBUTE((nonnull, format(printf, 2, 3)))
 void
 buf_load_status(
 /*============*/
@@ -594,7 +594,7 @@ extern "C" UNIV_INTERN
 os_thread_ret_t
 DECLARE_THREAD(buf_dump_thread)(
 /*============================*/
-	void*	arg __attribute__((unused)))	/*!< in: a dummy parameter
+	void*	arg MY_ATTRIBUTE((unused)))	/*!< in: a dummy parameter
 						required by os_thread_create */
 {
 	ut_ad(!srv_read_only_mode);
--- a/storage/innobase/buf/buf0flu.cc
+++ b/storage/innobase/buf/buf0flu.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1995, 2015, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1995, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -2384,7 +2384,7 @@ extern "C" UNIV_INTERN
 os_thread_ret_t
 DECLARE_THREAD(buf_flush_page_cleaner_thread)(
 /*==========================================*/
-	void*	arg __attribute__((unused)))
+	void*	arg MY_ATTRIBUTE((unused)))
 			/*!< in: a dummy parameter required by
 			os_thread_create */
 {
--- a/storage/innobase/buf/buf0lru.cc
+++ b/storage/innobase/buf/buf0lru.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1995, 2013, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1995, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -142,7 +142,7 @@ If a compressed page is freed other compressed pages may be relocated.
 caller needs to free the page to the free list
 @retval false if BUF_BLOCK_ZIP_PAGE was removed from page_hash. In
 this case the block is already returned to the buddy allocator. */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 bool
 buf_LRU_block_remove_hashed(
 /*========================*/
@@ -366,7 +366,7 @@ want to hog the CPU and resources. Release the buffer pool and block
 mutex and try to force a context switch. Then reacquire the same mutexes.
 The current page is "fixed" before the release of the mutexes and then
 "unfixed" again once we have reacquired the mutexes. */
-static	__attribute__((nonnull))
+static	MY_ATTRIBUTE((nonnull))
 void
 buf_flush_yield(
 /*============*/
@@ -407,7 +407,7 @@ If we have hogged the resources for too long then release the buffer
 pool and flush list mutex and do a thread yield. Set the current page
 to "sticky" so that it is not relocated during the yield.
 @return true if yielded */
-static	__attribute__((nonnull(1), warn_unused_result))
+static	MY_ATTRIBUTE((nonnull(1), warn_unused_result))
 bool
 buf_flush_try_yield(
 /*================*/
@@ -450,7 +450,7 @@ buf_flush_try_yield(
 Removes a single page from a given tablespace inside a specific
 buffer pool instance.
 @return true if page was removed. */
-static	__attribute__((nonnull, warn_unused_result))
+static	MY_ATTRIBUTE((nonnull, warn_unused_result))
 bool
 buf_flush_or_remove_page(
 /*=====================*/
@@ -531,7 +531,7 @@ the list as they age towards the tail of the LRU.
 @retval DB_SUCCESS if all freed
 @retval DB_FAIL if not all freed
 @retval DB_INTERRUPTED if the transaction was interrupted */
-static	__attribute__((nonnull(1), warn_unused_result))
+static	MY_ATTRIBUTE((nonnull(1), warn_unused_result))
 dberr_t
 buf_flush_or_remove_pages(
 /*======================*/
@@ -637,7 +637,7 @@ Remove or flush all the dirty pages that belong to a given tablespace
 inside a specific buffer pool instance. The pages will remain in the LRU
 list and will be evicted from the LRU list as they age and move towards
 the tail of the LRU list. */
-static __attribute__((nonnull(1)))
+static MY_ATTRIBUTE((nonnull(1)))
 void
 buf_flush_dirty_pages(
 /*==================*/
@@ -677,7 +677,7 @@ buf_flush_dirty_pages(
 /******************************************************************//**
 Remove all pages that belong to a given tablespace inside a specific
 buffer pool instance when we are DISCARDing the tablespace. */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 void
 buf_LRU_remove_all_pages(
 /*=====================*/
@@ -825,7 +825,7 @@ buffer pool instance when we are deleting the data file(s) of that
 tablespace. The pages still remain a part of LRU and are evicted from
 the list as they age towards the tail of the LRU only if buf_remove
 is BUF_REMOVE_FLUSH_NO_WRITE. */
-static	__attribute__((nonnull(1)))
+static	MY_ATTRIBUTE((nonnull(1)))
 void
 buf_LRU_remove_pages(
 /*=================*/
--- a/storage/innobase/data/data0data.cc
+++ b/storage/innobase/data/data0data.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1994, 2012, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1994, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -715,7 +715,7 @@ UNIV_INTERN
 void
 dtuple_convert_back_big_rec(
 /*========================*/
-	dict_index_t*	index __attribute__((unused)),	/*!< in: index */
+	dict_index_t*	index MY_ATTRIBUTE((unused)),	/*!< in: index */
 	dtuple_t*	entry,	/*!< in: entry whose data was put to vector */
 	big_rec_t*	vector)	/*!< in, own: big rec vector; it is
 				freed in this function */
--- a/storage/innobase/dict/dict0crea.cc
+++ b/storage/innobase/dict/dict0crea.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1996, 2014, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1996, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -246,7 +246,7 @@ dict_create_sys_columns_tuple(
 /***************************************************************//**
 Builds a table definition to insert.
 @return	DB_SUCCESS or error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 dict_build_table_def_step(
 /*======================*/
@@ -573,7 +573,7 @@ dict_create_search_tuple(
 /***************************************************************//**
 Builds an index definition row to insert.
 @return	DB_SUCCESS or error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 dict_build_index_def_step(
 /*======================*/
@@ -648,7 +648,7 @@ dict_build_field_def_step(
 /***************************************************************//**
 Creates an index tree for the index if it is not a member of a cluster.
 @return	DB_SUCCESS or DB_OUT_OF_FILE_SPACE */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 dict_create_index_tree_step(
 /*========================*/
@@ -1464,7 +1464,7 @@ dict_create_or_check_foreign_constraint_tables(void)
 /****************************************************************//**
 Evaluate the given foreign key SQL statement.
 @return	error code or DB_SUCCESS */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 dict_foreign_eval_sql(
 /*==================*/
@@ -1530,7 +1530,7 @@ dict_foreign_eval_sql(
 Add a single foreign key field definition to the data dictionary tables in
 the database.
 @return	error code or DB_SUCCESS */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 dict_create_add_foreign_field_to_dictionary(
 /*========================================*/
--- a/storage/innobase/dict/dict0load.cc
+++ b/storage/innobase/dict/dict0load.cc
@@ -1783,7 +1783,7 @@ Loads definitions for table indexes. Adds them to the data dictionary
 cache.
 @return DB_SUCCESS if ok, DB_CORRUPTION if corruption of dictionary
 table or DB_UNSUPPORTED if table has unknown index type */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 dberr_t
 dict_load_indexes(
 /*==============*/
@@ -2789,7 +2789,7 @@ dict_load_foreign_cols(
 /***********************************************************************//**
 Loads a foreign key constraint to the dictionary cache.
 @return	DB_SUCCESS or error code */
-static __attribute__((nonnull(1), warn_unused_result))
+static MY_ATTRIBUTE((nonnull(1), warn_unused_result))
 dberr_t
 dict_load_foreign(
 /*==============*/
--- a/storage/innobase/dict/dict0mem.cc
+++ b/storage/innobase/dict/dict0mem.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1996, 2015, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1996, 2016, Oracle and/or its affiliates. All Rights Reserved.
 Copyright (c) 2012, Facebook Inc.
 
 This program is free software; you can redistribute it and/or modify it under
@@ -264,7 +264,7 @@ dict_mem_table_add_col(
 
 /**********************************************************************//**
 Renames a column of a table in the data dictionary cache. */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 void
 dict_mem_table_col_rename_low(
 /*==========================*/
--- a/storage/innobase/dict/dict0stats_bg.cc
+++ b/storage/innobase/dict/dict0stats_bg.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 2012, 2013, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 2012, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -331,7 +331,7 @@ extern "C" UNIV_INTERN
 os_thread_ret_t
 DECLARE_THREAD(dict_stats_thread)(
 /*==============================*/
-	void*	arg __attribute__((unused)))	/*!< in: a dummy parameter
+	void*	arg MY_ATTRIBUTE((unused)))	/*!< in: a dummy parameter
 						required by os_thread_create */
 {
 	ut_a(!srv_read_only_mode);
--- a/storage/innobase/fil/fil0fil.cc
+++ b/storage/innobase/fil/fil0fil.cc
@@ -1875,7 +1875,7 @@ fil_set_max_space_id_if_bigger(
 Writes the flushed lsn and the latest archived log number to the page header
 of the first page of a data file of the system tablespace (space 0),
 which is uncompressed. */
-static __attribute__((warn_unused_result))
+static MY_ATTRIBUTE((warn_unused_result))
 dberr_t
 fil_write_lsn_and_arch_no_to_file(
 /*==============================*/
@@ -1883,7 +1883,7 @@ fil_write_lsn_and_arch_no_to_file(
 	ulint	sum_of_sizes,	/*!< in: combined size of previous files
 				in space, in database pages */
 	lsn_t	lsn,		/*!< in: lsn to write */
-	ulint	arch_log_no __attribute__((unused)))
+	ulint	arch_log_no MY_ATTRIBUTE((unused)))
 				/*!< in: archived log number to write */
 {
 	byte*	buf1;
@@ -1970,7 +1970,7 @@ Checks the consistency of the first data page of a tablespace
 at database startup.
 @retval NULL on success, or if innodb_force_recovery is set
 @return pointer to an error message string */
-static __attribute__((warn_unused_result))
+static MY_ATTRIBUTE((warn_unused_result))
 const char*
 fil_check_first_page(
 /*=================*/
--- a/storage/innobase/fsp/fsp0fsp.cc
+++ b/storage/innobase/fsp/fsp0fsp.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1995, 2015, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1995, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -93,7 +93,7 @@ fseg_n_reserved_pages_low(
 /********************************************************************//**
 Marks a page used. The page must reside within the extents of the given
 segment. */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 void
 fseg_mark_page_used(
 /*================*/
@@ -132,7 +132,7 @@ fsp_fill_free_list(
 	ulint		space,		/*!< in: space */
 	fsp_header_t*	header,		/*!< in/out: space header */
 	mtr_t*		mtr)		/*!< in/out: mini-transaction */
-	UNIV_COLD __attribute__((nonnull));
+	UNIV_COLD MY_ATTRIBUTE((nonnull));
 /**********************************************************************//**
 Allocates a single free page from a segment. This function implements
 the intelligent allocation strategy which tries to minimize file space
@@ -161,7 +161,7 @@ fseg_alloc_free_page_low(
 				in which the page should be initialized.
 				If init_mtr!=mtr, but the page is already
 				latched in mtr, do not initialize the page. */
-	__attribute__((warn_unused_result, nonnull));
+	MY_ATTRIBUTE((warn_unused_result, nonnull));
 #endif /* !UNIV_HOTBACKUP */
 
 /**********************************************************************//**
@@ -425,7 +425,7 @@ descriptor resides is x-locked. This function no longer extends the data
 file.
 @return pointer to the extent descriptor, NULL if the page does not
 exist in the space or if the offset is >= the free limit */
-UNIV_INLINE __attribute__((nonnull, warn_unused_result))
+UNIV_INLINE MY_ATTRIBUTE((nonnull, warn_unused_result))
 xdes_t*
 xdes_get_descriptor_with_space_hdr(
 /*===============================*/
@@ -487,7 +487,7 @@ is necessary to make the descriptor defined, as they are uninitialized
 above the free limit.
 @return pointer to the extent descriptor, NULL if the page does not
 exist in the space or if the offset exceeds the free limit */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 xdes_t*
 xdes_get_descriptor(
 /*================*/
@@ -614,7 +614,7 @@ byte*
 fsp_parse_init_file_page(
 /*=====================*/
 	byte*		ptr,	/*!< in: buffer */
-	byte*		end_ptr __attribute__((unused)), /*!< in: buffer end */
+	byte*		end_ptr MY_ATTRIBUTE((unused)), /*!< in: buffer end */
 	buf_block_t*	block)	/*!< in: block or NULL */
 {
 	ut_ad(ptr && end_ptr);
@@ -850,7 +850,7 @@ fsp_header_get_tablespace_size(void)
 Tries to extend a single-table tablespace so that a page would fit in the
 data file.
 @return	TRUE if success */
-static UNIV_COLD __attribute__((nonnull, warn_unused_result))
+static UNIV_COLD MY_ATTRIBUTE((nonnull, warn_unused_result))
 ibool
 fsp_try_extend_data_file_with_pages(
 /*================================*/
@@ -882,7 +882,7 @@ fsp_try_extend_data_file_with_pages(
 /***********************************************************************//**
 Tries to extend the last data file of a tablespace if it is auto-extending.
 @return	FALSE if not auto-extending */
-static UNIV_COLD __attribute__((nonnull))
+static UNIV_COLD MY_ATTRIBUTE((nonnull))
 ibool
 fsp_try_extend_data_file(
 /*=====================*/
@@ -1236,7 +1236,7 @@ fsp_alloc_free_extent(
 
 /**********************************************************************//**
 Allocates a single free page from a space. */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 void
 fsp_alloc_from_free_frag(
 /*=====================*/
@@ -1327,7 +1327,7 @@ Allocates a single free page from a space. The page is marked as used.
 @retval block, rw_lock_x_lock_count(&block->lock) == 1 if allocation succeeded
 (init_mtr == mtr, or the page was not previously freed in mtr)
 @retval block (not allocated or initialized) otherwise */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 buf_block_t*
 fsp_alloc_free_page(
 /*================*/
@@ -1576,9 +1576,9 @@ fsp_seg_inode_page_get_nth_inode(
 /*=============================*/
 	page_t*	page,	/*!< in: segment inode page */
 	ulint	i,	/*!< in: inode index on page */
-	ulint	zip_size __attribute__((unused)),
+	ulint	zip_size MY_ATTRIBUTE((unused)),
 			/*!< in: compressed page size, or 0 */
-	mtr_t*	mtr __attribute__((unused)))
+	mtr_t*	mtr MY_ATTRIBUTE((unused)))
 			/*!< in/out: mini-transaction */
 {
 	ut_ad(i < FSP_SEG_INODES_PER_PAGE(zip_size));
@@ -1877,7 +1877,7 @@ fseg_get_nth_frag_page_no(
 /*======================*/
 	fseg_inode_t*	inode,	/*!< in: segment inode */
 	ulint		n,	/*!< in: slot index */
-	mtr_t*		mtr __attribute__((unused)))
+	mtr_t*		mtr MY_ATTRIBUTE((unused)))
 				/*!< in/out: mini-transaction */
 {
 	ut_ad(inode && mtr);
@@ -2958,7 +2958,7 @@ fsp_get_available_space_in_free_extents(
 /********************************************************************//**
 Marks a page used. The page must reside within the extents of the given
 segment. */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 void
 fseg_mark_page_used(
 /*================*/
--- a/storage/innobase/fts/fts0blex.cc
+++ b/storage/innobase/fts/fts0blex.cc
@@ -305,9 +305,9 @@ YY_BUFFER_STATE fts0b_scan_buffer (char *base,yy_size_t size ,yyscan_t yyscanner
 YY_BUFFER_STATE fts0b_scan_string (yyconst char *yy_str ,yyscan_t yyscanner );
 YY_BUFFER_STATE fts0b_scan_bytes (yyconst char *bytes,int len ,yyscan_t yyscanner );
 
-void *fts0balloc (yy_size_t ,           yyscan_t yyscanner __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) );
-void *fts0brealloc (void *,yy_size_t ,           yyscan_t yyscanner __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) );
-void fts0bfree (void * ,           yyscan_t yyscanner __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) );
+void *fts0balloc (yy_size_t ,           yyscan_t yyscanner MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) );
+void *fts0brealloc (void *,yy_size_t ,           yyscan_t yyscanner MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) );
+void fts0bfree (void * ,           yyscan_t yyscanner MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) );
 
 #define yy_new_buffer fts0b_create_buffer
 
@@ -347,7 +347,7 @@ typedef int yy_state_type;
 static yy_state_type yy_get_previous_state (yyscan_t yyscanner );
 static yy_state_type yy_try_NUL_trans (yy_state_type current_state  ,yyscan_t yyscanner);
 static int yy_get_next_buffer (yyscan_t yyscanner );
-static void yy_fatal_error (yyconst char msg[] ,           yyscan_t yyscanner __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) );
+static void yy_fatal_error (yyconst char msg[] ,           yyscan_t yyscanner MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) );
 
 /* Done after the current pattern has been matched and before the
  * corresponding action - sets up yytext.
@@ -451,7 +451,7 @@ static yyconst flex_int16_t yy_chk[32] =
 #line 1 "fts0blex.l"
 /*****************************************************************************
 
-Copyright (c) 2007, 2014, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 2007, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -579,11 +579,11 @@ extern int fts0bwrap (yyscan_t yyscanner );
 #endif
 
 #ifndef yytext_ptr
-static void yy_flex_strncpy (char *,yyconst char *,int ,           yyscan_t yyscanner __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)));
+static void yy_flex_strncpy (char *,yyconst char *,int ,           yyscan_t yyscanner MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)));
 #endif
 
 #ifdef YY_NEED_STRLEN
-static int yy_flex_strlen (yyconst char * ,           yyscan_t yyscanner __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)));
+static int yy_flex_strlen (yyconst char * ,           yyscan_t yyscanner MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)));
 #endif
 
 #ifndef YY_NO_INPUT
@@ -1609,7 +1609,7 @@ YY_BUFFER_STATE fts0b_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , y
 #define YY_EXIT_FAILURE 2
 #endif
 
-static void yy_fatal_error (yyconst char* msg ,            yyscan_t yyscanner __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)))
+static void yy_fatal_error (yyconst char* msg ,            yyscan_t yyscanner MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)))
 {
 	(void) fprintf( stderr, "%s\n", msg );
 	exit( YY_EXIT_FAILURE );
@@ -1910,7 +1910,7 @@ int fts0blex_destroy  (yyscan_t yyscanner)
  */
 
 #ifndef yytext_ptr
-static void yy_flex_strncpy (char* s1, yyconst char * s2, int n ,            yyscan_t yyscanner __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)))
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n ,            yyscan_t yyscanner MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)))
 {
 	register int i;
 	for ( i = 0; i < n; ++i )
@@ -1919,7 +1919,7 @@ static void yy_flex_strncpy (char* s1, yyconst char * s2, int n ,            yys
 #endif
 
 #ifdef YY_NEED_STRLEN
-static int yy_flex_strlen (yyconst char * s ,            yyscan_t yyscanner __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)))
+static int yy_flex_strlen (yyconst char * s ,            yyscan_t yyscanner MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)))
 {
 	register int n;
 	for ( n = 0; s[n]; ++n )
@@ -1929,12 +1929,12 @@ static int yy_flex_strlen (yyconst char * s ,            yyscan_t yyscanner __at
 }
 #endif
 
-void *fts0balloc (yy_size_t  size ,            yyscan_t yyscanner __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)))
+void *fts0balloc (yy_size_t  size ,            yyscan_t yyscanner MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)))
 {
 	return (void *) malloc( size );
 }
 
-void *fts0brealloc  (void * ptr, yy_size_t  size ,            yyscan_t yyscanner __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)))
+void *fts0brealloc  (void * ptr, yy_size_t  size ,            yyscan_t yyscanner MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)))
 {
 	/* The cast to (char *) in the following accommodates both
 	 * implementations that use char* generic pointers, and those
@@ -1946,7 +1946,7 @@ void *fts0brealloc  (void * ptr, yy_size_t  size ,            yyscan_t yyscanner
 	return (void *) realloc( (char *) ptr, size );
 }
 
-void fts0bfree (void * ptr ,            yyscan_t yyscanner __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)))
+void fts0bfree (void * ptr ,            yyscan_t yyscanner MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)))
 {
 	free( (char *) ptr );	/* see fts0brealloc() for (char *) cast */
 }
--- a/storage/innobase/fts/fts0fts.cc
+++ b/storage/innobase/fts/fts0fts.cc
@@ -280,7 +280,7 @@ void
 fts_words_free(
 /*===========*/
 	ib_rbt_t*	words)		/*!< in: rb tree of words */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 #ifdef FTS_CACHE_SIZE_DEBUG
 /****************************************************************//**
 Read the max cache size parameter from the config table. */
@@ -302,7 +302,7 @@ fts_add_doc_by_id(
 /*==============*/
 	fts_trx_table_t*ftt,		/*!< in: FTS trx table */
 	doc_id_t	doc_id,		/*!< in: doc id */
-	ib_vector_t*	fts_indexes __attribute__((unused)));
+	ib_vector_t*	fts_indexes MY_ATTRIBUTE((unused)));
 					/*!< in: affected fts indexes */
 #ifdef FTS_DOC_STATS_DEBUG
 /****************************************************************//**
@@ -317,7 +317,7 @@ fts_is_word_in_index(
 	fts_table_t*	fts_table,	/*!< in: table instance */
 	const fts_string_t* word,	/*!< in: the word to check */
 	ibool*		found)		/*!< out: TRUE if exists */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 #endif /* FTS_DOC_STATS_DEBUG */
 
 /******************************************************************//**
@@ -332,7 +332,7 @@ fts_update_sync_doc_id(
 	const char*		table_name,	/*!< in: table name, or NULL */
 	doc_id_t		doc_id,		/*!< in: last document id */
 	trx_t*			trx)		/*!< in: update trx, or NULL */
-	__attribute__((nonnull(1)));
+	MY_ATTRIBUTE((nonnull(1)));
 
 /****************************************************************//**
 This function loads the default InnoDB stopword list */
@@ -1477,7 +1477,7 @@ fts_cache_add_doc(
 /****************************************************************//**
 Drops a table. If the table can't be found we return a SUCCESS code.
 @return DB_SUCCESS or error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 fts_drop_table(
 /*===========*/
@@ -1519,7 +1519,7 @@ fts_drop_table(
 /****************************************************************//**
 Rename a single auxiliary table due to database name change.
 @return DB_SUCCESS or error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 fts_rename_one_aux_table(
 /*=====================*/
@@ -1628,7 +1628,7 @@ Drops the common ancillary tables needed for supporting an FTS index
 on the given table. row_mysql_lock_data_dictionary must have been called
 before this.
 @return DB_SUCCESS or error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 fts_drop_common_tables(
 /*===================*/
@@ -1755,7 +1755,7 @@ Drops FTS ancillary tables needed for supporting an FTS index
 on the given table. row_mysql_lock_data_dictionary must have been called
 before this.
 @return DB_SUCCESS or error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 fts_drop_all_index_tables(
 /*======================*/
@@ -2663,7 +2663,7 @@ fts_get_next_doc_id(
 This function fetch the Doc ID from CONFIG table, and compare with
 the Doc ID supplied. And store the larger one to the CONFIG table.
 @return DB_SUCCESS if OK */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 dberr_t
 fts_cmp_set_sync_doc_id(
 /*====================*/
@@ -2917,7 +2917,7 @@ fts_add(
 /*********************************************************************//**
 Do commit-phase steps necessary for the deletion of a row.
 @return DB_SUCCESS or error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 fts_delete(
 /*=======*/
@@ -3008,7 +3008,7 @@ fts_delete(
 /*********************************************************************//**
 Do commit-phase steps necessary for the modification of a row.
 @return DB_SUCCESS or error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 fts_modify(
 /*=======*/
@@ -3079,7 +3079,7 @@ fts_create_doc_id(
 The given transaction is about to be committed; do whatever is necessary
 from the FTS system's POV.
 @return DB_SUCCESS or error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 fts_commit_table(
 /*=============*/
@@ -3412,7 +3412,7 @@ fts_add_doc_by_id(
 /*==============*/
 	fts_trx_table_t*ftt,		/*!< in: FTS trx table */
 	doc_id_t	doc_id,		/*!< in: doc id */
-	ib_vector_t*	fts_indexes __attribute__((unused)))
+	ib_vector_t*	fts_indexes MY_ATTRIBUTE((unused)))
 					/*!< in: affected fts indexes */
 {
 	mtr_t		mtr;
@@ -3532,7 +3532,7 @@ fts_add_doc_by_id(
 				get_doc, clust_index, doc_pcur, offsets, &doc);
 
 			if (doc.found) {
-				ibool	success __attribute__((unused));
+				ibool	success MY_ATTRIBUTE((unused));
 
 				btr_pcur_store_position(doc_pcur, &mtr);
 				mtr_commit(&mtr);
@@ -3641,7 +3641,7 @@ fts_get_max_doc_id(
 	dict_table_t*	table)		/*!< in: user table */
 {
 	dict_index_t*	index;
-	dict_field_t*	dfield __attribute__((unused)) = NULL;
+	dict_field_t*	dfield MY_ATTRIBUTE((unused)) = NULL;
 	doc_id_t	doc_id = 0;
 	mtr_t		mtr;
 	btr_pcur_t	pcur;
@@ -3899,7 +3899,7 @@ fts_write_node(
 /*********************************************************************//**
 Add rows to the DELETED_CACHE table.
 @return DB_SUCCESS if all went well else error code*/
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 fts_sync_add_deleted_cache(
 /*=======================*/
@@ -3953,7 +3953,7 @@ fts_sync_add_deleted_cache(
 @param[in]	index_cache	index cache
 @param[in]	unlock_cache	whether unlock cache when write node
 @return DB_SUCCESS if all went well else error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 fts_sync_write_words(
 	trx_t*			trx,
@@ -4089,7 +4089,7 @@ fts_sync_write_words(
 /*********************************************************************//**
 Write a single documents statistics to disk.
 @return DB_SUCCESS if all went well else error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 fts_sync_write_doc_stat(
 /*====================*/
@@ -4343,7 +4343,7 @@ fts_sync_begin(
 Run SYNC on the table, i.e., write out data from the index specific
 cache to the FTS aux INDEX table and FTS aux doc id stats table.
 @return DB_SUCCESS if all OK */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 fts_sync_index(
 /*===========*/
@@ -4411,7 +4411,7 @@ fts_sync_index_check(
 /*********************************************************************//**
 Commit the SYNC, change state of processed doc ids etc.
 @return DB_SUCCESS if all OK */
-static  __attribute__((nonnull, warn_unused_result))
+static  MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 fts_sync_commit(
 /*============*/
@@ -6169,7 +6169,7 @@ fts_update_hex_format_flag(
 /*********************************************************************//**
 Rename an aux table to HEX format. It's called when "%016llu" is used
 to format an object id in table name, which only happens in Windows. */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 fts_rename_one_aux_table_to_hex_format(
 /*===================================*/
@@ -6260,7 +6260,7 @@ Note the ids in tables are correct but the names are old ambiguous ones.
 
 This function should make sure that either all the parent table and aux tables
 are set DICT_TF2_FTS_AUX_HEX_NAME with flags2 or none of them are set */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 fts_rename_aux_tables_to_hex_format_low(
 /*====================================*/
@@ -6414,7 +6414,7 @@ fts_fake_hex_to_dec(
 {
 	ib_id_t		dec_id = 0;
 	char		tmp_id[FTS_AUX_MIN_TABLE_ID_LENGTH];
-	int		ret __attribute__((unused));
+	int		ret MY_ATTRIBUTE((unused));
 
 	ret = sprintf(tmp_id, UINT64PFx, id);
 	ut_ad(ret == 16);
@@ -6736,7 +6736,7 @@ fts_drop_aux_table_from_vector(
 Check and drop all orphaned FTS auxiliary tables, those that don't have
 a parent table or FTS index defined on them.
 @return DB_SUCCESS or error code */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 void
 fts_check_and_drop_orphaned_tables(
 /*===============================*/
--- a/storage/innobase/fts/fts0opt.cc
+++ b/storage/innobase/fts/fts0opt.cc
@@ -797,7 +797,7 @@ fts_zip_deflate_end(
 Read the words from the FTS INDEX.
 @return DB_SUCCESS if all OK, DB_TABLE_NOT_FOUND if no more indexes
         to search else error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 fts_index_fetch_words(
 /*==================*/
@@ -1131,7 +1131,7 @@ fts_optimize_lookup(
 /**********************************************************************//**
 Encode the word pos list into the node
 @return DB_SUCCESS or error code*/
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 dberr_t
 fts_optimize_encode_node(
 /*=====================*/
@@ -1220,7 +1220,7 @@ fts_optimize_encode_node(
 /**********************************************************************//**
 Optimize the data contained in a node.
 @return DB_SUCCESS or error code*/
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 dberr_t
 fts_optimize_node(
 /*==============*/
@@ -1318,7 +1318,7 @@ test_again:
 /**********************************************************************//**
 Determine the starting pos within the deleted doc id vector for a word.
 @return delete position */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 int
 fts_optimize_deleted_pos(
 /*=====================*/
@@ -1447,7 +1447,7 @@ fts_optimize_word(
 /**********************************************************************//**
 Update the FTS index table. This is a delete followed by an insert.
 @return DB_SUCCESS or error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 fts_optimize_write_word(
 /*====================*/
@@ -1550,7 +1550,7 @@ fts_word_free(
 /**********************************************************************//**
 Optimize the word ilist and rewrite data to the FTS index.
 @return status one of RESTART, EXIT, ERROR */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 fts_optimize_compact(
 /*=================*/
@@ -1645,7 +1645,7 @@ fts_optimize_create(
 /**********************************************************************//**
 Get optimize start time of an FTS index.
 @return DB_SUCCESS if all OK else error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 fts_optimize_get_index_start_time(
 /*==============================*/
@@ -1661,7 +1661,7 @@ fts_optimize_get_index_start_time(
 /**********************************************************************//**
 Set the optimize start time of an FTS index.
 @return DB_SUCCESS if all OK else error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 fts_optimize_set_index_start_time(
 /*==============================*/
@@ -1677,7 +1677,7 @@ fts_optimize_set_index_start_time(
 /**********************************************************************//**
 Get optimize end time of an FTS index.
 @return DB_SUCCESS if all OK else error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 fts_optimize_get_index_end_time(
 /*============================*/
@@ -1692,7 +1692,7 @@ fts_optimize_get_index_end_time(
 /**********************************************************************//**
 Set the optimize end time of an FTS index.
 @return DB_SUCCESS if all OK else error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 fts_optimize_set_index_end_time(
 /*============================*/
@@ -1912,7 +1912,7 @@ fts_optimize_set_next_word(
 Optimize is complete. Set the completion time, and reset the optimize
 start string for this FTS index to "".
 @return DB_SUCCESS if all OK */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 fts_optimize_index_completed(
 /*=========================*/
@@ -1952,7 +1952,7 @@ fts_optimize_index_completed(
 Read the list of words from the FTS auxiliary index that will be
 optimized in this pass.
 @return DB_SUCCESS if all OK */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 fts_optimize_index_read_words(
 /*==========================*/
@@ -2009,7 +2009,7 @@ fts_optimize_index_read_words(
 Run OPTIMIZE on the given FTS index. Note: this can take a very long
 time (hours).
 @return DB_SUCCESS if all OK */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 fts_optimize_index(
 /*===============*/
@@ -2080,7 +2080,7 @@ fts_optimize_index(
 /**********************************************************************//**
 Delete the document ids in the delete, and delete cache tables.
 @return DB_SUCCESS if all OK */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 fts_optimize_purge_deleted_doc_ids(
 /*===============================*/
@@ -2149,7 +2149,7 @@ fts_optimize_purge_deleted_doc_ids(
 /**********************************************************************//**
 Delete the document ids in the pending delete, and delete tables.
 @return DB_SUCCESS if all OK */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 fts_optimize_purge_deleted_doc_id_snapshot(
 /*=======================================*/
@@ -2199,7 +2199,7 @@ Copy the deleted doc ids that will be purged during this optimize run
 to the being deleted FTS auxiliary tables. The transaction is committed
 upon successfull copy and rolled back on DB_DUPLICATE_KEY error.
 @return DB_SUCCESS if all OK */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 fts_optimize_create_deleted_doc_id_snapshot(
 /*========================================*/
@@ -2237,7 +2237,7 @@ fts_optimize_create_deleted_doc_id_snapshot(
 Read in the document ids that are to be purged during optimize. The
 transaction is committed upon successfully read.
 @return DB_SUCCESS if all OK */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 fts_optimize_read_deleted_doc_id_snapshot(
 /*======================================*/
@@ -2274,7 +2274,7 @@ Optimze all the FTS indexes, skipping those that have already been
 optimized, since the FTS auxiliary indexes are not guaranteed to be
 of the same cardinality.
 @return DB_SUCCESS if all OK */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 fts_optimize_indexes(
 /*=================*/
@@ -2344,7 +2344,7 @@ fts_optimize_indexes(
 /*********************************************************************//**
 Cleanup the snapshot tables and the master deleted table.
 @return DB_SUCCESS if all OK */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 fts_optimize_purge_snapshot(
 /*========================*/
@@ -2373,7 +2373,7 @@ fts_optimize_purge_snapshot(
 /*********************************************************************//**
 Reset the start time to 0 so that a new optimize can be started.
 @return DB_SUCCESS if all OK */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 fts_optimize_reset_start_time(
 /*==========================*/
@@ -2412,7 +2412,7 @@ fts_optimize_reset_start_time(
 /*********************************************************************//**
 Run OPTIMIZE on the given table by a background thread.
 @return DB_SUCCESS if all OK */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 dberr_t
 fts_optimize_table_bk(
 /*==================*/
--- a/storage/innobase/fts/fts0que.cc
+++ b/storage/innobase/fts/fts0que.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 2007, 2015, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 2007, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -287,7 +287,7 @@ fts_expand_query(
 	dict_index_t*	index,		/*!< in: FTS index to search */
 	fts_query_t*	query)		/*!< in: query result, to be freed
 					by the client */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*************************************************************//**
 This function finds documents that contain all words in a
 phrase or proximity search. And if proximity search, verify
@@ -1128,7 +1128,7 @@ cont_search:
 /*****************************************************************//**
 Set difference.
 @return DB_SUCCESS if all go well */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 fts_query_difference(
 /*=================*/
@@ -1220,7 +1220,7 @@ fts_query_difference(
 /*****************************************************************//**
 Intersect the token doc ids with the current set.
 @return DB_SUCCESS if all go well */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 fts_query_intersect(
 /*================*/
@@ -1398,7 +1398,7 @@ fts_query_cache(
 /*****************************************************************//**
 Set union.
 @return DB_SUCCESS if all go well */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 fts_query_union(
 /*============*/
@@ -2014,7 +2014,7 @@ fts_query_select(
 Read the rows from the FTS index, that match word and where the
 doc id is between first and last doc id.
 @return DB_SUCCESS if all go well else error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 fts_query_find_term(
 /*================*/
@@ -2154,7 +2154,7 @@ fts_query_sum(
 /********************************************************************
 Calculate the total documents that contain a particular word (term).
 @return DB_SUCCESS if all go well else error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 fts_query_total_docs_containing_term(
 /*=================================*/
@@ -2233,7 +2233,7 @@ fts_query_total_docs_containing_term(
 /********************************************************************
 Get the total number of words in a documents.
 @return DB_SUCCESS if all go well else error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 fts_query_terms_in_document(
 /*========================*/
@@ -2314,7 +2314,7 @@ fts_query_terms_in_document(
 /*****************************************************************//**
 Retrieve the document and match the phrase tokens.
 @return DB_SUCCESS or error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 fts_query_match_document(
 /*=====================*/
@@ -2360,7 +2360,7 @@ fts_query_match_document(
 This function fetches the original documents and count the
 words in between matching words to see that is in specified distance
 @return DB_SUCCESS if all OK */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 bool
 fts_query_is_in_proximity_range(
 /*============================*/
@@ -2415,7 +2415,7 @@ fts_query_is_in_proximity_range(
 Iterate over the matched document ids and search the for the
 actual phrase in the text.
 @return DB_SUCCESS if all OK */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 fts_query_search_phrase(
 /*====================*/
@@ -2503,7 +2503,7 @@ func_exit:
 /*****************************************************************//**
 Text/Phrase search.
 @return DB_SUCCESS or error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 fts_query_phrase_search(
 /*====================*/
@@ -2754,7 +2754,7 @@ func_exit:
 /*****************************************************************//**
 Find the word and evaluate.
 @return DB_SUCCESS if all go well */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 fts_query_execute(
 /*==============*/
@@ -4123,7 +4123,7 @@ words in documents found in the first search pass will be used as
 search arguments to search the document again, thus "expand"
 the search result set.
 @return DB_SUCCESS if success, otherwise the error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 fts_expand_query(
 /*=============*/
--- a/storage/innobase/fts/fts0tlex.cc
+++ b/storage/innobase/fts/fts0tlex.cc
@@ -305,9 +305,9 @@ YY_BUFFER_STATE fts0t_scan_buffer (char *base,yy_size_t size ,yyscan_t yyscanner
 YY_BUFFER_STATE fts0t_scan_string (yyconst char *yy_str ,yyscan_t yyscanner );
 YY_BUFFER_STATE fts0t_scan_bytes (yyconst char *bytes,int len ,yyscan_t yyscanner );
 
-void *fts0talloc (yy_size_t ,           yyscan_t yyscanner __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) );
-void *fts0trealloc (void *,yy_size_t ,           yyscan_t yyscanner __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) );
-void fts0tfree (void * ,           yyscan_t yyscanner __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) );
+void *fts0talloc (yy_size_t ,           yyscan_t yyscanner MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) );
+void *fts0trealloc (void *,yy_size_t ,           yyscan_t yyscanner MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) );
+void fts0tfree (void * ,           yyscan_t yyscanner MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) );
 
 #define yy_new_buffer fts0t_create_buffer
 
@@ -347,7 +347,7 @@ typedef int yy_state_type;
 static yy_state_type yy_get_previous_state (yyscan_t yyscanner );
 static yy_state_type yy_try_NUL_trans (yy_state_type current_state  ,yyscan_t yyscanner);
 static int yy_get_next_buffer (yyscan_t yyscanner );
-static void yy_fatal_error (yyconst char msg[] ,           yyscan_t yyscanner __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) );
+static void yy_fatal_error (yyconst char msg[] ,           yyscan_t yyscanner MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) );
 
 /* Done after the current pattern has been matched and before the
  * corresponding action - sets up yytext.
@@ -447,7 +447,7 @@ static yyconst flex_int16_t yy_chk[29] =
 #line 1 "fts0tlex.l"
 /*****************************************************************************
 
-Copyright (c) 2007, 2014, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 2007, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -575,11 +575,11 @@ extern int fts0twrap (yyscan_t yyscanner );
 #endif
 
 #ifndef yytext_ptr
-static void yy_flex_strncpy (char *,yyconst char *,int ,           yyscan_t yyscanner __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)));
+static void yy_flex_strncpy (char *,yyconst char *,int ,           yyscan_t yyscanner MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)));
 #endif
 
 #ifdef YY_NEED_STRLEN
-static int yy_flex_strlen (yyconst char * ,           yyscan_t yyscanner __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)));
+static int yy_flex_strlen (yyconst char * ,           yyscan_t yyscanner MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)));
 #endif
 
 #ifndef YY_NO_INPUT
@@ -1602,7 +1602,7 @@ YY_BUFFER_STATE fts0t_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , y
 #define YY_EXIT_FAILURE 2
 #endif
 
-static void yy_fatal_error (yyconst char* msg ,            yyscan_t yyscanner __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)))
+static void yy_fatal_error (yyconst char* msg ,            yyscan_t yyscanner MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)))
 {
     	(void) fprintf( stderr, "%s\n", msg );
 	exit( YY_EXIT_FAILURE );
@@ -1903,7 +1903,7 @@ int fts0tlex_destroy  (yyscan_t yyscanner)
  */
 
 #ifndef yytext_ptr
-static void yy_flex_strncpy (char* s1, yyconst char * s2, int n ,            yyscan_t yyscanner __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)))
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n ,            yyscan_t yyscanner MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)))
 {
 	register int i;
 	for ( i = 0; i < n; ++i )
@@ -1912,7 +1912,7 @@ static void yy_flex_strncpy (char* s1, yyconst char * s2, int n ,            yys
 #endif
 
 #ifdef YY_NEED_STRLEN
-static int yy_flex_strlen (yyconst char * s ,            yyscan_t yyscanner __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)))
+static int yy_flex_strlen (yyconst char * s ,            yyscan_t yyscanner MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)))
 {
 	register int n;
 	for ( n = 0; s[n]; ++n )
@@ -1922,12 +1922,12 @@ static int yy_flex_strlen (yyconst char * s ,            yyscan_t yyscanner __at
 }
 #endif
 
-void *fts0talloc (yy_size_t  size ,            yyscan_t yyscanner __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)))
+void *fts0talloc (yy_size_t  size ,            yyscan_t yyscanner MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)))
 {
 	return (void *) malloc( size );
 }
 
-void *fts0trealloc  (void * ptr, yy_size_t  size ,            yyscan_t yyscanner __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)))
+void *fts0trealloc  (void * ptr, yy_size_t  size ,            yyscan_t yyscanner MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)))
 {
 	/* The cast to (char *) in the following accommodates both
 	 * implementations that use char* generic pointers, and those
@@ -1939,7 +1939,7 @@ void *fts0trealloc  (void * ptr, yy_size_t  size ,            yyscan_t yyscanner
 	return (void *) realloc( (char *) ptr, size );
 }
 
-void fts0tfree (void * ptr ,            yyscan_t yyscanner __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)) __attribute__((unused)))
+void fts0tfree (void * ptr ,            yyscan_t yyscanner MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)) MY_ATTRIBUTE((unused)))
 {
 	free( (char *) ptr );	/* see fts0trealloc() for (char *) cast */
 }
--- a/storage/innobase/fts/make_parser.sh
+++ b/storage/innobase/fts/make_parser.sh
@@ -1,6 +1,6 @@
 #!/bin/sh
 #
-# Copyright (c) 2007, 2011, Oracle and/or its affiliates. All Rights Reserved.
+# Copyright (c) 2007, 2016, Oracle and/or its affiliates. All Rights Reserved.
 #
 # This program is free software; you can redistribute it and/or modify it under
 # the terms of the GNU General Public License as published by the Free Software
@@ -22,15 +22,15 @@ make -f Makefile.query
 echo '#include "univ.i"' > $TMPF
 
 # This is to avoid compiler warning about unused parameters.
-# FIXME: gcc extension "__attribute__" causing compilation errors on windows
+# FIXME: gcc extension "MY_ATTRIBUTE" causing compilation errors on windows
 # platform. Quote them out for now.
 sed -e '
-s/^\(static.*void.*yy_fatal_error.*msg.*,\)\(.*yyscanner\)/\1 \2 __attribute__((unused))/;
-s/^\(static.*void.*yy_flex_strncpy.*n.*,\)\(.*yyscanner\)/\1 \2 __attribute__((unused))/;
-s/^\(static.*int.*yy_flex_strlen.*s.*,\)\(.*yyscanner\)/\1 \2 __attribute__((unused))/;
-s/^\(\(static\|void\).*fts0[bt]alloc.*,\)\(.*yyscanner\)/\1 \3 __attribute__((unused))/;
-s/^\(\(static\|void\).*fts0[bt]realloc.*,\)\(.*yyscanner\)/\1 \3 __attribute__((unused))/;
-s/^\(\(static\|void\).*fts0[bt]free.*,\)\(.*yyscanner\)/\1 \3 __attribute__((unused))/;
+s/^\(static.*void.*yy_fatal_error.*msg.*,\)\(.*yyscanner\)/\1 \2 MY_ATTRIBUTE((unused))/;
+s/^\(static.*void.*yy_flex_strncpy.*n.*,\)\(.*yyscanner\)/\1 \2 MY_ATTRIBUTE((unused))/;
+s/^\(static.*int.*yy_flex_strlen.*s.*,\)\(.*yyscanner\)/\1 \2 MY_ATTRIBUTE((unused))/;
+s/^\(\(static\|void\).*fts0[bt]alloc.*,\)\(.*yyscanner\)/\1 \3 MY_ATTRIBUTE((unused))/;
+s/^\(\(static\|void\).*fts0[bt]realloc.*,\)\(.*yyscanner\)/\1 \3 MY_ATTRIBUTE((unused))/;
+s/^\(\(static\|void\).*fts0[bt]free.*,\)\(.*yyscanner\)/\1 \3 MY_ATTRIBUTE((unused))/;
 ' < fts0blex.cc >> $TMPF
 
 mv $TMPF fts0blex.cc
@@ -38,12 +38,12 @@ mv $TMPF fts0blex.cc
 echo '#include "univ.i"' > $TMPF
 
 sed -e '
-s/^\(static.*void.*yy_fatal_error.*msg.*,\)\(.*yyscanner\)/\1 \2 __attribute__((unused))/;
-s/^\(static.*void.*yy_flex_strncpy.*n.*,\)\(.*yyscanner\)/\1 \2 __attribute__((unused))/;
-s/^\(static.*int.*yy_flex_strlen.*s.*,\)\(.*yyscanner\)/\1 \2 __attribute__((unused))/;
-s/^\(\(static\|void\).*fts0[bt]alloc.*,\)\(.*yyscanner\)/\1 \3 __attribute__((unused))/;
-s/^\(\(static\|void\).*fts0[bt]realloc.*,\)\(.*yyscanner\)/\1 \3 __attribute__((unused))/;
-s/^\(\(static\|void\).*fts0[bt]free.*,\)\(.*yyscanner\)/\1 \3 __attribute__((unused))/;
+s/^\(static.*void.*yy_fatal_error.*msg.*,\)\(.*yyscanner\)/\1 \2 MY_ATTRIBUTE((unused))/;
+s/^\(static.*void.*yy_flex_strncpy.*n.*,\)\(.*yyscanner\)/\1 \2 MY_ATTRIBUTE((unused))/;
+s/^\(static.*int.*yy_flex_strlen.*s.*,\)\(.*yyscanner\)/\1 \2 MY_ATTRIBUTE((unused))/;
+s/^\(\(static\|void\).*fts0[bt]alloc.*,\)\(.*yyscanner\)/\1 \3 MY_ATTRIBUTE((unused))/;
+s/^\(\(static\|void\).*fts0[bt]realloc.*,\)\(.*yyscanner\)/\1 \3 MY_ATTRIBUTE((unused))/;
+s/^\(\(static\|void\).*fts0[bt]free.*,\)\(.*yyscanner\)/\1 \3 MY_ATTRIBUTE((unused))/;
 ' < fts0tlex.cc >> $TMPF
 
 mv $TMPF fts0tlex.cc
--- a/storage/innobase/handler/ha_innodb.cc
+++ b/storage/innobase/handler/ha_innodb.cc
@@ -1425,7 +1425,7 @@ thd_set_lock_wait_time(
 /********************************************************************//**
 Obtain the InnoDB transaction of a MySQL thread.
 @return	reference to transaction pointer */
-__attribute__((warn_unused_result, nonnull))
+MY_ATTRIBUTE((warn_unused_result, nonnull))
 static inline
 trx_t*&
 thd_to_trx(
@@ -3486,7 +3486,7 @@ int
 innobase_end(
 /*=========*/
 	handlerton*		hton,	/*!< in/out: InnoDB handlerton */
-	ha_panic_function	type __attribute__((unused)))
+	ha_panic_function	type MY_ATTRIBUTE((unused)))
 					/*!< in: ha_panic() parameter */
 {
 	int	err= 0;
@@ -8612,7 +8612,7 @@ create_table_check_doc_id_col(
 
 /*****************************************************************//**
 Creates a table definition to an InnoDB database. */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 int
 create_table_def(
 /*=============*/
@@ -10325,7 +10325,7 @@ innobase_drop_database(
 /*********************************************************************//**
 Renames an InnoDB table.
 @return DB_SUCCESS or error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 innobase_rename_table(
 /*==================*/
@@ -15235,7 +15235,7 @@ static char* srv_buffer_pool_evict;
 Evict all uncompressed pages of compressed tables from the buffer pool.
 Keep the compressed pages in the buffer pool.
 @return whether all uncompressed pages were evicted */
-static __attribute__((warn_unused_result))
+static MY_ATTRIBUTE((warn_unused_result))
 bool
 innodb_buffer_pool_evict_uncompressed(void)
 /*=======================================*/
@@ -15563,13 +15563,13 @@ void
 purge_run_now_set(
 /*==============*/
 	THD*				thd	/*!< in: thread handle */
-					__attribute__((unused)),
+					MY_ATTRIBUTE((unused)),
 	struct st_mysql_sys_var*	var	/*!< in: pointer to system
 						variable */
-					__attribute__((unused)),
+					MY_ATTRIBUTE((unused)),
 	void*				var_ptr	/*!< out: where the formal
 						string goes */
-					__attribute__((unused)),
+					MY_ATTRIBUTE((unused)),
 	const void*			save)	/*!< in: immediate result from
 						check function */
 {
@@ -15586,13 +15586,13 @@ void
 purge_stop_now_set(
 /*===============*/
 	THD*				thd	/*!< in: thread handle */
-					__attribute__((unused)),
+					MY_ATTRIBUTE((unused)),
 	struct st_mysql_sys_var*	var	/*!< in: pointer to system
 						variable */
-					__attribute__((unused)),
+					MY_ATTRIBUTE((unused)),
 	void*				var_ptr	/*!< out: where the formal
 						string goes */
-					__attribute__((unused)),
+					MY_ATTRIBUTE((unused)),
 	const void*			save)	/*!< in: immediate result from
 						check function */
 {
@@ -15608,13 +15608,13 @@ void
 checkpoint_now_set(
 /*===============*/
 	THD*				thd	/*!< in: thread handle */
-					__attribute__((unused)),
+					MY_ATTRIBUTE((unused)),
 	struct st_mysql_sys_var*	var	/*!< in: pointer to system
 						variable */
-					__attribute__((unused)),
+					MY_ATTRIBUTE((unused)),
 	void*				var_ptr	/*!< out: where the formal
 						string goes */
-					__attribute__((unused)),
+					MY_ATTRIBUTE((unused)),
 	const void*			save)	/*!< in: immediate result from
 						check function */
 {
@@ -15635,13 +15635,13 @@ void
 buf_flush_list_now_set(
 /*===================*/
 	THD*				thd	/*!< in: thread handle */
-					__attribute__((unused)),
+					MY_ATTRIBUTE((unused)),
 	struct st_mysql_sys_var*	var	/*!< in: pointer to system
 						variable */
-					__attribute__((unused)),
+					MY_ATTRIBUTE((unused)),
 	void*				var_ptr	/*!< out: where the formal
 						string goes */
-					__attribute__((unused)),
+					MY_ATTRIBUTE((unused)),
 	const void*			save)	/*!< in: immediate result from
 						check function */
 {
@@ -15738,13 +15738,13 @@ void
 buffer_pool_dump_now(
 /*=================*/
 	THD*				thd	/*!< in: thread handle */
-					__attribute__((unused)),
+					MY_ATTRIBUTE((unused)),
 	struct st_mysql_sys_var*	var	/*!< in: pointer to system
 						variable */
-					__attribute__((unused)),
+					MY_ATTRIBUTE((unused)),
 	void*				var_ptr	/*!< out: where the formal
 						string goes */
-					__attribute__((unused)),
+					MY_ATTRIBUTE((unused)),
 	const void*			save)	/*!< in: immediate result from
 						check function */
 {
@@ -15761,13 +15761,13 @@ void
 buffer_pool_load_now(
 /*=================*/
 	THD*				thd	/*!< in: thread handle */
-					__attribute__((unused)),
+					MY_ATTRIBUTE((unused)),
 	struct st_mysql_sys_var*	var	/*!< in: pointer to system
 						variable */
-					__attribute__((unused)),
+					MY_ATTRIBUTE((unused)),
 	void*				var_ptr	/*!< out: where the formal
 						string goes */
-					__attribute__((unused)),
+					MY_ATTRIBUTE((unused)),
 	const void*			save)	/*!< in: immediate result from
 						check function */
 {
@@ -15784,13 +15784,13 @@ void
 buffer_pool_load_abort(
 /*===================*/
 	THD*				thd	/*!< in: thread handle */
-					__attribute__((unused)),
+					MY_ATTRIBUTE((unused)),
 	struct st_mysql_sys_var*	var	/*!< in: pointer to system
 						variable */
-					__attribute__((unused)),
+					MY_ATTRIBUTE((unused)),
 	void*				var_ptr	/*!< out: where the formal
 						string goes */
-					__attribute__((unused)),
+					MY_ATTRIBUTE((unused)),
 	const void*			save)	/*!< in: immediate result from
 						check function */
 {
@@ -15808,10 +15808,10 @@ which control InnoDB "status monitor" output to the error log.
 static
 void
 innodb_status_output_update(
-	THD*				thd __attribute__((unused)),
-	struct st_mysql_sys_var*	var __attribute__((unused)),
-	void*				var_ptr __attribute__((unused)),
-	const void*			save __attribute__((unused)))
+	THD*				thd MY_ATTRIBUTE((unused)),
+	struct st_mysql_sys_var*	var MY_ATTRIBUTE((unused)),
+	void*				var_ptr MY_ATTRIBUTE((unused)),
+	const void*			save MY_ATTRIBUTE((unused)))
 {
 	*static_cast<my_bool*>(var_ptr) = *static_cast<const my_bool*>(save);
 	/* The lock timeout monitor thread also takes care of this
--- a/storage/innobase/handler/ha_innodb.h
+++ b/storage/innobase/handler/ha_innodb.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 2000, 2012, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 2000, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -430,14 +430,14 @@ enum durability_properties thd_get_durability_property(const MYSQL_THD thd);
 @param off	auto_increment_offset
 @param inc	auto_increment_increment */
 void thd_get_autoinc(const MYSQL_THD thd, ulong* off, ulong* inc)
-__attribute__((nonnull));
+MY_ATTRIBUTE((nonnull));
 
 /** Is strict sql_mode set.
 @param thd	Thread object
 @return True if sql_mode has strict mode (all or trans), false otherwise.
 */
 bool thd_is_strict_mode(const MYSQL_THD thd)
-__attribute__((nonnull));
+MY_ATTRIBUTE((nonnull));
 } /* extern "C" */
 
 struct trx_t;
@@ -475,7 +475,7 @@ innobase_index_name_is_reserved(
 	const KEY*	key_info,	/*!< in: Indexes to be created */
 	ulint		num_of_keys)	/*!< in: Number of indexes to
 					be created. */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 /*****************************************************************//**
 Determines InnoDB table flags.
@@ -492,7 +492,7 @@ innobase_table_flags(
 						outside system tablespace */
 	ulint*			flags,		/*!< out: DICT_TF flags */
 	ulint*			flags2)		/*!< out: DICT_TF2 flags */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 /*****************************************************************//**
 Validates the create options. We may build on this function
@@ -509,7 +509,7 @@ create_options_are_invalid(
 					columns and indexes */
 	HA_CREATE_INFO*	create_info,	/*!< in: create info. */
 	bool		use_tablespace)	/*!< in: srv_file_per_table */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 /*********************************************************************//**
 Retrieve the FTS Relevance Ranking result for doc with doc_id
@@ -539,7 +539,7 @@ void
 innobase_fts_close_ranking(
 /*=======================*/
 	FT_INFO*	fts_hdl)	/*!< in: FTS handler */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*****************************************************************//**
 Initialize the table FTS stopword list
 @return TRUE if success */
@@ -550,7 +550,7 @@ innobase_fts_load_stopword(
 	dict_table_t*	table,		/*!< in: Table has the FTS */
 	trx_t*		trx,		/*!< in: transaction */
 	THD*		thd)		/*!< in: current thread */
-	__attribute__((nonnull(1,3), warn_unused_result));
+	MY_ATTRIBUTE((nonnull(1,3), warn_unused_result));
 
 /** Some defines for innobase_fts_check_doc_id_index() return value */
 enum fts_doc_id_index_enum {
@@ -572,7 +572,7 @@ innobase_fts_check_doc_id_index(
 						that is being altered */
 	ulint*			fts_doc_col_no)	/*!< out: The column number for
 						Doc ID */
-	__attribute__((warn_unused_result));
+	MY_ATTRIBUTE((warn_unused_result));
 
 /*******************************************************************//**
 Check whether the table has a unique index with FTS_DOC_ID_INDEX_NAME
@@ -585,7 +585,7 @@ innobase_fts_check_doc_id_index_in_def(
 /*===================================*/
 	ulint		n_key,		/*!< in: Number of keys */
 	const KEY*	key_info)	/*!< in: Key definitions */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 /***********************************************************************
 @return version of the extended FTS API */
--- a/storage/innobase/handler/handler0alter.cc
+++ b/storage/innobase/handler/handler0alter.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 2005, 2015, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 2005, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -98,7 +98,7 @@ static const Alter_inplace_info::HA_ALTER_FLAGS INNOBASE_ALTER_NOREBUILD
 	| Alter_inplace_info::ALTER_COLUMN_NAME;
 
 /* Report an InnoDB error to the client by invoking my_error(). */
-static UNIV_COLD __attribute__((nonnull))
+static UNIV_COLD MY_ATTRIBUTE((nonnull))
 void
 my_error_innodb(
 /*============*/
@@ -195,7 +195,7 @@ innobase_fulltext_exist(
 Determine if ALTER TABLE needs to rebuild the table.
 @param ha_alter_info		the DDL operation
 @return whether it is necessary to rebuild the table */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 bool
 innobase_need_rebuild(
 /*==================*/
@@ -515,7 +515,7 @@ ha_innobase::check_if_supported_inplace_alter(
 /*************************************************************//**
 Initialize the dict_foreign_t structure with supplied info
 @return true if added, false if duplicate foreign->id */
-static __attribute__((nonnull(1,3,5,7)))
+static MY_ATTRIBUTE((nonnull(1,3,5,7)))
 bool
 innobase_init_foreign(
 /*==================*/
@@ -604,7 +604,7 @@ innobase_init_foreign(
 /*************************************************************//**
 Check whether the foreign key options is legit
 @return true if it is */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 bool
 innobase_check_fk_option(
 /*=====================*/
@@ -636,7 +636,7 @@ innobase_check_fk_option(
 /*************************************************************//**
 Set foreign key options
 @return true if successfully set */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 bool
 innobase_set_foreign_key_option(
 /*============================*/
@@ -681,7 +681,7 @@ innobase_set_foreign_key_option(
 Check if a foreign key constraint can make use of an index
 that is being created.
 @return	useable index, or NULL if none found */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 const KEY*
 innobase_find_equiv_index(
 /*======================*/
@@ -737,7 +737,7 @@ no_match:
 Find an index whose first fields are the columns in the array
 in the same order and is not marked for deletion
 @return matching index, NULL if not found */
-static __attribute__((nonnull(1,2,6), warn_unused_result))
+static MY_ATTRIBUTE((nonnull(1,2,6), warn_unused_result))
 dict_index_t*
 innobase_find_fk_index(
 /*===================*/
@@ -784,7 +784,7 @@ next_rec:
 Create InnoDB foreign key structure from MySQL alter_info
 @retval true if successful
 @retval false on error (will call my_error()) */
-static __attribute__((nonnull(1,2,3,7,8), warn_unused_result))
+static MY_ATTRIBUTE((nonnull(1,2,3,7,8), warn_unused_result))
 bool
 innobase_get_foreign_key_info(
 /*==========================*/
@@ -1269,7 +1269,7 @@ innobase_rec_reset(
 /*******************************************************************//**
 This function checks that index keys are sensible.
 @return	0 or error number */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 int
 innobase_check_index_keys(
 /*======================*/
@@ -1390,7 +1390,7 @@ name_ok:
 
 /*******************************************************************//**
 Create index field definition for key part */
-static __attribute__((nonnull(2,3)))
+static MY_ATTRIBUTE((nonnull(2,3)))
 void
 innobase_create_index_field_def(
 /*============================*/
@@ -1437,7 +1437,7 @@ innobase_create_index_field_def(
 
 /*******************************************************************//**
 Create index definition for key */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 void
 innobase_create_index_def(
 /*======================*/
@@ -1721,7 +1721,7 @@ ELSE
 ENDIF
 
 @return	key definitions */
-static __attribute__((nonnull, warn_unused_result, malloc))
+static MY_ATTRIBUTE((nonnull, warn_unused_result, malloc))
 index_def_t*
 innobase_create_key_defs(
 /*=====================*/
@@ -1940,7 +1940,7 @@ created_clustered:
 /*******************************************************************//**
 Check each index column size, make sure they do not exceed the max limit
 @return	true if index column size exceeds limit */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 bool
 innobase_check_column_length(
 /*=========================*/
@@ -2090,7 +2090,7 @@ online_retry_drop_indexes_low(
 /********************************************************************//**
 Drop any indexes that we were not able to free previously due to
 open table handles. */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 void
 online_retry_drop_indexes(
 /*======================*/
@@ -2120,7 +2120,7 @@ online_retry_drop_indexes(
 /********************************************************************//**
 Commit a dictionary transaction and drop any indexes that we were not
 able to free previously due to open table handles. */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 void
 online_retry_drop_indexes_with_trx(
 /*===============================*/
@@ -2149,7 +2149,7 @@ online_retry_drop_indexes_with_trx(
 @param drop_fk		constraints being dropped
 @param n_drop_fk	number of constraints that are being dropped
 @return whether the constraint is being dropped */
-inline __attribute__((pure, nonnull, warn_unused_result))
+inline MY_ATTRIBUTE((pure, nonnull, warn_unused_result))
 bool
 innobase_dropping_foreign(
 /*======================*/
@@ -2176,7 +2176,7 @@ column that is being dropped or modified to NOT NULL.
 @retval true		Not allowed (will call my_error())
 @retval false		Allowed
 */
-static __attribute__((pure, nonnull, warn_unused_result))
+static MY_ATTRIBUTE((pure, nonnull, warn_unused_result))
 bool
 innobase_check_foreigns_low(
 /*========================*/
@@ -2276,7 +2276,7 @@ column that is being dropped or modified to NOT NULL.
 @retval true		Not allowed (will call my_error())
 @retval false		Allowed
 */
-static __attribute__((pure, nonnull, warn_unused_result))
+static MY_ATTRIBUTE((pure, nonnull, warn_unused_result))
 bool
 innobase_check_foreigns(
 /*====================*/
@@ -2321,7 +2321,7 @@ innobase_check_foreigns(
 @param dfield	InnoDB data field to copy to
 @param field	MySQL value for the column
 @param comp	nonzero if in compact format */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 void
 innobase_build_col_map_add(
 /*=======================*/
@@ -2355,7 +2355,7 @@ adding columns.
 @param heap		Memory heap where allocated
 @return	array of integers, mapping column numbers in the table
 to column numbers in altered_table */
-static __attribute__((nonnull(1,2,3,4,5,7), warn_unused_result))
+static MY_ATTRIBUTE((nonnull(1,2,3,4,5,7), warn_unused_result))
 const ulint*
 innobase_build_col_map(
 /*===================*/
@@ -2492,7 +2492,7 @@ innobase_drop_fts_index_table(
 @param user_table	InnoDB table as it is before the ALTER operation
 @param heap		Memory heap for the allocation
 @return array of new column names in rebuilt_table, or NULL if not renamed */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 const char**
 innobase_get_col_names(
 	Alter_inplace_info*	ha_alter_info,
@@ -2555,7 +2555,7 @@ while preparing ALTER TABLE.
 @retval true		Failure
 @retval false		Success
 */
-static __attribute__((warn_unused_result, nonnull(1,2,3,4)))
+static MY_ATTRIBUTE((warn_unused_result, nonnull(1,2,3,4)))
 bool
 prepare_inplace_alter_table_dict(
 /*=============================*/
@@ -3193,7 +3193,7 @@ err_exit:
 /* Check whether an index is needed for the foreign key constraint.
 If so, if it is dropped, is there an equivalent index can play its role.
 @return true if the index is needed and can't be dropped */
-static __attribute__((nonnull(1,2,3,5), warn_unused_result))
+static MY_ATTRIBUTE((nonnull(1,2,3,5), warn_unused_result))
 bool
 innobase_check_foreign_key_index(
 /*=============================*/
@@ -4069,7 +4069,7 @@ temparary index prefix
 @param locked		TRUE=table locked, FALSE=may need to do a lazy drop
 @param trx		the transaction
 */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 void
 innobase_rollback_sec_index(
 /*========================*/
@@ -4103,7 +4103,7 @@ during prepare, but might not be during commit).
 @retval true		Failure
 @retval false		Success
 */
-inline __attribute__((nonnull, warn_unused_result))
+inline MY_ATTRIBUTE((nonnull, warn_unused_result))
 bool
 rollback_inplace_alter_table(
 /*=========================*/
@@ -4235,7 +4235,7 @@ func_exit:
 @param foreign_id	Foreign key constraint identifier
 @retval true		Failure
 @retval false		Success */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 bool
 innobase_drop_foreign_try(
 /*======================*/
@@ -4292,7 +4292,7 @@ innobase_drop_foreign_try(
 @param new_clustered	whether the table has been rebuilt
 @retval true		Failure
 @retval false		Success */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 bool
 innobase_rename_column_try(
 /*=======================*/
@@ -4501,7 +4501,7 @@ rename_foreign:
 @param table_name	Table name in MySQL
 @retval true		Failure
 @retval false		Success */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 bool
 innobase_rename_columns_try(
 /*========================*/
@@ -4551,7 +4551,7 @@ as part of commit_cache_norebuild().
 @param ha_alter_info	Data used during in-place alter.
 @param table		the TABLE
 @param user_table	InnoDB table that was being altered */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 void
 innobase_rename_columns_cache(
 /*==========================*/
@@ -4595,7 +4595,7 @@ processed_field:
 @param altered_table	MySQL table that is being altered
 @param old_table	MySQL table as it is before the ALTER operation
 @return the next auto-increment value (0 if not present) */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 ulonglong
 commit_get_autoinc(
 /*===============*/
@@ -4677,7 +4677,7 @@ but do not touch the data dictionary cache.
 @retval true		Failure
 @retval false		Success
 */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 bool
 innobase_update_foreign_try(
 /*========================*/
@@ -4760,7 +4760,7 @@ after the changes to data dictionary tables were committed.
 @param ctx	In-place ALTER TABLE context
 @param user_thd	MySQL connection
 @return		InnoDB error code (should always be DB_SUCCESS) */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 innobase_update_foreign_cache(
 /*==========================*/
@@ -4845,7 +4845,7 @@ when rebuilding the table.
 @retval true		Failure
 @retval false		Success
 */
-inline __attribute__((nonnull, warn_unused_result))
+inline MY_ATTRIBUTE((nonnull, warn_unused_result))
 bool
 commit_try_rebuild(
 /*===============*/
@@ -5007,7 +5007,7 @@ commit_try_rebuild(
 /** Apply the changes made during commit_try_rebuild(),
 to the data dictionary cache and the file system.
 @param ctx	In-place ALTER TABLE context */
-inline __attribute__((nonnull))
+inline MY_ATTRIBUTE((nonnull))
 void
 commit_cache_rebuild(
 /*=================*/
@@ -5102,7 +5102,7 @@ when not rebuilding the table.
 @retval true		Failure
 @retval false		Success
 */
-inline __attribute__((nonnull, warn_unused_result))
+inline MY_ATTRIBUTE((nonnull, warn_unused_result))
 bool
 commit_try_norebuild(
 /*=================*/
@@ -5212,7 +5212,7 @@ after a successful commit_try_norebuild() call.
 @param trx		Data dictionary transaction object
 (will be started and committed)
 @return whether all replacements were found for dropped indexes */
-inline __attribute__((nonnull, warn_unused_result))
+inline MY_ATTRIBUTE((nonnull, warn_unused_result))
 bool
 commit_cache_norebuild(
 /*===================*/
--- a/storage/innobase/ibuf/ibuf0ibuf.cc
+++ b/storage/innobase/ibuf/ibuf0ibuf.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1997, 2014, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1997, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -657,7 +657,7 @@ byte*
 ibuf_parse_bitmap_init(
 /*===================*/
 	byte*		ptr,	/*!< in: buffer */
-	byte*		end_ptr __attribute__((unused)), /*!< in: buffer end */
+	byte*		end_ptr MY_ATTRIBUTE((unused)), /*!< in: buffer end */
 	buf_block_t*	block,	/*!< in: block or NULL */
 	mtr_t*		mtr)	/*!< in: mtr or NULL */
 {
@@ -2494,7 +2494,7 @@ ibuf_get_merge_page_nos_func(
 /*******************************************************************//**
 Get the matching records for space id.
 @return	current rec or NULL */
-static	__attribute__((nonnull, warn_unused_result))
+static	MY_ATTRIBUTE((nonnull, warn_unused_result))
 const rec_t*
 ibuf_get_user_rec(
 /*===============*/
@@ -2516,7 +2516,7 @@ ibuf_get_user_rec(
 Reads page numbers for a space id from an ibuf tree.
 @return a lower limit for the combined volume of records which will be
 merged */
-static	__attribute__((nonnull, warn_unused_result))
+static	MY_ATTRIBUTE((nonnull, warn_unused_result))
 ulint
 ibuf_get_merge_pages(
 /*=================*/
@@ -2626,7 +2626,7 @@ ibuf_merge_pages(
 /*********************************************************************//**
 Get the table instance from the table id.
 @return table instance */
-static __attribute__((warn_unused_result))
+static MY_ATTRIBUTE((warn_unused_result))
 dict_table_t*
 ibuf_get_table(
 /*===========*/
@@ -2725,7 +2725,7 @@ Contracts insert buffer trees by reading pages to the buffer pool.
 @return a lower limit for the combined size in bytes of entries which
 will be merged from ibuf trees to the pages read, 0 if ibuf is
 empty */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 ulint
 ibuf_merge(
 /*=======*/
@@ -3444,7 +3444,7 @@ ibuf_get_entry_counter_func(
 Buffer an operation in the insert/delete buffer, instead of doing it
 directly to the disk page, if this is possible.
 @return	DB_SUCCESS, DB_STRONG_FAIL or other error */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 ibuf_insert_low(
 /*============*/
@@ -3935,7 +3935,7 @@ skip_watch:
 During merge, inserts to an index page a secondary index entry extracted
 from the insert buffer.
 @return	newly inserted record */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 rec_t*
 ibuf_insert_to_index_page_low(
 /*==========================*/
@@ -4366,7 +4366,7 @@ ibuf_delete(
 /*********************************************************************//**
 Restores insert buffer tree cursor position
 @return	TRUE if the position was restored; FALSE if not */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 ibool
 ibuf_restore_pos(
 /*=============*/
@@ -4421,7 +4421,7 @@ Deletes from ibuf the record on which pcur is positioned. If we have to
 resort to a pessimistic delete, this function commits mtr and closes
 the cursor.
 @return	TRUE if mtr was committed and pcur closed in this operation */
-static __attribute__((warn_unused_result))
+static MY_ATTRIBUTE((warn_unused_result))
 ibool
 ibuf_delete_rec(
 /*============*/
--- a/storage/innobase/include/api0api.h
+++ b/storage/innobase/include/api0api.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 2011, 2015, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 2011, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -36,7 +36,7 @@ InnoDB Native API
 #endif
 
 #if defined(__GNUC__) && (__GNUC__ > 2) && ! defined(__INTEL_COMPILER)
-#define UNIV_NO_IGNORE		__attribute__ ((warn_unused_result))
+#define UNIV_NO_IGNORE		MY_ATTRIBUTE ((warn_unused_result))
 #else
 #define UNIV_NO_IGNORE
 #endif /* __GNUC__ && __GNUC__ > 2 && !__INTEL_COMPILER */
--- a/storage/innobase/include/btr0btr.h
+++ b/storage/innobase/include/btr0btr.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1994, 2013, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1994, 2016, Oracle and/or its affiliates. All Rights Reserved.
 Copyright (c) 2012, Facebook Inc.
 
 This program is free software; you can redistribute it and/or modify it under
@@ -114,7 +114,7 @@ btr_corruption_report(
 /*==================*/
 	const buf_block_t*	block,	/*!< in: corrupted block */
 	const dict_index_t*	index)	/*!< in: index tree */
-	UNIV_COLD __attribute__((nonnull));
+	UNIV_COLD MY_ATTRIBUTE((nonnull));
 
 /** Assert that a B-tree page is not corrupted.
 @param block buffer block containing a B-tree page
@@ -156,7 +156,7 @@ btr_blob_dbg_add_blob(
 	ulint		page_no,	/*!< in: start page of the column */
 	dict_index_t*	index,		/*!< in/out: index tree */
 	const char*	ctx)		/*!< in: context (for logging) */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /**************************************************************//**
 Display the references to off-page columns.
 This function is to be called from a debugger,
@@ -166,7 +166,7 @@ void
 btr_blob_dbg_print(
 /*===============*/
 	const dict_index_t*	index)	/*!< in: index tree */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /**************************************************************//**
 Check that there are no references to off-page columns from or to
 the given page. Invoked when freeing or clearing a page.
@@ -177,7 +177,7 @@ btr_blob_dbg_is_empty(
 /*==================*/
 	dict_index_t*	index,		/*!< in: index */
 	ulint		page_no)	/*!< in: page number */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 /**************************************************************//**
 Modify the 'deleted' flag of a record. */
@@ -189,7 +189,7 @@ btr_blob_dbg_set_deleted_flag(
 	dict_index_t*		index,	/*!< in/out: index */
 	const ulint*		offsets,/*!< in: rec_get_offs(rec, index) */
 	ibool			del)	/*!< in: TRUE=deleted, FALSE=exists */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /**************************************************************//**
 Change the ownership of an off-page column. */
 UNIV_INTERN
@@ -201,7 +201,7 @@ btr_blob_dbg_owner(
 	const ulint*		offsets,/*!< in: rec_get_offs(rec, index) */
 	ulint			i,	/*!< in: ith field in rec */
 	ibool			own)	/*!< in: TRUE=owned, FALSE=disowned */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /** Assert that there are no BLOB references to or from the given page. */
 # define btr_blob_dbg_assert_empty(index, page_no)	\
 	ut_a(btr_blob_dbg_is_empty(index, page_no))
@@ -221,7 +221,7 @@ btr_root_get(
 /*=========*/
 	const dict_index_t*	index,	/*!< in: index tree */
 	mtr_t*			mtr)	/*!< in: mtr */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /**************************************************************//**
 Checks and adjusts the root node of a tree during IMPORT TABLESPACE.
@@ -231,7 +231,7 @@ dberr_t
 btr_root_adjust_on_import(
 /*======================*/
 	const dict_index_t*	index)	/*!< in: index tree */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 /**************************************************************//**
 Gets the height of the B-tree (the level of the root, when the leaf
@@ -244,7 +244,7 @@ btr_height_get(
 /*===========*/
 	dict_index_t*	index,	/*!< in: index tree */
 	mtr_t*		mtr)	/*!< in/out: mini-transaction */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /**************************************************************//**
 Gets a buffer page and declares its latching order level. */
 UNIV_INLINE
@@ -306,7 +306,7 @@ index_id_t
 btr_page_get_index_id(
 /*==================*/
 	const page_t*	page)	/*!< in: index page */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 #ifndef UNIV_HOTBACKUP
 /********************************************************//**
 Gets the node level field in an index page.
@@ -316,7 +316,7 @@ ulint
 btr_page_get_level_low(
 /*===================*/
 	const page_t*	page)	/*!< in: index page */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 #define btr_page_get_level(page, mtr) btr_page_get_level_low(page)
 /********************************************************//**
 Gets the next index page number.
@@ -327,7 +327,7 @@ btr_page_get_next(
 /*==============*/
 	const page_t*	page,	/*!< in: index page */
 	mtr_t*		mtr)	/*!< in: mini-transaction handle */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /********************************************************//**
 Gets the previous index page number.
 @return	prev page number */
@@ -337,7 +337,7 @@ btr_page_get_prev(
 /*==============*/
 	const page_t*	page,	/*!< in: index page */
 	mtr_t*		mtr)	/*!< in: mini-transaction handle */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*************************************************************//**
 Gets pointer to the previous user record in the tree. It is assumed
 that the caller has appropriate latches on the page and its neighbor.
@@ -349,7 +349,7 @@ btr_get_prev_user_rec(
 	rec_t*	rec,	/*!< in: record on leaf level */
 	mtr_t*	mtr)	/*!< in: mtr holding a latch on the page, and if
 			needed, also to the previous page */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*************************************************************//**
 Gets pointer to the next user record in the tree. It is assumed
 that the caller has appropriate latches on the page and its neighbor.
@@ -361,7 +361,7 @@ btr_get_next_user_rec(
 	rec_t*	rec,	/*!< in: record on leaf level */
 	mtr_t*	mtr)	/*!< in: mtr holding a latch on the page, and if
 			needed, also to the next page */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /**************************************************************//**
 Releases the latch on a leaf page and bufferunfixes it. */
 UNIV_INLINE
@@ -372,7 +372,7 @@ btr_leaf_page_release(
 	ulint		latch_mode,	/*!< in: BTR_SEARCH_LEAF or
 					BTR_MODIFY_LEAF */
 	mtr_t*		mtr)		/*!< in: mtr */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /**************************************************************//**
 Gets the child node file address in a node pointer.
 NOTE: the offsets array must contain all offsets for the record since
@@ -386,7 +386,7 @@ btr_node_ptr_get_child_page_no(
 /*===========================*/
 	const rec_t*	rec,	/*!< in: node pointer record */
 	const ulint*	offsets)/*!< in: array returned by rec_get_offsets() */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 /************************************************************//**
 Creates the root node for a new index tree.
 @return	page number of the created root, FIL_NULL if did not succeed */
@@ -401,7 +401,7 @@ btr_create(
 	index_id_t	index_id,/*!< in: index id */
 	dict_index_t*	index,	/*!< in: index */
 	mtr_t*		mtr)	/*!< in: mini-transaction handle */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /************************************************************//**
 Frees a B-tree except the root page, which MUST be freed after this
 by calling btr_free_root. */
@@ -424,7 +424,7 @@ btr_free_root(
 				or 0 for uncompressed pages */
 	ulint	root_page_no,	/*!< in: root page number */
 	mtr_t*	mtr)		/*!< in/out: mini-transaction */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*************************************************************//**
 Makes tree one level higher by splitting the root, and inserts
 the tuple. It is assumed that mtr contains an x-latch on the tree.
@@ -447,7 +447,7 @@ btr_root_raise_and_insert(
 	const dtuple_t*	tuple,	/*!< in: tuple to insert */
 	ulint		n_ext,	/*!< in: number of externally stored columns */
 	mtr_t*		mtr)	/*!< in: mtr */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*************************************************************//**
 Reorganizes an index page.
 
@@ -473,7 +473,7 @@ btr_page_reorganize_low(
 	page_cur_t*	cursor,	/*!< in/out: page cursor */
 	dict_index_t*	index,	/*!< in: the index tree of the page */
 	mtr_t*		mtr)	/*!< in/out: mini-transaction */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*************************************************************//**
 Reorganizes an index page.
 
@@ -492,7 +492,7 @@ btr_page_reorganize(
 	page_cur_t*	cursor,	/*!< in/out: page cursor */
 	dict_index_t*	index,	/*!< in: the index tree of the page */
 	mtr_t*		mtr)	/*!< in/out: mini-transaction */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*************************************************************//**
 Decides if the page should be split at the convergence point of
 inserts converging to left.
@@ -505,7 +505,7 @@ btr_page_get_split_rec_to_left(
 	rec_t**		split_rec)/*!< out: if split recommended,
 				the first record on upper half page,
 				or NULL if tuple should be first */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*************************************************************//**
 Decides if the page should be split at the convergence point of
 inserts converging to right.
@@ -518,7 +518,7 @@ btr_page_get_split_rec_to_right(
 	rec_t**		split_rec)/*!< out: if split recommended,
 				the first record on upper half page,
 				or NULL if tuple should be first */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*************************************************************//**
 Splits an index page to halves and inserts the tuple. It is assumed
 that mtr holds an x-latch to the index tree. NOTE: the tree x-latch is
@@ -542,7 +542,7 @@ btr_page_split_and_insert(
 	const dtuple_t*	tuple,	/*!< in: tuple to insert */
 	ulint		n_ext,	/*!< in: number of externally stored columns */
 	mtr_t*		mtr)	/*!< in: mtr */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*******************************************************//**
 Inserts a data tuple to a tree on a non-leaf level. It is assumed
 that mtr holds an x-latch on the tree. */
@@ -557,7 +557,7 @@ btr_insert_on_non_leaf_level_func(
 	const char*	file,	/*!< in: file name */
 	ulint		line,	/*!< in: line where called */
 	mtr_t*		mtr)	/*!< in: mtr */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 # define btr_insert_on_non_leaf_level(f,i,l,t,m)			\
 	btr_insert_on_non_leaf_level_func(f,i,l,t,__FILE__,__LINE__,m)
 #endif /* !UNIV_HOTBACKUP */
@@ -569,7 +569,7 @@ btr_set_min_rec_mark(
 /*=================*/
 	rec_t*	rec,	/*!< in/out: record */
 	mtr_t*	mtr)	/*!< in: mtr */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 #ifndef UNIV_HOTBACKUP
 /*************************************************************//**
 Deletes on the upper level the node pointer to a page. */
@@ -580,7 +580,7 @@ btr_node_ptr_delete(
 	dict_index_t*	index,	/*!< in: index tree */
 	buf_block_t*	block,	/*!< in: page whose node pointer is deleted */
 	mtr_t*		mtr)	/*!< in: mtr */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 #ifdef UNIV_DEBUG
 /************************************************************//**
 Checks that the node pointer to a page is appropriate.
@@ -592,7 +592,7 @@ btr_check_node_ptr(
 	dict_index_t*	index,	/*!< in: index tree */
 	buf_block_t*	block,	/*!< in: index page */
 	mtr_t*		mtr)	/*!< in: mtr */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 #endif /* UNIV_DEBUG */
 /*************************************************************//**
 Tries to merge the page first to the left immediate brother if such a
@@ -615,7 +615,7 @@ btr_compress(
 	ibool		adjust,	/*!< in: TRUE if should adjust the
 				cursor position even if compression occurs */
 	mtr_t*		mtr)	/*!< in/out: mini-transaction */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*************************************************************//**
 Discards a page from a B-tree. This is used to remove the last record from
 a B-tree page: the whole page must be removed at the same time. This cannot
@@ -627,7 +627,7 @@ btr_discard_page(
 	btr_cur_t*	cursor,	/*!< in: cursor on the page to discard: not on
 				the root page */
 	mtr_t*		mtr)	/*!< in: mtr */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 #endif /* !UNIV_HOTBACKUP */
 /****************************************************************//**
 Parses the redo log record for setting an index record as the predefined
@@ -642,7 +642,7 @@ btr_parse_set_min_rec_mark(
 	ulint	comp,	/*!< in: nonzero=compact page format */
 	page_t*	page,	/*!< in: page or NULL */
 	mtr_t*	mtr)	/*!< in: mtr or NULL */
-	__attribute__((nonnull(1,2), warn_unused_result));
+	MY_ATTRIBUTE((nonnull(1,2), warn_unused_result));
 /***********************************************************//**
 Parses a redo log record of reorganizing a page.
 @return	end of log record or NULL */
@@ -656,7 +656,7 @@ btr_parse_page_reorganize(
 	bool		compressed,/*!< in: true if compressed page */
 	buf_block_t*	block,	/*!< in: page to be reorganized, or NULL */
 	mtr_t*		mtr)	/*!< in: mtr or NULL */
-	__attribute__((nonnull(1,2,3), warn_unused_result));
+	MY_ATTRIBUTE((nonnull(1,2,3), warn_unused_result));
 #ifndef UNIV_HOTBACKUP
 /**************************************************************//**
 Gets the number of pages in a B-tree.
@@ -669,7 +669,7 @@ btr_get_size(
 	ulint		flag,	/*!< in: BTR_N_LEAF_PAGES or BTR_TOTAL_SIZE */
 	mtr_t*		mtr)	/*!< in/out: mini-transaction where index
 				is s-latched */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /**************************************************************//**
 Allocates a new file page to be used in an index tree. NOTE: we assume
 that the caller has made the reservation for free extents!
@@ -692,7 +692,7 @@ btr_page_alloc(
 	mtr_t*		init_mtr)	/*!< in/out: mini-transaction
 					for x-latching and initializing
 					the page */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /**************************************************************//**
 Frees a file page used in an index tree. NOTE: cannot free field external
 storage pages because the page must contain info on its level. */
@@ -703,7 +703,7 @@ btr_page_free(
 	dict_index_t*	index,	/*!< in: index tree */
 	buf_block_t*	block,	/*!< in: block to be freed, x-latched */
 	mtr_t*		mtr)	/*!< in: mtr */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /**************************************************************//**
 Frees a file page used in an index tree. Can be used also to BLOB
 external storage pages, because the page level 0 can be given as an
@@ -716,7 +716,7 @@ btr_page_free_low(
 	buf_block_t*	block,	/*!< in: block to be freed, x-latched */
 	ulint		level,	/*!< in: page level */
 	mtr_t*		mtr)	/*!< in: mtr */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 #ifdef UNIV_BTR_PRINT
 /*************************************************************//**
 Prints size info of a B-tree. */
@@ -725,7 +725,7 @@ void
 btr_print_size(
 /*===========*/
 	dict_index_t*	index)	/*!< in: index tree */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /**************************************************************//**
 Prints directories and other info of all nodes in the index. */
 UNIV_INTERN
@@ -735,7 +735,7 @@ btr_print_index(
 	dict_index_t*	index,	/*!< in: index */
 	ulint		width)	/*!< in: print this many entries from start
 				and end */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 #endif /* UNIV_BTR_PRINT */
 /************************************************************//**
 Checks the size and number of fields in a record based on the definition of
@@ -750,7 +750,7 @@ btr_index_rec_validate(
 	ibool			dump_on_error)	/*!< in: TRUE if the function
 						should print hex dump of record
 						and page on error */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /**************************************************************//**
 Checks the consistency of an index tree.
 @return	TRUE if ok */
@@ -760,7 +760,7 @@ btr_validate_index(
 /*===============*/
 	dict_index_t*	index,			/*!< in: index */
 	const trx_t*	trx)			/*!< in: transaction or 0 */
-	__attribute__((nonnull(1), warn_unused_result));
+	MY_ATTRIBUTE((nonnull(1), warn_unused_result));
 
 #define BTR_N_LEAF_PAGES	1
 #define BTR_TOTAL_SIZE		2
--- a/storage/innobase/include/btr0btr.ic
+++ b/storage/innobase/include/btr0btr.ic
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1994, 2012, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1994, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -159,7 +159,7 @@ ulint
 btr_page_get_next(
 /*==============*/
 	const page_t*	page,	/*!< in: index page */
-	mtr_t*		mtr __attribute__((unused)))
+	mtr_t*		mtr MY_ATTRIBUTE((unused)))
 				/*!< in: mini-transaction handle */
 {
 	ut_ad(page && mtr);
@@ -199,7 +199,7 @@ ulint
 btr_page_get_prev(
 /*==============*/
 	const page_t*	page,	/*!< in: index page */
-	mtr_t*	mtr __attribute__((unused))) /*!< in: mini-transaction handle */
+	mtr_t*	mtr MY_ATTRIBUTE((unused))) /*!< in: mini-transaction handle */
 {
 	ut_ad(page && mtr);
 
--- a/storage/innobase/include/btr0cur.h
+++ b/storage/innobase/include/btr0cur.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1994, 2014, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1994, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -186,7 +186,7 @@ btr_cur_open_at_index_side_func(
 	const char*	file,		/*!< in: file name */
 	ulint		line,		/*!< in: line where called */
 	mtr_t*		mtr)		/*!< in/out: mini-transaction */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 #define btr_cur_open_at_index_side(f,i,l,c,lv,m)			\
 	btr_cur_open_at_index_side_func(f,i,l,c,lv,__FILE__,__LINE__,m)
 /**********************************************************************//**
@@ -235,7 +235,7 @@ btr_cur_optimistic_insert(
 				compressed tablespace, the caller must
 				mtr_commit(mtr) before latching
 				any further pages */
-	__attribute__((nonnull(2,3,4,5,6,7,10), warn_unused_result));
+	MY_ATTRIBUTE((nonnull(2,3,4,5,6,7,10), warn_unused_result));
 /*************************************************************//**
 Performs an insert on a page of an index tree. It is assumed that mtr
 holds an x-latch on the tree and on the cursor page. If the insert is
@@ -266,7 +266,7 @@ btr_cur_pessimistic_insert(
 	ulint		n_ext,	/*!< in: number of externally stored columns */
 	que_thr_t*	thr,	/*!< in: query thread or NULL */
 	mtr_t*		mtr)	/*!< in/out: mini-transaction */
-	__attribute__((nonnull(2,3,4,5,6,7,10), warn_unused_result));
+	MY_ATTRIBUTE((nonnull(2,3,4,5,6,7,10), warn_unused_result));
 /*************************************************************//**
 See if there is enough place in the page modification log to log
 an update-in-place.
@@ -293,7 +293,7 @@ btr_cur_update_alloc_zip_func(
 	bool		create,	/*!< in: true=delete-and-insert,
 				false=update-in-place */
 	mtr_t*		mtr)	/*!< in/out: mini-transaction */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 #ifdef UNIV_DEBUG
 # define btr_cur_update_alloc_zip(page_zip,cursor,index,offsets,len,cr,mtr) \
 	btr_cur_update_alloc_zip_func(page_zip,cursor,index,offsets,len,cr,mtr)
@@ -325,7 +325,7 @@ btr_cur_update_in_place(
 				is a secondary index, the caller must
 				mtr_commit(mtr) before latching any
 				further pages */
-	__attribute__((warn_unused_result, nonnull));
+	MY_ATTRIBUTE((warn_unused_result, nonnull));
 /***********************************************************//**
 Writes a redo log record of updating a record in-place. */
 UNIV_INTERN
@@ -339,7 +339,7 @@ btr_cur_update_in_place_log(
 	trx_id_t	trx_id,		/*!< in: transaction id */
 	roll_ptr_t	roll_ptr,	/*!< in: roll ptr */
 	mtr_t*		mtr)		/*!< in: mtr */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*************************************************************//**
 Tries to update a record on a page in an index tree. It is assumed that mtr
 holds an x-latch on the page. The operation does not succeed if there is too
@@ -371,7 +371,7 @@ btr_cur_optimistic_update(
 				is a secondary index, the caller must
 				mtr_commit(mtr) before latching any
 				further pages */
-	__attribute__((warn_unused_result, nonnull));
+	MY_ATTRIBUTE((warn_unused_result, nonnull));
 /*************************************************************//**
 Performs an update of a record on a page of a tree. It is assumed
 that mtr holds an x-latch on the tree and on the cursor page. If the
@@ -405,7 +405,7 @@ btr_cur_pessimistic_update(
 	trx_id_t	trx_id,	/*!< in: transaction id */
 	mtr_t*		mtr)	/*!< in/out: mini-transaction; must be committed
 				before latching any further pages */
-	__attribute__((warn_unused_result, nonnull));
+	MY_ATTRIBUTE((warn_unused_result, nonnull));
 /***********************************************************//**
 Marks a clustered index record deleted. Writes an undo log record to
 undo log on this delete marking. Writes in the trx id field the id
@@ -422,7 +422,7 @@ btr_cur_del_mark_set_clust_rec(
 	const ulint*	offsets,/*!< in: rec_get_offsets(rec) */
 	que_thr_t*	thr,	/*!< in: query thread */
 	mtr_t*		mtr)	/*!< in/out: mini-transaction */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /***********************************************************//**
 Sets a secondary index record delete mark to TRUE or FALSE.
 @return	DB_SUCCESS, DB_LOCK_WAIT, or error number */
@@ -435,7 +435,7 @@ btr_cur_del_mark_set_sec_rec(
 	ibool		val,	/*!< in: value to set */
 	que_thr_t*	thr,	/*!< in: query thread */
 	mtr_t*		mtr)	/*!< in/out: mini-transaction */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*************************************************************//**
 Tries to compress a page of the tree if it seems useful. It is assumed
 that mtr holds an x-latch on the tree and on the cursor page. To avoid
@@ -453,7 +453,7 @@ btr_cur_compress_if_useful(
 	ibool		adjust,	/*!< in: TRUE if should adjust the
 				cursor position even if compression occurs */
 	mtr_t*		mtr)	/*!< in/out: mini-transaction */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*******************************************************//**
 Removes the record on which the tree cursor is positioned. It is assumed
 that the mtr has an x-latch on the page where the cursor is positioned,
@@ -474,7 +474,7 @@ btr_cur_optimistic_delete_func(
 				TRUE on a leaf page of a secondary
 				index, the mtr must be committed
 				before latching any further pages */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 # ifdef UNIV_DEBUG
 #  define btr_cur_optimistic_delete(cursor, flags, mtr)		\
 	btr_cur_optimistic_delete_func(cursor, flags, mtr)
@@ -510,7 +510,7 @@ btr_cur_pessimistic_delete(
 	ulint		flags,	/*!< in: BTR_CREATE_FLAG or 0 */
 	enum trx_rb_ctx	rb_ctx,	/*!< in: rollback context */
 	mtr_t*		mtr)	/*!< in: mtr */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 #endif /* !UNIV_HOTBACKUP */
 /***********************************************************//**
 Parses a redo log record of updating a record in-place.
@@ -603,7 +603,7 @@ btr_cur_disown_inherited_fields(
 	const ulint*	offsets,/*!< in: array returned by rec_get_offsets() */
 	const upd_t*	update,	/*!< in: update vector */
 	mtr_t*		mtr)	/*!< in/out: mini-transaction */
-	__attribute__((nonnull(2,3,4,5,6)));
+	MY_ATTRIBUTE((nonnull(2,3,4,5,6)));
 
 /** Operation code for btr_store_big_rec_extern_fields(). */
 enum blob_op {
@@ -623,7 +623,7 @@ ibool
 btr_blob_op_is_update(
 /*==================*/
 	enum blob_op	op)	/*!< in: operation */
-	__attribute__((warn_unused_result));
+	MY_ATTRIBUTE((warn_unused_result));
 
 /*******************************************************************//**
 Stores the fields in big_rec_vec to the tablespace and puts pointers to
@@ -648,7 +648,7 @@ btr_store_big_rec_extern_fields(
 	mtr_t*		btr_mtr,	/*!< in: mtr containing the
 					latches to the clustered index */
 	enum blob_op	op)		/*! in: operation code */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 /*******************************************************************//**
 Frees the space in an externally stored field to the file space
@@ -742,7 +742,7 @@ btr_push_update_extern_fields(
 	dtuple_t*	tuple,	/*!< in/out: data tuple */
 	const upd_t*	update,	/*!< in: update vector */
 	mem_heap_t*	heap)	/*!< in: memory heap */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /***********************************************************//**
 Sets a secondary index record's delete mark to the given value. This
 function is only used by the insert buffer merge mechanism. */
--- a/storage/innobase/include/btr0pcur.h
+++ b/storage/innobase/include/btr0pcur.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1996, 2013, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1996, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -155,7 +155,7 @@ btr_pcur_open_at_index_side(
 	ulint		level,		/*!< in: level to search for
 					(0=leaf) */
 	mtr_t*		mtr)		/*!< in/out: mini-transaction */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /**************************************************************//**
 Gets the up_match value for a pcur after a search.
 @return number of matched fields at the cursor or to the right if
--- a/storage/innobase/include/btr0sea.h
+++ b/storage/innobase/include/btr0sea.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1996, 2011, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1996, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -69,7 +69,7 @@ btr_search_t*
 btr_search_get_info(
 /*================*/
 	dict_index_t*	index)	/*!< in: index */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*****************************************************************//**
 Creates and initializes a search info struct.
 @return	own: search info struct */
--- a/storage/innobase/include/btr0types.h
+++ b/storage/innobase/include/btr0types.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1996, 2011, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1996, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -81,7 +81,7 @@ btr_blob_dbg_rbt_insert(
 	dict_index_t*		index,	/*!< in/out: index tree */
 	const btr_blob_dbg_t*	b,	/*!< in: the reference */
 	const char*		ctx)	/*!< in: context (for logging) */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /** Remove from index->blobs a reference to an off-page column.
 @param index	the index tree
@@ -94,7 +94,7 @@ btr_blob_dbg_rbt_delete(
 	dict_index_t*		index,	/*!< in/out: index tree */
 	const btr_blob_dbg_t*	b,	/*!< in: the reference */
 	const char*		ctx)	/*!< in: context (for logging) */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /**************************************************************//**
 Add to index->blobs any references to off-page columns from a record.
@@ -107,7 +107,7 @@ btr_blob_dbg_add_rec(
 	dict_index_t*	index,	/*!< in/out: index */
 	const ulint*	offsets,/*!< in: offsets */
 	const char*	ctx)	/*!< in: context (for logging) */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /**************************************************************//**
 Remove from index->blobs any references to off-page columns from a record.
 @return number of references removed */
@@ -119,7 +119,7 @@ btr_blob_dbg_remove_rec(
 	dict_index_t*	index,	/*!< in/out: index */
 	const ulint*	offsets,/*!< in: offsets */
 	const char*	ctx)	/*!< in: context (for logging) */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /**************************************************************//**
 Count and add to index->blobs any references to off-page columns
 from records on a page.
@@ -131,7 +131,7 @@ btr_blob_dbg_add(
 	const page_t*	page,	/*!< in: rewritten page */
 	dict_index_t*	index,	/*!< in/out: index */
 	const char*	ctx)	/*!< in: context (for logging) */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /**************************************************************//**
 Count and remove from index->blobs any references to off-page columns
 from records on a page.
@@ -144,7 +144,7 @@ btr_blob_dbg_remove(
 	const page_t*	page,	/*!< in: b-tree page */
 	dict_index_t*	index,	/*!< in/out: index */
 	const char*	ctx)	/*!< in: context (for logging) */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /**************************************************************//**
 Restore in index->blobs any references to off-page columns
 Used when page reorganize fails due to compressed page overflow. */
@@ -156,7 +156,7 @@ btr_blob_dbg_restore(
 	const page_t*	page,	/*!< in: copy of original page */
 	dict_index_t*	index,	/*!< in/out: index */
 	const char*	ctx)	/*!< in: context (for logging) */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /** Operation that processes the BLOB references of an index record
 @param[in]	rec	record on index page
@@ -180,7 +180,7 @@ btr_blob_dbg_op(
 	dict_index_t*		index,	/*!< in/out: index */
 	const char*		ctx,	/*!< in: context (for logging) */
 	const btr_blob_dbg_op_f	op)	/*!< in: operation on records */
-	__attribute__((nonnull(1,3,4,5)));
+	MY_ATTRIBUTE((nonnull(1,3,4,5)));
 #else /* UNIV_BLOB_DEBUG */
 # define btr_blob_dbg_add_rec(rec, index, offsets, ctx)		((void) 0)
 # define btr_blob_dbg_add(page, index, ctx)			((void) 0)
--- a/storage/innobase/include/buf0buddy.h
+++ b/storage/innobase/include/buf0buddy.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 2006, 2011, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 2006, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -54,7 +54,7 @@ buf_buddy_alloc(
 				       	storage was allocated from the
 				       	LRU list and buf_pool->mutex was
 				       	temporarily released */
-	__attribute__((malloc, nonnull));
+	MY_ATTRIBUTE((malloc, nonnull));
 
 /**********************************************************************//**
 Deallocate a block. */
@@ -68,7 +68,7 @@ buf_buddy_free(
 					be pointed to by the buffer pool */
 	ulint		size)		/*!< in: block size,
 					up to UNIV_PAGE_SIZE */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 #ifndef UNIV_NONINL
 # include "buf0buddy.ic"
--- a/storage/innobase/include/buf0buddy.ic
+++ b/storage/innobase/include/buf0buddy.ic
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 2006, 2011, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 2006, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -50,7 +50,7 @@ buf_buddy_alloc_low(
 					allocated from the LRU list and
 					buf_pool->mutex was temporarily
 					released */
-	__attribute__((malloc, nonnull));
+	MY_ATTRIBUTE((malloc, nonnull));
 
 /**********************************************************************//**
 Deallocate a block. */
@@ -63,7 +63,7 @@ buf_buddy_free_low(
 					pointed to by the buffer pool */
 	ulint		i)		/*!< in: index of buf_pool->zip_free[],
 					or BUF_BUDDY_SIZES */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /**********************************************************************//**
 Get the index of buf_pool->zip_free[] for a given block size.
--- a/storage/innobase/include/buf0buf.h
+++ b/storage/innobase/include/buf0buf.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1995, 2014, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1995, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -258,7 +258,7 @@ buf_relocate(
 				buf_page_get_state(bpage) must be
 				BUF_BLOCK_ZIP_DIRTY or BUF_BLOCK_ZIP_PAGE */
 	buf_page_t*	dpage)	/*!< in/out: destination control block */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*********************************************************************//**
 Gets the current size of buffer buf_pool in bytes.
 @return	size in bytes */
@@ -289,7 +289,7 @@ UNIV_INLINE
 buf_page_t*
 buf_page_alloc_descriptor(void)
 /*===========================*/
-	__attribute__((malloc));
+	MY_ATTRIBUTE((malloc));
 /********************************************************************//**
 Free a buf_page_t descriptor. */
 UNIV_INLINE
@@ -297,7 +297,7 @@ void
 buf_page_free_descriptor(
 /*=====================*/
 	buf_page_t*	bpage)	/*!< in: bpage descriptor to free. */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /********************************************************************//**
 Allocates a buffer block.
@@ -534,7 +534,7 @@ ulint
 buf_page_get_freed_page_clock(
 /*==========================*/
 	const buf_page_t*	bpage)	/*!< in: block */
-	__attribute__((pure));
+	MY_ATTRIBUTE((pure));
 /********************************************************************//**
 Reads the freed_page_clock of a buffer block.
 @return	freed_page_clock */
@@ -543,7 +543,7 @@ ulint
 buf_block_get_freed_page_clock(
 /*===========================*/
 	const buf_block_t*	block)	/*!< in: block */
-	__attribute__((pure));
+	MY_ATTRIBUTE((pure));
 
 /********************************************************************//**
 Tells if a block is still close enough to the MRU end of the LRU list
@@ -606,7 +606,7 @@ buf_block_buf_fix_inc_func(
 	ulint		line,	/*!< in: line */
 # endif /* UNIV_SYNC_DEBUG */
 	buf_block_t*	block)	/*!< in/out: block to bufferfix */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /*******************************************************************//**
 Increments the bufferfix count. */
@@ -652,7 +652,7 @@ buf_page_is_corrupted(
 	const byte*	read_buf,	/*!< in: a database page */
 	ulint		zip_size)	/*!< in: size of compressed page;
 					0 for uncompressed pages */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /********************************************************************//**
 Checks if a page is all zeroes.
 @return	TRUE if the page is all zeroes */
@@ -682,7 +682,7 @@ ulint
 buf_block_get_lock_hash_val(
 /*========================*/
 	const buf_block_t*	block)	/*!< in: block */
-	__attribute__((pure));
+	MY_ATTRIBUTE((pure));
 #ifdef UNIV_DEBUG
 /*********************************************************************//**
 Finds a block in the buffer pool that points to a
@@ -743,7 +743,7 @@ buf_page_print(
 	ulint		flags)		/*!< in: 0 or
 					BUF_PAGE_PRINT_NO_CRASH or
 					BUF_PAGE_PRINT_NO_FULL */
-	UNIV_COLD __attribute__((nonnull));
+	UNIV_COLD MY_ATTRIBUTE((nonnull));
 /********************************************************************//**
 Decompress a block.
 @return	TRUE if successful */
@@ -870,7 +870,7 @@ enum buf_page_state
 buf_block_get_state(
 /*================*/
 	const buf_block_t*	block)	/*!< in: pointer to the control block */
-	__attribute__((pure));
+	MY_ATTRIBUTE((pure));
 /*********************************************************************//**
 Sets the state of a block. */
 UNIV_INLINE
@@ -895,7 +895,7 @@ ibool
 buf_page_in_file(
 /*=============*/
 	const buf_page_t*	bpage)	/*!< in: pointer to control block */
-	__attribute__((pure));
+	MY_ATTRIBUTE((pure));
 #ifndef UNIV_HOTBACKUP
 /*********************************************************************//**
 Determines if a block should be on unzip_LRU list.
@@ -905,7 +905,7 @@ ibool
 buf_page_belongs_to_unzip_LRU(
 /*==========================*/
 	const buf_page_t*	bpage)	/*!< in: pointer to control block */
-	__attribute__((pure));
+	MY_ATTRIBUTE((pure));
 
 /*********************************************************************//**
 Gets the mutex of a block.
@@ -915,7 +915,7 @@ ib_mutex_t*
 buf_page_get_mutex(
 /*===============*/
 	const buf_page_t*	bpage)	/*!< in: pointer to control block */
-	__attribute__((pure));
+	MY_ATTRIBUTE((pure));
 
 /*********************************************************************//**
 Get the flush type of a page.
@@ -925,7 +925,7 @@ buf_flush_t
 buf_page_get_flush_type(
 /*====================*/
 	const buf_page_t*	bpage)	/*!< in: buffer page */
-	__attribute__((pure));
+	MY_ATTRIBUTE((pure));
 /*********************************************************************//**
 Set the flush type of a page. */
 UNIV_INLINE
@@ -951,7 +951,7 @@ enum buf_io_fix
 buf_page_get_io_fix(
 /*================*/
 	const buf_page_t*	bpage)	/*!< in: pointer to the control block */
-	__attribute__((pure));
+	MY_ATTRIBUTE((pure));
 /*********************************************************************//**
 Gets the io_fix state of a block.
 @return	io_fix state */
@@ -960,7 +960,7 @@ enum buf_io_fix
 buf_block_get_io_fix(
 /*================*/
 	const buf_block_t*	block)	/*!< in: pointer to the control block */
-	__attribute__((pure));
+	MY_ATTRIBUTE((pure));
 /*********************************************************************//**
 Sets the io_fix state of a block. */
 UNIV_INLINE
@@ -1006,7 +1006,7 @@ ibool
 buf_page_can_relocate(
 /*==================*/
 	const buf_page_t*	bpage)	/*!< control block being relocated */
-	__attribute__((pure));
+	MY_ATTRIBUTE((pure));
 
 /*********************************************************************//**
 Determine if a block has been flagged old.
@@ -1016,7 +1016,7 @@ ibool
 buf_page_is_old(
 /*============*/
 	const buf_page_t*	bpage)	/*!< in: control block */
-	__attribute__((pure));
+	MY_ATTRIBUTE((pure));
 /*********************************************************************//**
 Flag a block old. */
 UNIV_INLINE
@@ -1033,7 +1033,7 @@ unsigned
 buf_page_is_accessed(
 /*=================*/
 	const buf_page_t*	bpage)	/*!< in: control block */
-	__attribute__((nonnull, pure));
+	MY_ATTRIBUTE((nonnull, pure));
 /*********************************************************************//**
 Flag a block accessed. */
 UNIV_INLINE
@@ -1041,7 +1041,7 @@ void
 buf_page_set_accessed(
 /*==================*/
 	buf_page_t*	bpage)		/*!< in/out: control block */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*********************************************************************//**
 Gets the buf_block_t handle of a buffered file block if an uncompressed
 page frame exists, or NULL. Note: even though bpage is not declared a
@@ -1052,7 +1052,7 @@ buf_block_t*
 buf_page_get_block(
 /*===============*/
 	buf_page_t*	bpage)	/*!< in: control block, or NULL */
-	__attribute__((pure));
+	MY_ATTRIBUTE((pure));
 #endif /* !UNIV_HOTBACKUP */
 #ifdef UNIV_DEBUG
 /*********************************************************************//**
@@ -1063,7 +1063,7 @@ buf_frame_t*
 buf_block_get_frame(
 /*================*/
 	const buf_block_t*	block)	/*!< in: pointer to the control block */
-	__attribute__((pure));
+	MY_ATTRIBUTE((pure));
 #else /* UNIV_DEBUG */
 # define buf_block_get_frame(block) (block)->frame
 #endif /* UNIV_DEBUG */
@@ -1075,7 +1075,7 @@ ulint
 buf_page_get_space(
 /*===============*/
 	const buf_page_t*	bpage)	/*!< in: pointer to the control block */
-	__attribute__((pure));
+	MY_ATTRIBUTE((pure));
 /*********************************************************************//**
 Gets the space id of a block.
 @return	space id */
@@ -1084,7 +1084,7 @@ ulint
 buf_block_get_space(
 /*================*/
 	const buf_block_t*	block)	/*!< in: pointer to the control block */
-	__attribute__((pure));
+	MY_ATTRIBUTE((pure));
 /*********************************************************************//**
 Gets the page number of a block.
 @return	page number */
@@ -1093,7 +1093,7 @@ ulint
 buf_page_get_page_no(
 /*=================*/
 	const buf_page_t*	bpage)	/*!< in: pointer to the control block */
-	__attribute__((pure));
+	MY_ATTRIBUTE((pure));
 /*********************************************************************//**
 Gets the page number of a block.
 @return	page number */
@@ -1102,7 +1102,7 @@ ulint
 buf_block_get_page_no(
 /*==================*/
 	const buf_block_t*	block)	/*!< in: pointer to the control block */
-	__attribute__((pure));
+	MY_ATTRIBUTE((pure));
 /*********************************************************************//**
 Gets the compressed page size of a block.
 @return	compressed page size, or 0 */
@@ -1111,7 +1111,7 @@ ulint
 buf_page_get_zip_size(
 /*==================*/
 	const buf_page_t*	bpage)	/*!< in: pointer to the control block */
-	__attribute__((pure));
+	MY_ATTRIBUTE((pure));
 /*********************************************************************//**
 Gets the compressed page size of a block.
 @return	compressed page size, or 0 */
@@ -1120,7 +1120,7 @@ ulint
 buf_block_get_zip_size(
 /*===================*/
 	const buf_block_t*	block)	/*!< in: pointer to the control block */
-	__attribute__((pure));
+	MY_ATTRIBUTE((pure));
 /*********************************************************************//**
 Gets the compressed page descriptor corresponding to an uncompressed page
 if applicable. */
@@ -1209,7 +1209,7 @@ buf_page_address_fold(
 /*==================*/
 	ulint	space,	/*!< in: space id */
 	ulint	offset)	/*!< in: offset of the page within space */
-	__attribute__((const));
+	MY_ATTRIBUTE((const));
 /********************************************************************//**
 Calculates the index of a buffer pool to the buf_pool[] array.
 @return	the position of the buffer pool in buf_pool[] */
@@ -1218,7 +1218,7 @@ ulint
 buf_pool_index(
 /*===========*/
 	const buf_pool_t*	buf_pool)	/*!< in: buffer pool */
-	__attribute__((nonnull, const));
+	MY_ATTRIBUTE((nonnull, const));
 /******************************************************************//**
 Returns the buffer pool instance given a page instance
 @return buf_pool */
@@ -1358,7 +1358,7 @@ buf_pool_watch_is_sentinel(
 /*=======================*/
 	buf_pool_t*		buf_pool,	/*!< buffer pool instance */
 	const buf_page_t*	bpage)		/*!< in: block */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /****************************************************************//**
 Add watch for the given page to be read in. Caller must have the buffer pool
 @return NULL if watch set, block if the page is in the buffer pool */
@@ -1369,7 +1369,7 @@ buf_pool_watch_set(
 	ulint	space,	/*!< in: space id */
 	ulint	offset,	/*!< in: page number */
 	ulint	fold)	/*!< in: buf_page_address_fold(space, offset) */
-	__attribute__((warn_unused_result));
+	MY_ATTRIBUTE((warn_unused_result));
 /****************************************************************//**
 Stop watching if the page has been read in.
 buf_pool_watch_set(space,offset) must have returned NULL before. */
@@ -1390,7 +1390,7 @@ buf_pool_watch_occurred(
 /*====================*/
 	ulint	space,	/*!< in: space id */
 	ulint	offset)	/*!< in: page number */
-	__attribute__((warn_unused_result));
+	MY_ATTRIBUTE((warn_unused_result));
 /********************************************************************//**
 Get total buffer pool statistics. */
 UNIV_INTERN
--- a/storage/innobase/include/buf0flu.h
+++ b/storage/innobase/include/buf0flu.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1995, 2013, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1995, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -85,7 +85,7 @@ buf_flush_page_try(
 /*===============*/
 	buf_pool_t*	buf_pool,	/*!< in/out: buffer pool instance */
 	buf_block_t*	block)		/*!< in/out: buffer control block */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 # endif /* UNIV_DEBUG || UNIV_IBUF_DEBUG */
 /*******************************************************************//**
 This utility flushes dirty blocks from the end of the flush list of
@@ -254,7 +254,7 @@ buf_flush_ready_for_flush(
 	buf_page_t*	bpage,	/*!< in: buffer control block, must be
 				buf_page_in_file(bpage) */
 	buf_flush_t	flush_type)/*!< in: type of flush */
-	__attribute__((warn_unused_result));
+	MY_ATTRIBUTE((warn_unused_result));
 
 #ifdef UNIV_DEBUG
 /******************************************************************//**
--- a/storage/innobase/include/buf0lru.h
+++ b/storage/innobase/include/buf0lru.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1995, 2013, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1995, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -93,7 +93,7 @@ buf_LRU_free_page(
 	buf_page_t*	bpage,	/*!< in: block to be freed */
 	bool		zip)	/*!< in: true if should remove also the
 				compressed page of an uncompressed page */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /******************************************************************//**
 Try to free a replaceable block.
 @return	TRUE if found and freed */
@@ -105,7 +105,7 @@ buf_LRU_scan_and_free_block(
 	ibool		scan_all)	/*!< in: scan whole LRU list
 					if TRUE, otherwise scan only
 					'old' blocks. */
-	__attribute__((nonnull,warn_unused_result));
+	MY_ATTRIBUTE((nonnull,warn_unused_result));
 /******************************************************************//**
 Returns a free block from the buf_pool.  The block is taken off the
 free list.  If it is empty, returns NULL.
@@ -146,7 +146,7 @@ buf_block_t*
 buf_LRU_get_free_block(
 /*===================*/
 	buf_pool_t*	buf_pool)	/*!< in/out: buffer pool instance */
-	__attribute__((nonnull,warn_unused_result));
+	MY_ATTRIBUTE((nonnull,warn_unused_result));
 /******************************************************************//**
 Determines if the unzip_LRU list should be used for evicting a victim
 instead of the general LRU list.
@@ -229,7 +229,7 @@ buf_LRU_free_one_page(
 	buf_page_t*	bpage)	/*!< in/out: block, must contain a file page and
 				be in a state where it can be freed; there
 				may or may not be a hash index to the page */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 #if defined UNIV_DEBUG || defined UNIV_BUF_DEBUG
 /**********************************************************************//**
--- a/storage/innobase/include/data0data.h
+++ b/storage/innobase/include/data0data.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1994, 2012, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1994, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -46,7 +46,7 @@ dtype_t*
 dfield_get_type(
 /*============*/
 	const dfield_t*	field)	/*!< in: SQL data field */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*********************************************************************//**
 Gets pointer to the data in a field.
 @return	pointer to data */
@@ -55,7 +55,7 @@ void*
 dfield_get_data(
 /*============*/
 	const dfield_t* field)	/*!< in: field */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 #else /* UNIV_DEBUG */
 # define dfield_get_type(field) (&(field)->type)
 # define dfield_get_data(field) ((field)->data)
@@ -68,7 +68,7 @@ dfield_set_type(
 /*============*/
 	dfield_t*	field,	/*!< in: SQL data field */
 	const dtype_t*	type)	/*!< in: pointer to data type struct */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*********************************************************************//**
 Gets length of field data.
 @return	length of data; UNIV_SQL_NULL if SQL null data */
@@ -77,7 +77,7 @@ ulint
 dfield_get_len(
 /*===========*/
 	const dfield_t* field)	/*!< in: field */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*********************************************************************//**
 Sets length in a field. */
 UNIV_INLINE
@@ -86,7 +86,7 @@ dfield_set_len(
 /*===========*/
 	dfield_t*	field,	/*!< in: field */
 	ulint		len)	/*!< in: length or UNIV_SQL_NULL */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*********************************************************************//**
 Determines if a field is SQL NULL
 @return	nonzero if SQL null data */
@@ -95,7 +95,7 @@ ulint
 dfield_is_null(
 /*===========*/
 	const dfield_t* field)	/*!< in: field */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*********************************************************************//**
 Determines if a field is externally stored
 @return	nonzero if externally stored */
@@ -104,7 +104,7 @@ ulint
 dfield_is_ext(
 /*==========*/
 	const dfield_t* field)	/*!< in: field */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*********************************************************************//**
 Sets the "external storage" flag */
 UNIV_INLINE
@@ -112,7 +112,7 @@ void
 dfield_set_ext(
 /*===========*/
 	dfield_t*	field)	/*!< in/out: field */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*********************************************************************//**
 Sets pointer to the data and length in a field. */
 UNIV_INLINE
@@ -122,7 +122,7 @@ dfield_set_data(
 	dfield_t*	field,	/*!< in: field */
 	const void*	data,	/*!< in: data */
 	ulint		len)	/*!< in: length or UNIV_SQL_NULL */
-	__attribute__((nonnull(1)));
+	MY_ATTRIBUTE((nonnull(1)));
 /*********************************************************************//**
 Sets a data field to SQL NULL. */
 UNIV_INLINE
@@ -130,7 +130,7 @@ void
 dfield_set_null(
 /*============*/
 	dfield_t*	field)	/*!< in/out: field */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /**********************************************************************//**
 Writes an SQL null field full of zeros. */
 UNIV_INLINE
@@ -139,7 +139,7 @@ data_write_sql_null(
 /*================*/
 	byte*	data,	/*!< in: pointer to a buffer of size len */
 	ulint	len)	/*!< in: SQL null size in bytes */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*********************************************************************//**
 Copies the data and len fields. */
 UNIV_INLINE
@@ -148,7 +148,7 @@ dfield_copy_data(
 /*=============*/
 	dfield_t*	field1,	/*!< out: field to copy to */
 	const dfield_t*	field2)	/*!< in: field to copy from */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*********************************************************************//**
 Copies a data field to another. */
 UNIV_INLINE
@@ -157,7 +157,7 @@ dfield_copy(
 /*========*/
 	dfield_t*	field1,	/*!< out: field to copy to */
 	const dfield_t*	field2)	/*!< in: field to copy from */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*********************************************************************//**
 Copies the data pointed to by a data field. */
 UNIV_INLINE
@@ -166,7 +166,7 @@ dfield_dup(
 /*=======*/
 	dfield_t*	field,	/*!< in/out: data field */
 	mem_heap_t*	heap)	/*!< in: memory heap where allocated */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 #ifndef UNIV_HOTBACKUP
 /*********************************************************************//**
 Tests if two data fields are equal.
@@ -181,7 +181,7 @@ dfield_datas_are_binary_equal(
 	const dfield_t*	field2,	/*!< in: field */
 	ulint		len)	/*!< in: maximum prefix to compare,
 				or 0 to compare the whole field length */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*********************************************************************//**
 Tests if dfield data length and content is equal to the given.
 @return	TRUE if equal */
@@ -192,7 +192,7 @@ dfield_data_is_binary_equal(
 	const dfield_t*	field,	/*!< in: field */
 	ulint		len,	/*!< in: data length or UNIV_SQL_NULL */
 	const byte*	data)	/*!< in: data */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 #endif /* !UNIV_HOTBACKUP */
 /*********************************************************************//**
 Gets number of fields in a data tuple.
@@ -202,7 +202,7 @@ ulint
 dtuple_get_n_fields(
 /*================*/
 	const dtuple_t*	tuple)	/*!< in: tuple */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 #ifdef UNIV_DEBUG
 /*********************************************************************//**
 Gets nth field of a tuple.
@@ -224,7 +224,7 @@ ulint
 dtuple_get_info_bits(
 /*=================*/
 	const dtuple_t*	tuple)	/*!< in: tuple */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*********************************************************************//**
 Sets info bits in a data tuple. */
 UNIV_INLINE
@@ -233,7 +233,7 @@ dtuple_set_info_bits(
 /*=================*/
 	dtuple_t*	tuple,		/*!< in: tuple */
 	ulint		info_bits)	/*!< in: info bits */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*********************************************************************//**
 Gets number of fields used in record comparisons.
 @return	number of fields used in comparisons in rem0cmp.* */
@@ -242,7 +242,7 @@ ulint
 dtuple_get_n_fields_cmp(
 /*====================*/
 	const dtuple_t*	tuple)	/*!< in: tuple */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*********************************************************************//**
 Gets number of fields used in record comparisons. */
 UNIV_INLINE
@@ -252,7 +252,7 @@ dtuple_set_n_fields_cmp(
 	dtuple_t*	tuple,		/*!< in: tuple */
 	ulint		n_fields_cmp)	/*!< in: number of fields used in
 					comparisons in rem0cmp.* */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /* Estimate the number of bytes that are going to be allocated when
 creating a new dtuple_t object */
@@ -272,7 +272,7 @@ dtuple_create_from_mem(
 	void*	buf,		/*!< in, out: buffer to use */
 	ulint	buf_size,	/*!< in: buffer size */
 	ulint	n_fields)	/*!< in: number of fields */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 /**********************************************************//**
 Creates a data tuple to a memory heap. The default value for number
@@ -286,7 +286,7 @@ dtuple_create(
 				is created, DTUPLE_EST_ALLOC(n_fields)
 				bytes will be allocated from this heap */
 	ulint		n_fields)/*!< in: number of fields */
-	__attribute__((nonnull, malloc));
+	MY_ATTRIBUTE((nonnull, malloc));
 
 /*********************************************************************//**
 Sets number of fields used in a tuple. Normally this is set in
@@ -297,7 +297,7 @@ dtuple_set_n_fields(
 /*================*/
 	dtuple_t*	tuple,		/*!< in: tuple */
 	ulint		n_fields)	/*!< in: number of fields */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*********************************************************************//**
 Copies a data tuple to another.  This is a shallow copy; if a deep copy
 is desired, dfield_dup() will have to be invoked on each field.
@@ -309,7 +309,7 @@ dtuple_copy(
 	const dtuple_t*	tuple,	/*!< in: tuple to copy from */
 	mem_heap_t*	heap)	/*!< in: memory heap
 				where the tuple is created */
-	__attribute__((nonnull, malloc));
+	MY_ATTRIBUTE((nonnull, malloc));
 /**********************************************************//**
 The following function returns the sum of data lengths of a tuple. The space
 occupied by the field structs or the tuple struct is not counted.
@@ -320,7 +320,7 @@ dtuple_get_data_size(
 /*=================*/
 	const dtuple_t*	tuple,	/*!< in: typed data tuple */
 	ulint		comp)	/*!< in: nonzero=ROW_FORMAT=COMPACT  */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*********************************************************************//**
 Computes the number of externally stored fields in a data tuple.
 @return	number of fields */
@@ -329,7 +329,7 @@ ulint
 dtuple_get_n_ext(
 /*=============*/
 	const dtuple_t*	tuple)	/*!< in: tuple */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /************************************************************//**
 Compare two data tuples, respecting the collation of character fields.
 @return 1, 0 , -1 if tuple1 is greater, equal, less, respectively,
@@ -340,7 +340,7 @@ dtuple_coll_cmp(
 /*============*/
 	const dtuple_t*	tuple1,	/*!< in: tuple 1 */
 	const dtuple_t*	tuple2)	/*!< in: tuple 2 */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /************************************************************//**
 Folds a prefix given as the number of fields of a tuple.
 @return	the folded value */
@@ -353,7 +353,7 @@ dtuple_fold(
 	ulint		n_bytes,/*!< in: number of bytes to fold in an
 				incomplete last field */
 	index_id_t	tree_id)/*!< in: index tree id */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 /*******************************************************************//**
 Sets types of fields binary in a tuple. */
 UNIV_INLINE
@@ -362,7 +362,7 @@ dtuple_set_types_binary(
 /*====================*/
 	dtuple_t*	tuple,	/*!< in: data tuple */
 	ulint		n)	/*!< in: number of fields to set */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /**********************************************************************//**
 Checks if a dtuple contains an SQL null value.
 @return	TRUE if some field is SQL null */
@@ -371,7 +371,7 @@ ibool
 dtuple_contains_null(
 /*=================*/
 	const dtuple_t*	tuple)	/*!< in: dtuple */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /**********************************************************//**
 Checks that a data field is typed. Asserts an error if not.
 @return	TRUE if ok */
@@ -380,7 +380,7 @@ ibool
 dfield_check_typed(
 /*===============*/
 	const dfield_t*	field)	/*!< in: data field */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /**********************************************************//**
 Checks that a data tuple is typed. Asserts an error if not.
 @return	TRUE if ok */
@@ -389,7 +389,7 @@ ibool
 dtuple_check_typed(
 /*===============*/
 	const dtuple_t*	tuple)	/*!< in: tuple */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /**********************************************************//**
 Checks that a data tuple is typed.
 @return	TRUE if ok */
@@ -398,7 +398,7 @@ ibool
 dtuple_check_typed_no_assert(
 /*=========================*/
 	const dtuple_t*	tuple)	/*!< in: tuple */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 #ifdef UNIV_DEBUG
 /**********************************************************//**
 Validates the consistency of a tuple which must be complete, i.e,
@@ -409,7 +409,7 @@ ibool
 dtuple_validate(
 /*============*/
 	const dtuple_t*	tuple)	/*!< in: tuple */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 #endif /* UNIV_DEBUG */
 /*************************************************************//**
 Pretty prints a dfield value according to its data type. */
@@ -418,7 +418,7 @@ void
 dfield_print(
 /*=========*/
 	const dfield_t*	dfield)	/*!< in: dfield */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*************************************************************//**
 Pretty prints a dfield value according to its data type. Also the hex string
 is printed if a string contains non-printable characters. */
@@ -427,7 +427,7 @@ void
 dfield_print_also_hex(
 /*==================*/
 	const dfield_t*	dfield)	 /*!< in: dfield */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /**********************************************************//**
 The following function prints the contents of a tuple. */
 UNIV_INTERN
@@ -436,7 +436,7 @@ dtuple_print(
 /*=========*/
 	FILE*		f,	/*!< in: output stream */
 	const dtuple_t*	tuple)	/*!< in: tuple */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /**************************************************************//**
 Moves parts of long fields in entry to the big record vector so that
 the size of tuple drops below the maximum record size allowed in the
@@ -453,7 +453,7 @@ dtuple_convert_big_rec(
 	dtuple_t*	entry,	/*!< in/out: index entry */
 	ulint*		n_ext)	/*!< in/out: number of
 				externally stored columns */
-	__attribute__((nonnull, malloc, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, malloc, warn_unused_result));
 /**************************************************************//**
 Puts back to entry the data stored in vector. Note that to ensure the
 fields in entry can accommodate the data, vector must have been created
@@ -466,7 +466,7 @@ dtuple_convert_back_big_rec(
 	dtuple_t*	entry,	/*!< in: entry whose data was put to vector */
 	big_rec_t*	vector)	/*!< in, own: big rec vector; it is
 				freed in this function */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /**************************************************************//**
 Frees the memory in a big rec vector. */
 UNIV_INLINE
@@ -475,7 +475,7 @@ dtuple_big_rec_free(
 /*================*/
 	big_rec_t*	vector)	/*!< in, own: big rec vector; it is
 				freed in this function */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /*######################################################################*/
 
--- a/storage/innobase/include/dict0boot.h
+++ b/storage/innobase/include/dict0boot.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1996, 2012, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1996, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -95,7 +95,7 @@ UNIV_INTERN
 dberr_t
 dict_boot(void)
 /*===========*/
-	__attribute__((warn_unused_result));
+	MY_ATTRIBUTE((warn_unused_result));
 
 /*****************************************************************//**
 Creates and initializes the data dictionary at the server bootstrap.
@@ -104,7 +104,7 @@ UNIV_INTERN
 dberr_t
 dict_create(void)
 /*=============*/
-	__attribute__((warn_unused_result));
+	MY_ATTRIBUTE((warn_unused_result));
 
 /*********************************************************************//**
 Check if a table id belongs to  system table.
@@ -114,7 +114,7 @@ bool
 dict_is_sys_table(
 /*==============*/
 	table_id_t	id)		/*!< in: table id to check */
-	__attribute__((warn_unused_result));
+	MY_ATTRIBUTE((warn_unused_result));
 
 /* Space id and page no where the dictionary header resides */
 #define	DICT_HDR_SPACE		0	/* the SYSTEM tablespace */
--- a/storage/innobase/include/dict0crea.h
+++ b/storage/innobase/include/dict0crea.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1996, 2014, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1996, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -123,7 +123,7 @@ dict_create_add_foreign_id(
 				incremented if used */
 	const char*	name,	/*!< in: table name */
 	dict_foreign_t*	foreign)/*!< in/out: foreign key */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /** Adds the given set of foreign key objects to the dictionary tables
 in the database. This function does not modify the dictionary cache. The
@@ -142,7 +142,7 @@ dict_create_add_foreigns_to_dictionary(
 	const dict_foreign_set&	local_fk_set,
 	const dict_table_t*	table,
 	trx_t*			trx)
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /****************************************************************//**
 Creates the tablespaces and datafiles system tables inside InnoDB
 at server bootstrap or server start if they are not found or are
@@ -177,7 +177,7 @@ dict_create_add_foreign_to_dictionary(
 	const char*		name,	/*!< in: table name */
 	const dict_foreign_t*	foreign,/*!< in: foreign key */
 	trx_t*			trx)	/*!< in/out: dictionary transaction */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 /* Table create node structure */
 struct tab_node_t{
--- a/storage/innobase/include/dict0crea.ic
+++ b/storage/innobase/include/dict0crea.ic
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1996, 2012, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1996, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -33,7 +33,7 @@ UNIV_INTERN
 bool
 row_is_mysql_tmp_table_name(
 /*========================*/
-	const char*     name) __attribute__((warn_unused_result));
+	const char*     name) MY_ATTRIBUTE((warn_unused_result));
 				/*!< in: table name in the form
 				'database/tablename' */
 
--- a/storage/innobase/include/dict0dict.h
+++ b/storage/innobase/include/dict0dict.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1996, 2015, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1996, 2016, Oracle and/or its affiliates. All Rights Reserved.
 Copyright (c) 2012, Facebook Inc.
 
 This program is free software; you can redistribute it and/or modify it under
@@ -53,7 +53,7 @@ void
 dict_casedn_str(
 /*============*/
 	char*	a)	/*!< in/out: string to put in lower case */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /********************************************************************//**
 Get the database name length in a table name.
 @return	database name length */
@@ -63,7 +63,7 @@ dict_get_db_name_len(
 /*=================*/
 	const char*	name)	/*!< in: table name in the form
 				dbname '/' tablename */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*********************************************************************//**
 Open a table from its database and table name, this is currently used by
 foreign constraint parser to get the referenced table.
@@ -107,7 +107,7 @@ dict_remove_db_name(
 /*================*/
 	const char*	name)	/*!< in: table name in the form
 				dbname '/' tablename */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 /** Operation to perform when opening a table */
 enum dict_table_op_t {
@@ -130,7 +130,7 @@ dict_table_open_on_id(
 	table_id_t	table_id,	/*!< in: table id */
 	ibool		dict_locked,	/*!< in: TRUE=data dictionary locked */
 	dict_table_op_t	table_op)	/*!< in: operation to perform */
-	__attribute__((warn_unused_result));
+	MY_ATTRIBUTE((warn_unused_result));
 /********************************************************************//**
 Decrements the count of open handles to a table. */
 UNIV_INTERN
@@ -142,7 +142,7 @@ dict_table_close(
 	ibool		try_drop)	/*!< in: TRUE=try to drop any orphan
 					indexes after an aborted online
 					index creation */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /**********************************************************************//**
 Inits the data dictionary module. */
 UNIV_INTERN
@@ -167,7 +167,7 @@ ulint
 dict_col_get_mbminlen(
 /*==================*/
 	const dict_col_t*	col)	/*!< in: column */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*********************************************************************//**
 Gets the maximum number of bytes per character.
 @return maximum multi-byte char size, in bytes */
@@ -176,7 +176,7 @@ ulint
 dict_col_get_mbmaxlen(
 /*==================*/
 	const dict_col_t*	col)	/*!< in: column */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*********************************************************************//**
 Sets the minimum and maximum number of bytes per character. */
 UNIV_INLINE
@@ -188,7 +188,7 @@ dict_col_set_mbminmaxlen(
 					character size, in bytes */
 	ulint		mbmaxlen)	/*!< in: minimum multi-byte
 					character size, in bytes */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*********************************************************************//**
 Gets the column data type. */
 UNIV_INLINE
@@ -197,7 +197,7 @@ dict_col_copy_type(
 /*===============*/
 	const dict_col_t*	col,	/*!< in: column */
 	dtype_t*		type)	/*!< out: data type */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /**********************************************************************//**
 Determine bytes of column prefix to be stored in the undo log. Please
 note if the table format is UNIV_FORMAT_A (< UNIV_FORMAT_B), no prefix
@@ -210,7 +210,7 @@ dict_max_field_len_store_undo(
 	dict_table_t*		table,	/*!< in: table */
 	const dict_col_t*	col)	/*!< in: column which index prefix
 					is based on */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 #endif /* !UNIV_HOTBACKUP */
 #ifdef UNIV_DEBUG
 /*********************************************************************//**
@@ -222,7 +222,7 @@ dict_col_type_assert_equal(
 /*=======================*/
 	const dict_col_t*	col,	/*!< in: column */
 	const dtype_t*		type)	/*!< in: data type */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 #endif /* UNIV_DEBUG */
 #ifndef UNIV_HOTBACKUP
 /***********************************************************************//**
@@ -233,7 +233,7 @@ ulint
 dict_col_get_min_size(
 /*==================*/
 	const dict_col_t*	col)	/*!< in: column */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /***********************************************************************//**
 Returns the maximum size of the column.
 @return	maximum size */
@@ -242,7 +242,7 @@ ulint
 dict_col_get_max_size(
 /*==================*/
 	const dict_col_t*	col)	/*!< in: column */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /***********************************************************************//**
 Returns the size of a fixed size column, 0 if not a fixed size column.
 @return	fixed size, or 0 */
@@ -252,7 +252,7 @@ dict_col_get_fixed_size(
 /*====================*/
 	const dict_col_t*	col,	/*!< in: column */
 	ulint			comp)	/*!< in: nonzero=ROW_FORMAT=COMPACT  */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /***********************************************************************//**
 Returns the ROW_FORMAT=REDUNDANT stored SQL NULL size of a column.
 For fixed length types it is the fixed length of the type, otherwise 0.
@@ -263,7 +263,7 @@ dict_col_get_sql_null_size(
 /*=======================*/
 	const dict_col_t*	col,	/*!< in: column */
 	ulint			comp)	/*!< in: nonzero=ROW_FORMAT=COMPACT  */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*********************************************************************//**
 Gets the column number.
 @return	col->ind, table column position (starting from 0) */
@@ -272,7 +272,7 @@ ulint
 dict_col_get_no(
 /*============*/
 	const dict_col_t*	col)	/*!< in: column */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*********************************************************************//**
 Gets the column position in the clustered index. */
 UNIV_INLINE
@@ -281,7 +281,7 @@ dict_col_get_clust_pos(
 /*===================*/
 	const dict_col_t*	col,		/*!< in: table column */
 	const dict_index_t*	clust_index)	/*!< in: clustered index */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /****************************************************************//**
 If the given column name is reserved for InnoDB system columns, return
 TRUE.
@@ -291,7 +291,7 @@ ibool
 dict_col_name_is_reserved(
 /*======================*/
 	const char*	name)	/*!< in: column name */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /********************************************************************//**
 Acquire the autoinc lock. */
 UNIV_INTERN
@@ -299,7 +299,7 @@ void
 dict_table_autoinc_lock(
 /*====================*/
 	dict_table_t*	table)	/*!< in/out: table */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /********************************************************************//**
 Unconditionally set the autoinc counter. */
 UNIV_INTERN
@@ -308,7 +308,7 @@ dict_table_autoinc_initialize(
 /*==========================*/
 	dict_table_t*	table,	/*!< in/out: table */
 	ib_uint64_t	value)	/*!< in: next value to assign to a row */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /** Store autoinc value when the table is evicted.
 @param[in]	table	table evicted */
@@ -333,7 +333,7 @@ ib_uint64_t
 dict_table_autoinc_read(
 /*====================*/
 	const dict_table_t*	table)	/*!< in: table */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /********************************************************************//**
 Updates the autoinc counter if the value supplied is greater than the
 current value. */
@@ -344,7 +344,7 @@ dict_table_autoinc_update_if_greater(
 
 	dict_table_t*	table,	/*!< in/out: table */
 	ib_uint64_t	value)	/*!< in: value which was assigned to a row */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /********************************************************************//**
 Release the autoinc lock. */
 UNIV_INTERN
@@ -352,7 +352,7 @@ void
 dict_table_autoinc_unlock(
 /*======================*/
 	dict_table_t*	table)	/*!< in/out: table */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 #endif /* !UNIV_HOTBACKUP */
 /**********************************************************************//**
 Adds system columns to a table object. */
@@ -362,7 +362,7 @@ dict_table_add_system_columns(
 /*==========================*/
 	dict_table_t*	table,	/*!< in/out: table */
 	mem_heap_t*	heap)	/*!< in: temporary heap */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 #ifndef UNIV_HOTBACKUP
 /**********************************************************************//**
 Adds a table object to the dictionary cache. */
@@ -373,7 +373,7 @@ dict_table_add_to_cache(
 	dict_table_t*	table,		/*!< in: table */
 	ibool		can_be_evicted,	/*!< in: TRUE if can be evicted*/
 	mem_heap_t*	heap)		/*!< in: temporary heap */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /**********************************************************************//**
 Removes a table object from the dictionary cache. */
 UNIV_INTERN
@@ -381,7 +381,7 @@ void
 dict_table_remove_from_cache(
 /*=========================*/
 	dict_table_t*	table)	/*!< in, own: table */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /**********************************************************************//**
 Removes a table object from the dictionary cache. */
 UNIV_INTERN
@@ -404,7 +404,7 @@ dict_table_rename_in_cache(
 					/*!< in: in ALTER TABLE we want
 					to preserve the original table name
 					in constraints which reference it */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /**********************************************************************//**
 Removes an index from the dictionary cache. */
 UNIV_INTERN
@@ -413,7 +413,7 @@ dict_index_remove_from_cache(
 /*=========================*/
 	dict_table_t*	table,	/*!< in/out: table */
 	dict_index_t*	index)	/*!< in, own: index */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /**********************************************************************//**
 Change the id of a table object in the dictionary cache. This is used in
 DISCARD TABLESPACE. */
@@ -423,7 +423,7 @@ dict_table_change_id_in_cache(
 /*==========================*/
 	dict_table_t*	table,	/*!< in/out: table object already in cache */
 	table_id_t	new_id)	/*!< in: new id to set */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /**********************************************************************//**
 Removes a foreign constraint struct from the dictionary cache. */
 UNIV_INTERN
@@ -431,7 +431,7 @@ void
 dict_foreign_remove_from_cache(
 /*===========================*/
 	dict_foreign_t*	foreign)	/*!< in, own: foreign constraint */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /**********************************************************************//**
 Adds a foreign key constraint object to the dictionary cache. May free
 the object if there already is an object with the same identifier in.
@@ -452,7 +452,7 @@ dict_foreign_add_to_cache(
 				compatibility */
 	dict_err_ignore_t	ignore_err)
 				/*!< in: error to be ignored */
-	__attribute__((nonnull(1), warn_unused_result));
+	MY_ATTRIBUTE((nonnull(1), warn_unused_result));
 /*********************************************************************//**
 Checks if a table is referenced by foreign keys.
 @return	TRUE if table is referenced by a foreign key */
@@ -461,7 +461,7 @@ ibool
 dict_table_is_referenced_by_foreign_key(
 /*====================================*/
 	const dict_table_t*	table)	/*!< in: InnoDB table */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /**********************************************************************//**
 Replace the index passed in with another equivalent index in the
 foreign key lists of the table.
@@ -475,7 +475,7 @@ dict_foreign_replace_index(
 					/*!< in: column names, or NULL
 					to use table->col_names */
 	const dict_index_t*	index)	/*!< in: index to be replaced */
-	__attribute__((nonnull(1,3), warn_unused_result));
+	MY_ATTRIBUTE((nonnull(1,3), warn_unused_result));
 /**********************************************************************//**
 Determines whether a string starts with the specified keyword.
 @return TRUE if str starts with keyword */
@@ -486,7 +486,7 @@ dict_str_starts_with_keyword(
 	THD*		thd,		/*!< in: MySQL thread handle */
 	const char*	str,		/*!< in: string to scan for keyword */
 	const char*	keyword)	/*!< in: keyword to look for */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*********************************************************************//**
 Scans a table create SQL string and adds to the data dictionary
 the foreign key constraints declared in the string. This function
@@ -515,7 +515,7 @@ dict_create_foreign_constraints(
 	ibool		reject_fks)	/*!< in: if TRUE, fail with error
 					code DB_CANNOT_ADD_CONSTRAINT if
 					any foreign keys are found. */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /**********************************************************************//**
 Parses the CONSTRAINT id's to be dropped in an ALTER TABLE statement.
 @return DB_SUCCESS or DB_CANNOT_DROP_CONSTRAINT if syntax error or the
@@ -532,7 +532,7 @@ dict_foreign_parse_drop_constraints(
 						to drop */
 	const char***	constraints_to_drop)	/*!< out: id's of the
 						constraints to drop */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /**********************************************************************//**
 Returns a table object and increments its open handle count.
 NOTE! This is a high-level function to be used mainly from outside the
@@ -551,7 +551,7 @@ dict_table_open_on_name(
 	dict_err_ignore_t
 			ignore_err)	/*!< in: error to be ignored when
 					loading the table */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 /*********************************************************************//**
 Tries to find an index whose first fields are the columns in the array,
@@ -580,7 +580,7 @@ dict_foreign_find_index(
 					/*!< in: nonzero if none of
 					the columns must be declared
 					NOT NULL */
-	__attribute__((nonnull(1,3), warn_unused_result));
+	MY_ATTRIBUTE((nonnull(1,3), warn_unused_result));
 /**********************************************************************//**
 Returns a column's name.
 @return column name. NOTE: not guaranteed to stay valid if table is
@@ -591,7 +591,7 @@ dict_table_get_col_name(
 /*====================*/
 	const dict_table_t*	table,	/*!< in: table */
 	ulint			col_nr)	/*!< in: column number */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /**********************************************************************//**
 Prints a table data. */
 UNIV_INTERN
@@ -599,7 +599,7 @@ void
 dict_table_print(
 /*=============*/
 	dict_table_t*	table)	/*!< in: table */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /**********************************************************************//**
 Outputs info on foreign keys of a table. */
 UNIV_INTERN
@@ -613,7 +613,7 @@ dict_print_info_on_foreign_keys(
 	FILE*		file,	/*!< in: file where to print */
 	trx_t*		trx,	/*!< in: transaction */
 	dict_table_t*	table)	/*!< in: table */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /**********************************************************************//**
 Outputs info on a foreign key of a table in a format suitable for
 CREATE TABLE. */
@@ -625,7 +625,7 @@ dict_print_info_on_foreign_key_in_create_format(
 	trx_t*		trx,		/*!< in: transaction */
 	dict_foreign_t*	foreign,	/*!< in: foreign key constraint */
 	ibool		add_newline)	/*!< in: whether to add a newline */
-	__attribute__((nonnull(1,3)));
+	MY_ATTRIBUTE((nonnull(1,3)));
 /********************************************************************//**
 Displays the names of the index and the table. */
 UNIV_INTERN
@@ -635,7 +635,7 @@ dict_index_name_print(
 	FILE*			file,	/*!< in: output stream */
 	const trx_t*		trx,	/*!< in: transaction */
 	const dict_index_t*	index)	/*!< in: index to print */
-	__attribute__((nonnull(1,3)));
+	MY_ATTRIBUTE((nonnull(1,3)));
 /*********************************************************************//**
 Tries to find an index whose first fields are the columns in the array,
 in the same order and is not marked for deletion and is not the same
@@ -664,7 +664,7 @@ dict_foreign_qualify_index(
 					/*!< in: nonzero if none of
 					the columns must be declared
 					NOT NULL */
-	__attribute__((nonnull(1,3), warn_unused_result));
+	MY_ATTRIBUTE((nonnull(1,3), warn_unused_result));
 #ifdef UNIV_DEBUG
 /********************************************************************//**
 Gets the first index on the table (the clustered index).
@@ -674,7 +674,7 @@ dict_index_t*
 dict_table_get_first_index(
 /*=======================*/
 	const dict_table_t*	table)	/*!< in: table */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /********************************************************************//**
 Gets the last index on the table.
 @return	index, NULL if none exists */
@@ -683,7 +683,7 @@ dict_index_t*
 dict_table_get_last_index(
 /*=======================*/
 	const dict_table_t*	table)	/*!< in: table */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /********************************************************************//**
 Gets the next index on the table.
 @return	index, NULL if none left */
@@ -692,7 +692,7 @@ dict_index_t*
 dict_table_get_next_index(
 /*======================*/
 	const dict_index_t*	index)	/*!< in: index */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 #else /* UNIV_DEBUG */
 # define dict_table_get_first_index(table) UT_LIST_GET_FIRST((table)->indexes)
 # define dict_table_get_last_index(table) UT_LIST_GET_LAST((table)->indexes)
@@ -721,7 +721,7 @@ ulint
 dict_index_is_clust(
 /*================*/
 	const dict_index_t*	index)	/*!< in: index */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 /********************************************************************//**
 Check whether the index is unique.
 @return	nonzero for unique index, zero for other indexes */
@@ -730,7 +730,7 @@ ulint
 dict_index_is_unique(
 /*=================*/
 	const dict_index_t*	index)	/*!< in: index */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 /********************************************************************//**
 Check whether the index is the insert buffer tree.
 @return	nonzero for insert buffer, zero for other indexes */
@@ -739,7 +739,7 @@ ulint
 dict_index_is_ibuf(
 /*===============*/
 	const dict_index_t*	index)	/*!< in: index */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 /********************************************************************//**
 Check whether the index is a secondary index or the insert buffer tree.
 @return	nonzero for insert buffer, zero for other indexes */
@@ -748,7 +748,7 @@ ulint
 dict_index_is_sec_or_ibuf(
 /*======================*/
 	const dict_index_t*	index)	/*!< in: index */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 
 /************************************************************************
 Gets the all the FTS indexes for the table. NOTE: must not be called for
@@ -760,7 +760,7 @@ dict_table_get_all_fts_indexes(
 				/* out: number of indexes collected */
 	dict_table_t*	table,	/* in: table */
 	ib_vector_t*	indexes)/* out: vector for collecting FTS indexes */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /********************************************************************//**
 Gets the number of user-defined columns in a table in the dictionary
 cache.
@@ -770,7 +770,7 @@ ulint
 dict_table_get_n_user_cols(
 /*=======================*/
 	const dict_table_t*	table)	/*!< in: table */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 /********************************************************************//**
 Gets the number of system columns in a table in the dictionary cache.
 @return	number of system (e.g., ROW_ID) columns of a table */
@@ -779,7 +779,7 @@ ulint
 dict_table_get_n_sys_cols(
 /*======================*/
 	const dict_table_t*	table)	/*!< in: table */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 /********************************************************************//**
 Gets the number of all columns (also system) in a table in the dictionary
 cache.
@@ -789,7 +789,7 @@ ulint
 dict_table_get_n_cols(
 /*==================*/
 	const dict_table_t*	table)	/*!< in: table */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 /********************************************************************//**
 Gets the approximately estimated number of rows in the table.
 @return	estimated number of rows */
@@ -798,7 +798,7 @@ ib_uint64_t
 dict_table_get_n_rows(
 /*==================*/
 	const dict_table_t*	table)	/*!< in: table */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /********************************************************************//**
 Increment the number of rows in the table by one.
 Notice that this operation is not protected by any latch, the number is
@@ -808,7 +808,7 @@ void
 dict_table_n_rows_inc(
 /*==================*/
 	dict_table_t*	table)	/*!< in/out: table */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /********************************************************************//**
 Decrement the number of rows in the table by one.
 Notice that this operation is not protected by any latch, the number is
@@ -818,7 +818,7 @@ void
 dict_table_n_rows_dec(
 /*==================*/
 	dict_table_t*	table)	/*!< in/out: table */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 #ifdef UNIV_DEBUG
 /********************************************************************//**
 Gets the nth column of a table.
@@ -829,7 +829,7 @@ dict_table_get_nth_col(
 /*===================*/
 	const dict_table_t*	table,	/*!< in: table */
 	ulint			pos)	/*!< in: position of column */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /********************************************************************//**
 Gets the given system column of a table.
 @return	pointer to column object */
@@ -839,7 +839,7 @@ dict_table_get_sys_col(
 /*===================*/
 	const dict_table_t*	table,	/*!< in: table */
 	ulint			sys)	/*!< in: DATA_ROW_ID, ... */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 #else /* UNIV_DEBUG */
 #define dict_table_get_nth_col(table, pos) \
 ((table)->cols + (pos))
@@ -855,7 +855,7 @@ dict_table_get_sys_col_no(
 /*======================*/
 	const dict_table_t*	table,	/*!< in: table */
 	ulint			sys)	/*!< in: DATA_ROW_ID, ... */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 #ifndef UNIV_HOTBACKUP
 /********************************************************************//**
 Returns the minimum data size of an index record.
@@ -865,7 +865,7 @@ ulint
 dict_index_get_min_size(
 /*====================*/
 	const dict_index_t*	index)	/*!< in: index */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 #endif /* !UNIV_HOTBACKUP */
 /********************************************************************//**
 Check whether the table uses the compact page format.
@@ -875,7 +875,7 @@ ibool
 dict_table_is_comp(
 /*===============*/
 	const dict_table_t*	table)	/*!< in: table */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /********************************************************************//**
 Determine the file format of a table.
 @return	file format version */
@@ -884,7 +884,7 @@ ulint
 dict_table_get_format(
 /*==================*/
 	const dict_table_t*	table)	/*!< in: table */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /********************************************************************//**
 Determine the file format from a dict_table_t::flags.
 @return	file format version */
@@ -893,7 +893,7 @@ ulint
 dict_tf_get_format(
 /*===============*/
 	ulint		flags)		/*!< in: dict_table_t::flags */
-	__attribute__((warn_unused_result));
+	MY_ATTRIBUTE((warn_unused_result));
 /********************************************************************//**
 Set the various values in a dict_table_t::flags pointer. */
 UNIV_INLINE
@@ -904,7 +904,7 @@ dict_tf_set(
 	rec_format_t	format,		/*!< in: file format */
 	ulint		zip_ssize,	/*!< in: zip shift size */
 	bool		remote_path)	/*!< in: table uses DATA DIRECTORY */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /********************************************************************//**
 Convert a 32 bit integer table flags to the 32 bit integer that is
 written into the tablespace header at the offset FSP_SPACE_FLAGS and is
@@ -921,7 +921,7 @@ ulint
 dict_tf_to_fsp_flags(
 /*=================*/
 	ulint	flags)	/*!< in: dict_table_t::flags */
-	__attribute__((const));
+	MY_ATTRIBUTE((const));
 /********************************************************************//**
 Extract the compressed page size from table flags.
 @return	compressed page size, or 0 if not compressed */
@@ -930,7 +930,7 @@ ulint
 dict_tf_get_zip_size(
 /*=================*/
 	ulint	flags)			/*!< in: flags */
-	__attribute__((const));
+	MY_ATTRIBUTE((const));
 /********************************************************************//**
 Check whether the table uses the compressed compact page format.
 @return	compressed page size, or 0 if not compressed */
@@ -939,7 +939,7 @@ ulint
 dict_table_zip_size(
 /*================*/
 	const dict_table_t*	table)	/*!< in: table */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 #ifndef UNIV_HOTBACKUP
 /*********************************************************************//**
 Obtain exclusive locks on all index trees of the table. This is to prevent
@@ -950,7 +950,7 @@ void
 dict_table_x_lock_indexes(
 /*======================*/
 	dict_table_t*	table)	/*!< in: table */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*********************************************************************//**
 Release the exclusive locks on all index tree. */
 UNIV_INLINE
@@ -958,7 +958,7 @@ void
 dict_table_x_unlock_indexes(
 /*========================*/
 	dict_table_t*	table)	/*!< in: table */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /********************************************************************//**
 Checks if a column is in the ordering columns of the clustered index of a
 table. Column prefixes are treated like whole columns.
@@ -969,7 +969,7 @@ dict_table_col_in_clustered_key(
 /*============================*/
 	const dict_table_t*	table,	/*!< in: table */
 	ulint			n)	/*!< in: column number */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*******************************************************************//**
 Check if the table has an FTS index.
 @return TRUE if table has an FTS index */
@@ -978,7 +978,7 @@ ibool
 dict_table_has_fts_index(
 /*=====================*/
 	dict_table_t*   table)		/*!< in: table */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*******************************************************************//**
 Copies types of columns contained in table to tuple and sets all
 fields of the tuple to the SQL NULL value.  This function should
@@ -989,7 +989,7 @@ dict_table_copy_types(
 /*==================*/
 	dtuple_t*		tuple,	/*!< in/out: data tuple */
 	const dict_table_t*	table)	/*!< in: table */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /********************************************************************
 Wait until all the background threads of the given table have exited, i.e.,
 bg_threads == 0. Note: bg_threads_mutex must be reserved when
@@ -1001,7 +1001,7 @@ dict_table_wait_for_bg_threads_to_exit(
 	dict_table_t*	table,	/* in: table */
 	ulint		delay)	/* in: time in microseconds to wait between
 				checks of bg_threads. */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /**********************************************************************//**
 Looks for an index with the given id. NOTE that we do not reserve
 the dictionary mutex: this function is for emergency purposes like
@@ -1012,7 +1012,7 @@ dict_index_t*
 dict_index_find_on_id_low(
 /*======================*/
 	index_id_t	id)	/*!< in: index id */
-	__attribute__((warn_unused_result));
+	MY_ATTRIBUTE((warn_unused_result));
 /**********************************************************************//**
 Make room in the table cache by evicting an unused table. The unused table
 should not be part of FK relationship and currently not used in any user
@@ -1038,7 +1038,7 @@ dict_index_add_to_cache(
 	ibool		strict)	/*!< in: TRUE=refuse to create the index
 				if records could be too big to fit in
 				an B-tree page */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /**********************************************************************//**
 Removes an index from the dictionary cache. */
 UNIV_INTERN
@@ -1047,7 +1047,7 @@ dict_index_remove_from_cache(
 /*=========================*/
 	dict_table_t*	table,	/*!< in/out: table */
 	dict_index_t*	index)	/*!< in, own: index */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 #endif /* !UNIV_HOTBACKUP */
 /********************************************************************//**
 Gets the number of fields in the internal representation of an index,
@@ -1060,7 +1060,7 @@ dict_index_get_n_fields(
 	const dict_index_t*	index)	/*!< in: an internal
 					representation of index (in
 					the dictionary cache) */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /********************************************************************//**
 Gets the number of fields in the internal representation of an index
 that uniquely determine the position of an index entry in the index, if
@@ -1073,7 +1073,7 @@ dict_index_get_n_unique(
 /*====================*/
 	const dict_index_t*	index)	/*!< in: an internal representation
 					of index (in the dictionary cache) */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /********************************************************************//**
 Gets the number of fields in the internal representation of an index
 which uniquely determine the position of an index entry in the index, if
@@ -1085,7 +1085,7 @@ dict_index_get_n_unique_in_tree(
 /*============================*/
 	const dict_index_t*	index)	/*!< in: an internal representation
 					of index (in the dictionary cache) */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /********************************************************************//**
 Gets the number of user-defined ordering fields in the index. In the internal
 representation we add the row id to the ordering fields to make all indexes
@@ -1098,7 +1098,7 @@ dict_index_get_n_ordering_defined_by_user(
 /*======================================*/
 	const dict_index_t*	index)	/*!< in: an internal representation
 					of index (in the dictionary cache) */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 #ifdef UNIV_DEBUG
 /********************************************************************//**
 Gets the nth field of an index.
@@ -1109,7 +1109,7 @@ dict_index_get_nth_field(
 /*=====================*/
 	const dict_index_t*	index,	/*!< in: index */
 	ulint			pos)	/*!< in: position of field */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 #else /* UNIV_DEBUG */
 # define dict_index_get_nth_field(index, pos) ((index)->fields + (pos))
 #endif /* UNIV_DEBUG */
@@ -1122,7 +1122,7 @@ dict_index_get_nth_col(
 /*===================*/
 	const dict_index_t*	index,	/*!< in: index */
 	ulint			pos)	/*!< in: position of the field */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /********************************************************************//**
 Gets the column number of the nth field in an index.
 @return	column number */
@@ -1132,7 +1132,7 @@ dict_index_get_nth_col_no(
 /*======================*/
 	const dict_index_t*	index,	/*!< in: index */
 	ulint			pos)	/*!< in: position of the field */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /********************************************************************//**
 Looks for column n in an index.
 @return position in internal representation of the index;
@@ -1143,7 +1143,7 @@ dict_index_get_nth_col_pos(
 /*=======================*/
 	const dict_index_t*	index,	/*!< in: index */
 	ulint			n)	/*!< in: column number */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /********************************************************************//**
 Looks for column n in an index.
 @return position in internal representation of the index;
@@ -1156,7 +1156,7 @@ dict_index_get_nth_col_or_prefix_pos(
 	ulint			n,		/*!< in: column number */
 	ibool			inc_prefix)	/*!< in: TRUE=consider
 						column prefixes too */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /********************************************************************//**
 Returns TRUE if the index contains a column or a prefix of that column.
 @return	TRUE if contains the column or its prefix */
@@ -1166,7 +1166,7 @@ dict_index_contains_col_or_prefix(
 /*==============================*/
 	const dict_index_t*	index,	/*!< in: index */
 	ulint			n)	/*!< in: column number */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /********************************************************************//**
 Looks for a matching field in an index. The column has to be the same. The
 column in index must be complete, or must contain a prefix longer than the
@@ -1181,7 +1181,7 @@ dict_index_get_nth_field_pos(
 	const dict_index_t*	index,	/*!< in: index from which to search */
 	const dict_index_t*	index2,	/*!< in: index */
 	ulint			n)	/*!< in: field number in index2 */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /********************************************************************//**
 Looks for column n position in the clustered index.
 @return	position in internal representation of the clustered index */
@@ -1191,7 +1191,7 @@ dict_table_get_nth_col_pos(
 /*=======================*/
 	const dict_table_t*	table,	/*!< in: table */
 	ulint			n)	/*!< in: column number */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /********************************************************************//**
 Returns the position of a system column in an index.
 @return	position, ULINT_UNDEFINED if not contained */
@@ -1201,7 +1201,7 @@ dict_index_get_sys_col_pos(
 /*=======================*/
 	const dict_index_t*	index,	/*!< in: index */
 	ulint			type)	/*!< in: DATA_ROW_ID, ... */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*******************************************************************//**
 Adds a column to index. */
 UNIV_INTERN
@@ -1212,7 +1212,7 @@ dict_index_add_col(
 	const dict_table_t*	table,		/*!< in: table */
 	dict_col_t*		col,		/*!< in: column */
 	ulint			prefix_len)	/*!< in: column prefix length */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 #ifndef UNIV_HOTBACKUP
 /*******************************************************************//**
 Copies types of fields contained in index to tuple. */
@@ -1224,7 +1224,7 @@ dict_index_copy_types(
 	const dict_index_t*	index,		/*!< in: index */
 	ulint			n_fields)	/*!< in: number of
 						field types to copy */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 #endif /* !UNIV_HOTBACKUP */
 /*********************************************************************//**
 Gets the field column.
@@ -1234,7 +1234,7 @@ const dict_col_t*
 dict_field_get_col(
 /*===============*/
 	const dict_field_t*	field)	/*!< in: index field */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 #ifndef UNIV_HOTBACKUP
 /**********************************************************************//**
 Returns an index object if it is found in the dictionary cache.
@@ -1245,7 +1245,7 @@ dict_index_t*
 dict_index_get_if_in_cache_low(
 /*===========================*/
 	index_id_t	index_id)	/*!< in: index id */
-	__attribute__((warn_unused_result));
+	MY_ATTRIBUTE((warn_unused_result));
 #if defined UNIV_DEBUG || defined UNIV_BUF_DEBUG
 /**********************************************************************//**
 Returns an index object if it is found in the dictionary cache.
@@ -1255,7 +1255,7 @@ dict_index_t*
 dict_index_get_if_in_cache(
 /*=======================*/
 	index_id_t	index_id)	/*!< in: index id */
-	__attribute__((warn_unused_result));
+	MY_ATTRIBUTE((warn_unused_result));
 #endif /* UNIV_DEBUG || UNIV_BUF_DEBUG */
 #ifdef UNIV_DEBUG
 /**********************************************************************//**
@@ -1268,7 +1268,7 @@ dict_index_check_search_tuple(
 /*==========================*/
 	const dict_index_t*	index,	/*!< in: index tree */
 	const dtuple_t*		tuple)	/*!< in: tuple used in a search */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /** Whether and when to allow temporary index names */
 enum check_name {
 	/** Require all indexes to be complete. */
@@ -1288,7 +1288,7 @@ dict_table_check_for_dup_indexes(
 					in this table */
 	enum check_name		check)	/*!< in: whether and when to allow
 					temporary index names */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 #endif /* UNIV_DEBUG */
 /**********************************************************************//**
 Builds a node pointer out of a physical record and a page number.
@@ -1306,7 +1306,7 @@ dict_index_build_node_ptr(
 					created */
 	ulint			level)	/*!< in: level of rec in tree:
 					0 means leaf level */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /**********************************************************************//**
 Copies an initial segment of a physical record, long enough to specify an
 index entry uniquely.
@@ -1322,7 +1322,7 @@ dict_index_copy_rec_order_prefix(
 	byte**			buf,	/*!< in/out: memory buffer for the
 					copied prefix, or NULL */
 	ulint*			buf_size)/*!< in/out: buffer size */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /**********************************************************************//**
 Builds a typed data tuple out of a physical record.
 @return	own: data tuple */
@@ -1334,7 +1334,7 @@ dict_index_build_data_tuple(
 	rec_t*		rec,	/*!< in: record for which to build data tuple */
 	ulint		n_fields,/*!< in: number of data fields */
 	mem_heap_t*	heap)	/*!< in: memory heap where tuple created */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*********************************************************************//**
 Gets the space id of the root of the index tree.
 @return	space id */
@@ -1343,7 +1343,7 @@ ulint
 dict_index_get_space(
 /*=================*/
 	const dict_index_t*	index)	/*!< in: index */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*********************************************************************//**
 Sets the space id of the root of the index tree. */
 UNIV_INLINE
@@ -1352,7 +1352,7 @@ dict_index_set_space(
 /*=================*/
 	dict_index_t*	index,	/*!< in/out: index */
 	ulint		space)	/*!< in: space id */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*********************************************************************//**
 Gets the page number of the root of the index tree.
 @return	page number */
@@ -1361,7 +1361,7 @@ ulint
 dict_index_get_page(
 /*================*/
 	const dict_index_t*	tree)	/*!< in: index */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*********************************************************************//**
 Gets the read-write lock of the index tree.
 @return	read-write lock */
@@ -1370,7 +1370,7 @@ rw_lock_t*
 dict_index_get_lock(
 /*================*/
 	dict_index_t*	index)	/*!< in: index */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /********************************************************************//**
 Returns free space reserved for future updates of records. This is
 relevant only in the case of many consecutive inserts, as updates
@@ -1390,7 +1390,7 @@ enum online_index_status
 dict_index_get_online_status(
 /*=========================*/
 	const dict_index_t*	index)	/*!< in: secondary index */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /********************************************************************//**
 Sets the status of online index creation. */
 UNIV_INLINE
@@ -1399,7 +1399,7 @@ dict_index_set_online_status(
 /*=========================*/
 	dict_index_t*			index,	/*!< in/out: index */
 	enum online_index_status	status)	/*!< in: status */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /********************************************************************//**
 Determines if a secondary index is being or has been created online,
 or if the table is being rebuilt online, allowing concurrent modifications
@@ -1413,7 +1413,7 @@ bool
 dict_index_is_online_ddl(
 /*=====================*/
 	const dict_index_t*	index)	/*!< in: index */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*********************************************************************//**
 Calculates the minimum record length in an index. */
 UNIV_INTERN
@@ -1421,7 +1421,7 @@ ulint
 dict_index_calc_min_rec_len(
 /*========================*/
 	const dict_index_t*	index)	/*!< in: index */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /********************************************************************//**
 Reserves the dictionary system mutex for MySQL. */
 UNIV_INTERN
@@ -1485,7 +1485,7 @@ dict_tables_have_same_db(
 				dbname '/' tablename */
 	const char*	name2)	/*!< in: table name in the form
 				dbname '/' tablename */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*********************************************************************//**
 Removes an index from the cache */
 UNIV_INTERN
@@ -1494,7 +1494,7 @@ dict_index_remove_from_cache(
 /*=========================*/
 	dict_table_t*	table,	/*!< in/out: table */
 	dict_index_t*	index)	/*!< in, own: index */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /**********************************************************************//**
 Get index by name
 @return	index, NULL if does not exist */
@@ -1504,7 +1504,7 @@ dict_table_get_index_on_name(
 /*=========================*/
 	dict_table_t*	table,	/*!< in: table */
 	const char*	name)	/*!< in: name of the index to find */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /**********************************************************************//**
 In case there is more than one index with the same name return the index
 with the min(id).
@@ -1515,7 +1515,7 @@ dict_table_get_index_on_name_and_min_id(
 /*====================================*/
 	dict_table_t*	table,	/*!< in: table */
 	const char*	name)	/*!< in: name of the index to find */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /***************************************************************
 Check whether a column exists in an FTS index. */
 UNIV_INLINE
@@ -1526,7 +1526,7 @@ dict_table_is_fts_column(
 				the offset within the vector */
 	ib_vector_t*	indexes,/* in: vector containing only FTS indexes */
 	ulint		col_no)	/* in: col number to search for */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /**********************************************************************//**
 Move a table to the non LRU end of the LRU list. */
 UNIV_INTERN
@@ -1534,7 +1534,7 @@ void
 dict_table_move_from_lru_to_non_lru(
 /*================================*/
 	dict_table_t*	table)	/*!< in: table to move from LRU to non-LRU */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /**********************************************************************//**
 Move a table to the LRU list from the non-LRU list. */
 UNIV_INTERN
@@ -1542,7 +1542,7 @@ void
 dict_table_move_from_non_lru_to_lru(
 /*================================*/
 	dict_table_t*	table)	/*!< in: table to move from non-LRU to LRU */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /**********************************************************************//**
 Move to the most recently used segment of the LRU list. */
 UNIV_INTERN
@@ -1550,7 +1550,7 @@ void
 dict_move_to_mru(
 /*=============*/
 	dict_table_t*	table)	/*!< in: table to move to MRU */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /** Maximum number of columns in a foreign key constraint. Please Note MySQL
 has a much lower limit on the number of columns allowed in a foreign key
@@ -1674,7 +1674,7 @@ dict_table_schema_check(
 						!= DB_TABLE_NOT_FOUND is
 						returned */
 	size_t			errstr_sz)	/*!< in: errstr size */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /* @} */
 
 /*********************************************************************//**
@@ -1692,7 +1692,7 @@ dict_fs2utf8(
 	size_t		db_utf8_size,	/*!< in: dbname_utf8 size */
 	char*		table_utf8,	/*!< out: table name, e.g. aюbØc */
 	size_t		table_utf8_size)/*!< in: table_utf8 size */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /**********************************************************************//**
 Closes the data dictionary module. */
@@ -1709,7 +1709,7 @@ ulint
 dict_table_is_corrupted(
 /*====================*/
 	const dict_table_t*	table)	/*!< in: table */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 /**********************************************************************//**
 Check whether the index is corrupted.
@@ -1719,7 +1719,7 @@ ulint
 dict_index_is_corrupted(
 /*====================*/
 	const dict_index_t*	index)	/*!< in: index */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 #endif /* !UNIV_HOTBACKUP */
 /**********************************************************************//**
@@ -1732,7 +1732,7 @@ dict_set_corrupted(
 	dict_index_t*	index,	/*!< in/out: index */
 	trx_t*		trx,	/*!< in/out: transaction */
 	const char*	ctx)	/*!< in: context */
-	UNIV_COLD __attribute__((nonnull));
+	UNIV_COLD MY_ATTRIBUTE((nonnull));
 
 /**********************************************************************//**
 Flags an index corrupted in the data dictionary cache only. This
@@ -1744,7 +1744,7 @@ dict_set_corrupted_index_cache_only(
 /*================================*/
 	dict_index_t*	index,		/*!< in/out: index */
 	dict_table_t*	table)		/*!< in/out: table */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /**********************************************************************//**
 Flags a table with specified space_id corrupted in the table dictionary
@@ -1764,7 +1764,7 @@ bool
 dict_tf_is_valid(
 /*=============*/
 	ulint		flags)		/*!< in: table flags */
-	__attribute__((warn_unused_result));
+	MY_ATTRIBUTE((warn_unused_result));
 
 /********************************************************************//**
 Check if the tablespace for the table has been discarded.
@@ -1774,7 +1774,7 @@ bool
 dict_table_is_discarded(
 /*====================*/
 	const dict_table_t*	table)	/*!< in: table to check */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 
 /********************************************************************//**
 Check if it is a temporary table.
@@ -1784,7 +1784,7 @@ bool
 dict_table_is_temporary(
 /*====================*/
 	const dict_table_t*	table)	/*!< in: table to check */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 
 #ifndef UNIV_HOTBACKUP
 /*********************************************************************//**
@@ -1795,7 +1795,7 @@ void
 dict_index_zip_success(
 /*===================*/
 	dict_index_t*	index)	/*!< in/out: index to be updated. */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*********************************************************************//**
 This function should be called whenever a page compression attempt
 fails. Updates the compression padding information. */
@@ -1804,7 +1804,7 @@ void
 dict_index_zip_failure(
 /*===================*/
 	dict_index_t*	index)	/*!< in/out: index to be updated. */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*********************************************************************//**
 Return the optimal page size, for which page will likely compress.
 @return page size beyond which page may not compress*/
@@ -1814,7 +1814,7 @@ dict_index_zip_pad_optimal_page_size(
 /*=================================*/
 	dict_index_t*	index)	/*!< in: index for which page size
 				is requested */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*************************************************************//**
 Convert table flag to row format string.
 @return row format name */
--- a/storage/innobase/include/dict0dict.ic
+++ b/storage/innobase/include/dict0dict.ic
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1996, 2015, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1996, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -357,7 +357,7 @@ UNIV_INLINE
 ulint
 dict_table_get_n_sys_cols(
 /*======================*/
-	const dict_table_t*	table __attribute__((unused)))	/*!< in: table */
+	const dict_table_t*	table MY_ATTRIBUTE((unused)))	/*!< in: table */
 {
 	ut_ad(table);
 	ut_ad(table->magic_n == DICT_TABLE_MAGIC_N);
--- a/storage/innobase/include/dict0load.h
+++ b/storage/innobase/include/dict0load.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1996, 2013, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1996, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -243,7 +243,7 @@ dict_load_foreigns(
 	bool			check_charsets,	/*!< in: whether to check
 						charset compatibility */
 	dict_err_ignore_t	ignore_err)	/*!< in: error to be ignored */
-	__attribute__((nonnull(1), warn_unused_result));
+	MY_ATTRIBUTE((nonnull(1), warn_unused_result));
 /********************************************************************//**
 Prints to the standard output information on all tables found in the data
 dictionary system table. */
--- a/storage/innobase/include/dict0mem.h
+++ b/storage/innobase/include/dict0mem.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1996, 2015, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1996, 2016, Oracle and/or its affiliates. All Rights Reserved.
 Copyright (c) 2012, Facebook Inc.
 
 This program is free software; you can redistribute it and/or modify it under
@@ -276,7 +276,7 @@ dict_mem_table_add_col(
 	ulint		mtype,	/*!< in: main datatype */
 	ulint		prtype,	/*!< in: precise type */
 	ulint		len)	/*!< in: precision */
-	__attribute__((nonnull(1)));
+	MY_ATTRIBUTE((nonnull(1)));
 /**********************************************************************//**
 Renames a column of a table in the data dictionary cache. */
 UNIV_INTERN
@@ -287,7 +287,7 @@ dict_mem_table_col_rename(
 	unsigned	nth_col,/*!< in: column index */
 	const char*	from,	/*!< in: old column name */
 	const char*	to)	/*!< in: new column name */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /**********************************************************************//**
 This function populates a dict_col_t memory structure with
 supplied information. */
--- a/storage/innobase/include/dict0stats.h
+++ b/storage/innobase/include/dict0stats.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 2009, 2012, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 2009, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -77,7 +77,7 @@ dict_stats_set_persistent(
 	dict_table_t*	table,	/*!< in/out: table */
 	ibool		ps_on,	/*!< in: persistent stats explicitly enabled */
 	ibool		ps_off)	/*!< in: persistent stats explicitly disabled */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /*********************************************************************//**
 Check whether persistent statistics is enabled for a given table.
@@ -87,7 +87,7 @@ ibool
 dict_stats_is_persistent_enabled(
 /*=============================*/
 	const dict_table_t*	table)	/*!< in: table */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 /*********************************************************************//**
 Set the auto recalc flag for a given table (only honored for a persistent
@@ -127,7 +127,7 @@ void
 dict_stats_deinit(
 /*==============*/
 	dict_table_t*	table)	/*!< in/out: table */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /*********************************************************************//**
 Calculates new estimates for table and index statistics. The statistics
@@ -179,7 +179,7 @@ void
 dict_stats_update_for_index(
 /*========================*/
 	dict_index_t*	index)	/*!< in/out: index */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /*********************************************************************//**
 Renames a table in InnoDB persistent stats storage.
--- a/storage/innobase/include/dict0stats_bg.h
+++ b/storage/innobase/include/dict0stats_bg.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 2012, 2013, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 2012, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -74,7 +74,7 @@ bool
 dict_stats_stop_bg(
 /*===============*/
 	dict_table_t*	table)	/*!< in/out: table */
-	__attribute__((warn_unused_result));
+	MY_ATTRIBUTE((warn_unused_result));
 
 /*****************************************************************//**
 Wait until background stats thread has stopped using the specified table.
--- a/storage/innobase/include/dyn0dyn.h
+++ b/storage/innobase/include/dyn0dyn.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1996, 2013, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1996, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -48,7 +48,7 @@ dyn_array_create(
 /*=============*/
 	dyn_array_t*	arr)	/*!< in/out memory buffer of
 				size sizeof(dyn_array_t) */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /************************************************************//**
 Frees a dynamic array. */
 UNIV_INLINE
@@ -56,7 +56,7 @@ void
 dyn_array_free(
 /*===========*/
 	dyn_array_t*	arr)	/*!< in,own: dyn array */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*********************************************************************//**
 Makes room on top of a dyn array and returns a pointer to a buffer in it.
 After copying the elements, the caller must close the buffer using
@@ -69,7 +69,7 @@ dyn_array_open(
 	dyn_array_t*	arr,	/*!< in: dynamic array */
 	ulint		size)	/*!< in: size in bytes of the buffer; MUST be
 				smaller than DYN_ARRAY_DATA_SIZE! */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*********************************************************************//**
 Closes the buffer returned by dyn_array_open. */
 UNIV_INLINE
@@ -78,7 +78,7 @@ dyn_array_close(
 /*============*/
 	dyn_array_t*	arr,	/*!< in: dynamic array */
 	const byte*	ptr)	/*!< in: end of used space */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*********************************************************************//**
 Makes room on top of a dyn array and returns a pointer to
 the added element. The caller must copy the element to
@@ -90,7 +90,7 @@ dyn_array_push(
 /*===========*/
 	dyn_array_t*	arr,	/*!< in/out: dynamic array */
 	ulint		size)	/*!< in: size in bytes of the element */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /************************************************************//**
 Returns pointer to an element in dyn array.
 @return	pointer to element */
@@ -101,7 +101,7 @@ dyn_array_get_element(
 	const dyn_array_t*	arr,	/*!< in: dyn array */
 	ulint			pos)	/*!< in: position of element
 					in bytes from array start */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /************************************************************//**
 Returns the size of stored data in a dyn array.
 @return	data size in bytes */
@@ -110,7 +110,7 @@ ulint
 dyn_array_get_data_size(
 /*====================*/
 	const dyn_array_t*	arr)	/*!< in: dyn array */
-	__attribute__((nonnull, warn_unused_result, pure));
+	MY_ATTRIBUTE((nonnull, warn_unused_result, pure));
 /************************************************************//**
 Gets the first block in a dyn array.
 @param arr	dyn array
@@ -144,7 +144,7 @@ ulint
 dyn_block_get_used(
 /*===============*/
 	const dyn_block_t*	block)	/*!< in: dyn array block */
-	__attribute__((nonnull, warn_unused_result, pure));
+	MY_ATTRIBUTE((nonnull, warn_unused_result, pure));
 /********************************************************************//**
 Gets pointer to the start of data in a dyn array block.
 @return	pointer to data */
@@ -153,7 +153,7 @@ byte*
 dyn_block_get_data(
 /*===============*/
 	const dyn_block_t*	block)	/*!< in: dyn array block */
-	__attribute__((nonnull, warn_unused_result, pure));
+	MY_ATTRIBUTE((nonnull, warn_unused_result, pure));
 /********************************************************//**
 Pushes n bytes to a dyn array. */
 UNIV_INLINE
@@ -163,7 +163,7 @@ dyn_push_string(
 	dyn_array_t*	arr,	/*!< in/out: dyn array */
 	const byte*	str,	/*!< in: string to write */
 	ulint		len)	/*!< in: string length */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /*#################################################################*/
 
--- a/storage/innobase/include/dyn0dyn.ic
+++ b/storage/innobase/include/dyn0dyn.ic
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1996, 2013, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1996, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -36,7 +36,7 @@ dyn_block_t*
 dyn_array_add_block(
 /*================*/
 	dyn_array_t*	arr)	/*!< in/out: dyn array */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 /********************************************************************//**
 Gets the number of used bytes in a dyn array block.
--- a/storage/innobase/include/fil0fil.h
+++ b/storage/innobase/include/fil0fil.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1995, 2015, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1995, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -233,7 +233,7 @@ fil_node_create(
 	ulint		id,	/*!< in: space id where to append */
 	ibool		is_raw)	/*!< in: TRUE if a raw device or
 				a raw disk partition */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 #ifdef UNIV_LOG_ARCHIVE
 /****************************************************************//**
 Drops files from the start of a file space, so that its size is cut by
@@ -400,7 +400,7 @@ fil_read_first_page(
 						lsn values in data files */
 	lsn_t*		max_flushed_lsn)	/*!< out: max of flushed
 						lsn values in data files */
-	__attribute__((warn_unused_result));
+	MY_ATTRIBUTE((warn_unused_result));
 /*******************************************************************//**
 Increments the count of pending operation, if space is not being deleted.
 @return	TRUE if being deleted, and operation should be skipped */
@@ -488,7 +488,7 @@ dberr_t
 fil_discard_tablespace(
 /*===================*/
 	ulint	id)	/*!< in: space id */
-	__attribute__((warn_unused_result));
+	MY_ATTRIBUTE((warn_unused_result));
 #endif /* !UNIV_HOTBACKUP */
 
 /** Test if a tablespace file can be renamed to a new filepath by checking
@@ -597,7 +597,7 @@ fil_create_new_single_table_tablespace(
 	ulint		size)		/*!< in: the initial size of the
 					tablespace file in pages,
 					must be >= FIL_IBD_FILE_INITIAL_SIZE */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 #ifndef UNIV_HOTBACKUP
 /********************************************************************//**
 Tries to open a single-table tablespace and optionally checks the space id is
@@ -631,7 +631,7 @@ fil_open_single_table_tablespace(
 	const char*	tablename,	/*!< in: table name in the
 					databasename/tablename format */
 	const char*	filepath)	/*!< in: tablespace filepath */
-	__attribute__((nonnull(5), warn_unused_result));
+	MY_ATTRIBUTE((nonnull(5), warn_unused_result));
 
 #endif /* !UNIV_HOTBACKUP */
 /********************************************************************//**
@@ -780,7 +780,7 @@ fil_io(
 				appropriately aligned */
 	void*	message)	/*!< in: message for aio handler if non-sync
 				aio used, else ignored */
-	__attribute__((nonnull(8)));
+	MY_ATTRIBUTE((nonnull(8)));
 /**********************************************************************//**
 Waits for an aio operation to complete. This function is used to write the
 handler for completed requests. The aio array of pending requests is divided
@@ -975,7 +975,7 @@ fil_tablespace_iterate(
 	dict_table_t*		table,
 	ulint			n_io_buffers,
 	PageCallback&		callback)
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 /*******************************************************************//**
 Checks if a single-table tablespace for a given table name exists in the
@@ -999,7 +999,7 @@ fil_get_space_names(
 /*================*/
 	space_name_list_t&	space_name_list)
 				/*!< in/out: Vector for collecting the names. */
-	__attribute__((warn_unused_result));
+	MY_ATTRIBUTE((warn_unused_result));
 
 /** Generate redo log for swapping two .ibd files
 @param[in]	old_table	old table
@@ -1014,7 +1014,7 @@ fil_mtr_rename_log(
 	const dict_table_t*	new_table,
 	const char*		tmp_name,
 	mtr_t*			mtr)
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /*******************************************************************//**
 Finds the given page_no of the given space id from the double write buffer,
--- a/storage/innobase/include/fsp0fsp.h
+++ b/storage/innobase/include/fsp0fsp.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1995, 2012, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1995, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -510,7 +510,7 @@ fseg_alloc_free_page_general(
 				in which the page should be initialized.
 				If init_mtr!=mtr, but the page is already
 				latched in mtr, do not initialize the page. */
-	__attribute__((warn_unused_result, nonnull));
+	MY_ATTRIBUTE((warn_unused_result, nonnull));
 /**********************************************************************//**
 Reserves free pages from a tablespace. All mini-transactions which may
 use several pages from the tablespace should call this function beforehand
@@ -579,7 +579,7 @@ fseg_page_is_free(
 	fseg_header_t*	seg_header,	/*!< in: segment header */
 	ulint		space,		/*!< in: space id */
 	ulint		page)		/*!< in: page offset */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /**********************************************************************//**
 Frees part of a segment. This function can be used to free a segment
 by repeatedly calling this function in different mini-transactions.
@@ -675,7 +675,7 @@ bool
 fsp_flags_is_valid(
 /*===============*/
 	ulint	flags)		/*!< in: tablespace flags */
-	__attribute__((warn_unused_result, const));
+	MY_ATTRIBUTE((warn_unused_result, const));
 /********************************************************************//**
 Determine if the tablespace is compressed from dict_table_t::flags.
 @return	TRUE if compressed, FALSE if not compressed */
--- a/storage/innobase/include/fts0ast.h
+++ b/storage/innobase/include/fts0ast.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 2007, 2014, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 2007, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -200,7 +200,7 @@ fts_ast_visit(
 						and ignored processing an
 						operator, currently we only
 						ignore FTS_IGNORE operator */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*****************************************************************//**
 Process (nested) sub-expression, create a new result set to store the
 sub-expression result by processing nodes under current sub-expression
@@ -213,7 +213,7 @@ fts_ast_visit_sub_exp(
 	fts_ast_node_t*		node,		/*!< in: instance to traverse*/
 	fts_ast_callback	visitor,	/*!< in: callback */
 	void*			arg)		/*!< in: callback arg */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /********************************************************************
 Create a lex instance.*/
 UNIV_INTERN
@@ -223,7 +223,7 @@ fts_lexer_create(
 	ibool		boolean_mode,		/*!< in: query type */
 	const byte*	query,			/*!< in: query string */
 	ulint		query_len)		/*!< in: query string len */
-	__attribute__((nonnull, malloc, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, malloc, warn_unused_result));
 /********************************************************************
 Free an fts_lexer_t instance.*/
 UNIV_INTERN
@@ -232,7 +232,7 @@ fts_lexer_free(
 /*===========*/
 	fts_lexer_t*	fts_lexer)		/*!< in: lexer instance to
 						free */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /**
 Create an ast string object, with NUL-terminator, so the string
--- a/storage/innobase/include/fts0fts.h
+++ b/storage/innobase/include/fts0fts.h
@@ -411,7 +411,7 @@ fts_get_next_doc_id(
 /*================*/
 	const dict_table_t*	table,	/*!< in: table */
 	doc_id_t*		doc_id)	/*!< out: new document id */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*********************************************************************//**
 Update the next and last Doc ID in the CONFIG table to be the input
 "doc_id" value (+ 1). We would do so after each FTS index build or
@@ -424,7 +424,7 @@ fts_update_next_doc_id(
 	const dict_table_t*	table,		/*!< in: table */
 	const char*		table_name,	/*!< in: table name, or NULL */
 	doc_id_t		doc_id)		/*!< in: DOC ID to set */
-	__attribute__((nonnull(2)));
+	MY_ATTRIBUTE((nonnull(2)));
 
 /******************************************************************//**
 Create a new document id .
@@ -440,7 +440,7 @@ fts_create_doc_id(
 						current row that is being
 						inserted. */
 	mem_heap_t*	heap)			/*!< in: heap */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /******************************************************************//**
 Create a new fts_doc_ids_t.
 @return new fts_doc_ids_t. */
@@ -469,7 +469,7 @@ fts_trx_add_op(
 	fts_row_state	state,			/*!< in: state of the row */
 	ib_vector_t*	fts_indexes)		/*!< in: FTS indexes affected
 						(NULL=all) */
-	__attribute__((nonnull(1,2)));
+	MY_ATTRIBUTE((nonnull(1,2)));
 
 /******************************************************************//**
 Free an FTS trx. */
@@ -494,7 +494,7 @@ fts_create_common_tables(
 						index */
 	const char*	name,			/*!< in: table name */
 	bool		skip_doc_id_index)	/*!< in: Skip index on doc id */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /******************************************************************//**
 Wrapper function of fts_create_index_tables_low(), create auxiliary
 tables for an FTS index
@@ -506,7 +506,7 @@ fts_create_index_tables(
 	trx_t*			trx,		/*!< in: transaction handle */
 	const dict_index_t*	index)		/*!< in: the FTS index
 						instance */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /******************************************************************//**
 Creates the column specific ancillary tables needed for supporting an
 FTS index on the given table. row_mysql_lock_data_dictionary must have
@@ -522,7 +522,7 @@ fts_create_index_tables_low(
 						instance */
 	const char*	table_name,		/*!< in: the table name */
 	table_id_t	table_id)		/*!< in: the table id */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /******************************************************************//**
 Add the FTS document id hidden column. */
 UNIV_INTERN
@@ -531,7 +531,7 @@ fts_add_doc_id_column(
 /*==================*/
 	dict_table_t*	table,	/*!< in/out: Table with FTS index */
 	mem_heap_t*	heap)	/*!< in: temporary memory heap, or NULL */
-	__attribute__((nonnull(1)));
+	MY_ATTRIBUTE((nonnull(1)));
 
 /*********************************************************************//**
 Drops the ancillary tables needed for supporting an FTS index on the
@@ -545,7 +545,7 @@ fts_drop_tables(
 	trx_t*		trx,			/*!< in: transaction */
 	dict_table_t*	table)			/*!< in: table has the FTS
 						index */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /******************************************************************//**
 The given transaction is about to be committed; do whatever is necessary
 from the FTS system's POV.
@@ -555,7 +555,7 @@ dberr_t
 fts_commit(
 /*=======*/
 	trx_t*		trx)			/*!< in: transaction */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 /*******************************************************************//**
 FTS Query entry point.
@@ -572,7 +572,7 @@ fts_query(
 						in bytes */
 	fts_result_t**	result)			/*!< out: query result, to be
 						freed by the caller.*/
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 /******************************************************************//**
 Retrieve the FTS Relevance Ranking result for doc with doc_id
@@ -690,7 +690,7 @@ dberr_t
 fts_optimize_table(
 /*===============*/
 	dict_table_t*	table)			/*!< in: table to optimiza */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /**********************************************************************//**
 Startup the optimize thread and create the work queue. */
@@ -716,7 +716,7 @@ fts_drop_index_tables(
 /*==================*/
 	trx_t*		trx,			/*!< in: transaction */
 	dict_index_t*	index)			/*!< in: Index to drop */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 /******************************************************************//**
 Remove the table from the OPTIMIZER's list. We do wait for
@@ -757,7 +757,7 @@ fts_savepoint_take(
 	trx_t*		trx,			/*!< in: transaction */
 	fts_trx_t*	fts_trx,		/*!< in: fts transaction */
 	const char*	name)			/*!< in: savepoint name */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /**********************************************************************//**
 Refresh last statement savepoint. */
 UNIV_INTERN
@@ -765,7 +765,7 @@ void
 fts_savepoint_laststmt_refresh(
 /*===========================*/
 	trx_t*		trx)			/*!< in: transaction */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /**********************************************************************//**
 Release the savepoint data identified by  name. */
 UNIV_INTERN
@@ -834,7 +834,7 @@ fts_drop_index_split_tables(
 /*========================*/
 	trx_t*		trx,			/*!< in: transaction */
 	dict_index_t*	index)			/*!< in: fts instance */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 /** Run SYNC on the table, i.e., write out data from the cache to the
 FTS auxiliary INDEX table and clear the cache at the end.
@@ -1026,7 +1026,7 @@ fts_drop_index(
 	dict_table_t*	table,	/*!< in: Table where indexes are dropped */
 	dict_index_t*	index,	/*!< in: Index to be dropped */
 	trx_t*		trx)	/*!< in: Transaction for the drop */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /****************************************************************//**
 Rename auxiliary tables for all fts index for a table
--- a/storage/innobase/include/fts0priv.h
+++ b/storage/innobase/include/fts0priv.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 2011, 2013, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 2011, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -121,7 +121,7 @@ fts_parse_sql(
 	fts_table_t*	fts_table,	/*!< in: FTS aux table */
 	pars_info_t*	info,		/*!< in: info struct, or NULL */
 	const char*	sql)		/*!< in: SQL string to evaluate */
-	__attribute__((nonnull(3), malloc, warn_unused_result));
+	MY_ATTRIBUTE((nonnull(3), malloc, warn_unused_result));
 /******************************************************************//**
 Evaluate a parsed SQL statement
 @return DB_SUCCESS or error code */
@@ -131,7 +131,7 @@ fts_eval_sql(
 /*=========*/
 	trx_t*		trx,		/*!< in: transaction */
 	que_t*		graph)		/*!< in: Parsed statement */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /******************************************************************//**
 Construct the name of an ancillary FTS table for the given table.
 @return own: table name, must be freed with mem_free() */
@@ -141,7 +141,7 @@ fts_get_table_name(
 /*===============*/
 	const fts_table_t*
 			fts_table)	/*!< in: FTS aux table info */
-	__attribute__((nonnull, malloc, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, malloc, warn_unused_result));
 /******************************************************************//**
 Construct the column specification part of the SQL string for selecting the
 indexed FTS columns for the given table. Adds the necessary bound
@@ -164,7 +164,7 @@ fts_get_select_columns_str(
 	dict_index_t*	index,		/*!< in: FTS index */
 	pars_info_t*	info,		/*!< in/out: parser info */
 	mem_heap_t*	heap)		/*!< in: memory heap */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 /** define for fts_doc_fetch_by_doc_id() "option" value, defines whether
 we want to get Doc whose ID is equal to or greater or smaller than supplied
@@ -191,7 +191,7 @@ fts_doc_fetch_by_doc_id(
 			callback,	/*!< in: callback to read
 					records */
 	void*		arg)		/*!< in: callback arg */
-	__attribute__((nonnull(6)));
+	MY_ATTRIBUTE((nonnull(6)));
 
 /*******************************************************************//**
 Callback function for fetch that stores the text of an FTS document,
@@ -203,7 +203,7 @@ fts_query_expansion_fetch_doc(
 /*==========================*/
 	void*		row,		/*!< in: sel_node_t* */
 	void*		user_arg)	/*!< in: fts_doc_t* */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /********************************************************************
 Write out a single word's data as new entry/entries in the INDEX table.
 @return DB_SUCCESS if all OK. */
@@ -216,7 +216,7 @@ fts_write_node(
 	fts_table_t*	fts_table,	/*!< in: the FTS aux index */
 	fts_string_t*	word,		/*!< in: word in UTF-8 */
 	fts_node_t*	node)		/*!< in: node columns */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*******************************************************************//**
 Tokenize a document. */
 UNIV_INTERN
@@ -227,7 +227,7 @@ fts_tokenize_document(
 					tokenize */
 	fts_doc_t*	result)		/*!< out: if provided, save
 					result tokens here */
-	__attribute__((nonnull(1)));
+	MY_ATTRIBUTE((nonnull(1)));
 
 /*******************************************************************//**
 Continue to tokenize a document. */
@@ -241,7 +241,7 @@ fts_tokenize_document_next(
 					tokens from this tokenization */
 	fts_doc_t*	result)		/*!< out: if provided, save
 					result tokens here */
-	__attribute__((nonnull(1)));
+	MY_ATTRIBUTE((nonnull(1)));
 /******************************************************************//**
 Initialize a document. */
 UNIV_INTERN
@@ -249,7 +249,7 @@ void
 fts_doc_init(
 /*=========*/
 	fts_doc_t*	doc)		/*!< in: doc to initialize */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /******************************************************************//**
 Do a binary search for a doc id in the array
@@ -263,7 +263,7 @@ fts_bsearch(
 	int		lower,		/*!< in: lower bound of array*/
 	int		upper,		/*!< in: upper bound of array*/
 	doc_id_t	doc_id)		/*!< in: doc id to lookup */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /******************************************************************//**
 Free document. */
 UNIV_INTERN
@@ -271,7 +271,7 @@ void
 fts_doc_free(
 /*=========*/
 	fts_doc_t*	doc)		/*!< in: document */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /******************************************************************//**
 Free fts_optimizer_word_t instanace.*/
 UNIV_INTERN
@@ -279,7 +279,7 @@ void
 fts_word_free(
 /*==========*/
 	fts_word_t*	word)		/*!< in: instance to free.*/
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /******************************************************************//**
 Read the rows from the FTS inde
 @return DB_SUCCESS or error code */
@@ -293,7 +293,7 @@ fts_index_fetch_nodes(
 	const fts_string_t*
 			word,		/*!< in: the word to fetch */
 	fts_fetch_t*	fetch)		/*!< in: fetch callback.*/
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /******************************************************************//**
 Create a fts_optimizer_word_t instance.
 @return new instance */
@@ -304,7 +304,7 @@ fts_word_init(
 	fts_word_t*	word,		/*!< in: word to initialize */
 	byte*		utf8,		/*!< in: UTF-8 string */
 	ulint		len)		/*!< in: length of string in bytes */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /******************************************************************//**
 Compare two fts_trx_table_t instances, we actually compare the
 table id's here.
@@ -315,7 +315,7 @@ fts_trx_table_cmp(
 /*==============*/
 	const void*	v1,		/*!< in: id1 */
 	const void*	v2)		/*!< in: id2 */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /******************************************************************//**
 Compare a table id with a trx_table_t table id.
 @return < 0 if n1 < n2, 0 if n1 == n2, > 0 if n1 > n2 */
@@ -325,7 +325,7 @@ fts_trx_table_id_cmp(
 /*=================*/
 	const void*	p1,		/*!< in: id1 */
 	const void*	p2)		/*!< in: id2 */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /******************************************************************//**
 Commit a transaction.
 @return DB_SUCCESS if all OK */
@@ -334,7 +334,7 @@ dberr_t
 fts_sql_commit(
 /*===========*/
 	trx_t*		trx)		/*!< in: transaction */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /******************************************************************//**
 Rollback a transaction.
 @return DB_SUCCESS if all OK */
@@ -343,7 +343,7 @@ dberr_t
 fts_sql_rollback(
 /*=============*/
 	trx_t*		trx)		/*!< in: transaction */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /******************************************************************//**
 Parse an SQL string. %s is replaced with the table's id. Don't acquire
 the dict mutex
@@ -355,7 +355,7 @@ fts_parse_sql_no_dict_lock(
 	fts_table_t*	fts_table,	/*!< in: table with FTS index */
 	pars_info_t*	info,		/*!< in: parser info */
 	const char*	sql)		/*!< in: SQL string to evaluate */
-	__attribute__((nonnull(3), malloc, warn_unused_result));
+	MY_ATTRIBUTE((nonnull(3), malloc, warn_unused_result));
 /******************************************************************//**
 Get value from config table. The caller must ensure that enough
 space is allocated for value to hold the column contents
@@ -370,7 +370,7 @@ fts_config_get_value(
 					this parameter name */
 	fts_string_t*	value)		/*!< out: value read from
 					config table */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /******************************************************************//**
 Get value specific to an FTS index from the config table. The caller
 must ensure that enough space is allocated for value to hold the
@@ -386,7 +386,7 @@ fts_config_get_index_value(
 					this parameter name */
 	fts_string_t*	value)		/*!< out: value read from
 					config table */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /******************************************************************//**
 Set the value in the config table for name.
 @return DB_SUCCESS or error code */
@@ -400,7 +400,7 @@ fts_config_set_value(
 					this parameter name */
 	const fts_string_t*
 			value)		/*!< in: value to update */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /****************************************************************//**
 Set an ulint value in the config table.
 @return DB_SUCCESS if all OK else error code */
@@ -412,7 +412,7 @@ fts_config_set_ulint(
 	fts_table_t*	fts_table,	/*!< in: the indexed FTS table */
 	const char*	name,		/*!< in: param name */
 	ulint		int_value)	/*!< in: value */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /******************************************************************//**
 Set the value specific to an FTS index in the config table.
 @return DB_SUCCESS or error code */
@@ -426,7 +426,7 @@ fts_config_set_index_value(
 					this parameter name */
 	fts_string_t*	value)		/*!< out: value read from
 					config table */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /******************************************************************//**
 Increment the value in the config table for column name.
 @return DB_SUCCESS or error code */
@@ -439,7 +439,7 @@ fts_config_increment_value(
 	const char*	name,		/*!< in: increment config value
 					for this parameter name */
 	ulint		delta)		/*!< in: increment by this much */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /******************************************************************//**
 Increment the per index value in the config table for column name.
 @return DB_SUCCESS or error code */
@@ -452,7 +452,7 @@ fts_config_increment_index_value(
 	const char*	name,		/*!< in: increment config value
 					for this parameter name */
 	ulint		delta)		/*!< in: increment by this much */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /******************************************************************//**
 Get an ulint value from the config table.
 @return DB_SUCCESS or error code */
@@ -464,7 +464,7 @@ fts_config_get_index_ulint(
 	dict_index_t*	index,		/*!< in: FTS index */
 	const char*	name,		/*!< in: param name */
 	ulint*		int_value)	/*!< out: value */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /******************************************************************//**
 Set an ulint value int the config table.
 @return DB_SUCCESS or error code */
@@ -476,7 +476,7 @@ fts_config_set_index_ulint(
 	dict_index_t*	index,		/*!< in: FTS index */
 	const char*	name,		/*!< in: param name */
 	ulint		int_value)	/*!< in: value */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /******************************************************************//**
 Get an ulint value from the config table.
 @return DB_SUCCESS or error code */
@@ -488,7 +488,7 @@ fts_config_get_ulint(
 	fts_table_t*	fts_table,	/*!< in: the indexed FTS table */
 	const char*	name,		/*!< in: param name */
 	ulint*		int_value)	/*!< out: value */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /******************************************************************//**
 Search cache for word.
 @return the word node vector if found else NULL */
@@ -500,7 +500,7 @@ fts_cache_find_word(
 			index_cache,	/*!< in: cache to search */
 	const fts_string_t*
 			text)		/*!< in: word to search for */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /******************************************************************//**
 Check cache for deleted doc id.
 @return TRUE if deleted */
@@ -511,7 +511,7 @@ fts_cache_is_deleted_doc_id(
 	const fts_cache_t*
 			cache,		/*!< in: cache ito search */
 	doc_id_t	doc_id)		/*!< in: doc id to search for */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /******************************************************************//**
 Append deleted doc ids to vector and sort the vector. */
 UNIV_INTERN
@@ -546,7 +546,7 @@ fts_get_total_word_count(
 	trx_t*		trx,		/*!< in: transaction */
 	dict_index_t*	index,		/*!< in: for this index */
 	ulint*		total)		/*!< out: total words */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 #endif
 /******************************************************************//**
 Search the index specific cache for a particular FTS index.
@@ -559,7 +559,7 @@ fts_find_index_cache(
 			cache,		/*!< in: cache to search */
 	const dict_index_t*
 			index)		/*!< in: index to search for */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /******************************************************************//**
 Write the table id to the given buffer (including final NUL). Buffer must be
 at least FTS_AUX_MIN_TABLE_ID_LENGTH bytes long.
@@ -570,10 +570,10 @@ fts_write_object_id(
 /*================*/
 	ib_id_t		id,		/*!< in: a table/index id */
 	char*		str,		/*!< in: buffer to write the id to */
-	bool		hex_format __attribute__((unused)))
+	bool		hex_format MY_ATTRIBUTE((unused)))
 					/*!< in: true for fixed hex format,
 					false for old ambiguous format */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /******************************************************************//**
 Read the table id from the string generated by fts_write_object_id().
 @return TRUE if parse successful */
@@ -583,7 +583,7 @@ fts_read_object_id(
 /*===============*/
 	ib_id_t*	id,		/*!< out: a table id */
 	const char*	str)		/*!< in: buffer to read from */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /******************************************************************//**
 Get the table id.
 @return number of bytes written */
@@ -596,7 +596,7 @@ fts_get_table_id(
 	char*		table_id)	/*!< out: table id, must be at least
 					FTS_AUX_MIN_TABLE_ID_LENGTH bytes
 					long */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /******************************************************************//**
 Add the table to add to the OPTIMIZER's list. */
 UNIV_INTERN
@@ -604,7 +604,7 @@ void
 fts_optimize_add_table(
 /*===================*/
 	dict_table_t*	table)		/*!< in: table to add */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /******************************************************************//**
 Optimize a table. */
 UNIV_INTERN
@@ -612,7 +612,7 @@ void
 fts_optimize_do_table(
 /*==================*/
 	dict_table_t*	table)		/*!< in: table to optimize */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /******************************************************************//**
 Construct the prefix name of an FTS table.
 @return own: table name, must be freed with mem_free() */
@@ -622,7 +622,7 @@ fts_get_table_name_prefix(
 /*======================*/
 	const fts_table_t*
 			fts_table)	/*!< in: Auxiliary table type */
-	__attribute__((nonnull, malloc, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, malloc, warn_unused_result));
 /******************************************************************//**
 Add node positions. */
 UNIV_INTERN
@@ -633,7 +633,7 @@ fts_cache_node_add_positions(
 	fts_node_t*	node,		/*!< in: word node */
 	doc_id_t	doc_id,		/*!< in: doc id */
 	ib_vector_t*	positions)	/*!< in: fts_token_t::positions */
-	__attribute__((nonnull(2,4)));
+	MY_ATTRIBUTE((nonnull(2,4)));
 
 /******************************************************************//**
 Create the config table name for retrieving index specific value.
@@ -644,7 +644,7 @@ fts_config_create_index_param_name(
 /*===============================*/
 	const char*		param,		/*!< in: base name of param */
 	const dict_index_t*	index)		/*!< in: index for config */
-	__attribute__((nonnull, malloc, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, malloc, warn_unused_result));
 
 #ifndef UNIV_NONINL
 #include "fts0priv.ic"
--- a/storage/innobase/include/fts0priv.ic
+++ b/storage/innobase/include/fts0priv.ic
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 2011, 2013, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 2011, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -33,7 +33,7 @@ fts_write_object_id(
 /*================*/
 	ib_id_t		id,		/* in: a table/index id */
 	char*		str,		/* in: buffer to write the id to */
-	bool		hex_format __attribute__((unused)))
+	bool		hex_format MY_ATTRIBUTE((unused)))
 					/* in: true for fixed hex format,
 					false for old ambiguous format */
 {
--- a/storage/innobase/include/ha_prototypes.h
+++ b/storage/innobase/include/ha_prototypes.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 2006, 2015, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 2006, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -135,7 +135,7 @@ enum durability_properties
 thd_requested_durability(
 /*=====================*/
 	const THD* thd)	/*!< in: thread handle */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 /******************************************************************//**
 Returns true if the transaction this thread is processing has edited
@@ -176,7 +176,7 @@ innobase_mysql_cmp(
 	const unsigned char* b,		/*!< in: data field */
 	unsigned int	b_length)	/*!< in: data field length,
 					not UNIV_SQL_NULL */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /**************************************************************//**
 Converts a MySQL type to an InnoDB type. Note that this function returns
 the 'mtype' of InnoDB. InnoDB differentiates between MySQL's old <= 4.1
@@ -192,7 +192,7 @@ get_innobase_type_from_mysql_type(
 					and unsigned integer
 					types are 'unsigned types' */
 	const void*	field)		/*!< in: MySQL Field */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /******************************************************************//**
 Get the variable length bounds of the given character set. */
@@ -290,7 +290,7 @@ innobase_get_stmt(
 /*==============*/
 	THD*	thd,		/*!< in: MySQL thread handle */
 	size_t*	length)		/*!< out: length of the SQL statement */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /******************************************************************//**
 This function is used to find the storage length in bytes of the first n
 characters for prefix indexes using a multibyte character set. The function
@@ -316,7 +316,7 @@ enum icp_result
 innobase_index_cond(
 /*================*/
 	void*	file)	/*!< in/out: pointer to ha_innobase */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /******************************************************************//**
 Returns true if the thread supports XA,
 global value of innodb_supports_xa if thd is NULL.
@@ -452,7 +452,7 @@ innobase_format_name(
 	const char*	name,		/*!< in: index or table name
 					to format */
 	ibool		is_index_name)	/*!< in: index name */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /** Corresponds to Sql_condition:enum_warning_level. */
 enum ib_log_level_t {
@@ -482,7 +482,7 @@ ib_errf(
 	ib_uint32_t	code,		/*!< MySQL error code */
 	const char*	format,		/*!< printf format */
 	...)				/*!< Args */
-	__attribute__((format(printf, 4, 5)));
+	MY_ATTRIBUTE((format(printf, 4, 5)));
 
 /******************************************************************//**
 Use this when the args are passed to the format string from
@@ -513,7 +513,7 @@ ib_logf(
 	ib_log_level_t	level,		/*!< in: warning level */
 	const char*	format,		/*!< printf format */
 	...)				/*!< Args */
-	__attribute__((format(printf, 2, 3)));
+	MY_ATTRIBUTE((format(printf, 2, 3)));
 
 /******************************************************************//**
 Returns the NUL terminated value of glob_hostname.
@@ -559,7 +559,7 @@ innobase_next_autoinc(
 	ulonglong	step,		/*!< in: AUTOINC increment step */
 	ulonglong	offset,		/*!< in: AUTOINC offset */
 	ulonglong	max_value)	/*!< in: max value for type */
-	__attribute__((pure, warn_unused_result));
+	MY_ATTRIBUTE((pure, warn_unused_result));
 
 /********************************************************************//**
 Get the upper limit of the MySQL integral and floating-point type.
@@ -569,7 +569,7 @@ ulonglong
 innobase_get_int_col_max_value(
 /*===========================*/
 	const Field*	field)	/*!< in: MySQL field */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 
 /**********************************************************************
 Check if the length of the identifier exceeds the maximum allowed.
--- a/storage/innobase/include/handler0alter.h
+++ b/storage/innobase/include/handler0alter.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 2005, 2013, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 2005, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -32,7 +32,7 @@ innobase_rec_to_mysql(
 	const dict_index_t*	index,	/*!< in: index */
 	const ulint*		offsets)/*!< in: rec_get_offsets(
 					rec, index, ...) */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /*************************************************************//**
 Copies an InnoDB index entry to table->record[0]. */
@@ -43,7 +43,7 @@ innobase_fields_to_mysql(
 	struct TABLE*		table,	/*!< in/out: MySQL table */
 	const dict_index_t*	index,	/*!< in: InnoDB index */
 	const dfield_t*		fields)	/*!< in: InnoDB index fields */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /*************************************************************//**
 Copies an InnoDB row to table->record[0]. */
@@ -54,7 +54,7 @@ innobase_row_to_mysql(
 	struct TABLE*		table,	/*!< in/out: MySQL table */
 	const dict_table_t*	itab,	/*!< in: InnoDB table */
 	const dtuple_t*		row)	/*!< in: InnoDB row */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /*************************************************************//**
 Resets table->record[0]. */
@@ -63,7 +63,7 @@ void
 innobase_rec_reset(
 /*===============*/
 	struct TABLE*		table)		/*!< in/out: MySQL table */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /** Generate the next autoinc based on a snapshot of the session
 auto_increment_increment and auto_increment_offset variables. */
--- a/storage/innobase/include/ibuf0ibuf.h
+++ b/storage/innobase/include/ibuf0ibuf.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1997, 2013, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1997, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -118,7 +118,7 @@ void
 ibuf_mtr_start(
 /*===========*/
 	mtr_t*	mtr)	/*!< out: mini-transaction */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /***************************************************************//**
 Commits an insert buffer mini-transaction. */
 UNIV_INLINE
@@ -126,7 +126,7 @@ void
 ibuf_mtr_commit(
 /*============*/
 	mtr_t*	mtr)	/*!< in/out: mini-transaction */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*********************************************************************//**
 Initializes an ibuf bitmap page. */
 UNIV_INTERN
@@ -252,7 +252,7 @@ ibool
 ibuf_inside(
 /*========*/
 	const mtr_t*	mtr)	/*!< in: mini-transaction */
-	__attribute__((nonnull, pure));
+	MY_ATTRIBUTE((nonnull, pure));
 /***********************************************************************//**
 Checks if a page address is an ibuf bitmap page (level 3 page) address.
 @return	TRUE if a bitmap page */
@@ -285,7 +285,7 @@ ibuf_page_low(
 				is not one of the fixed address ibuf
 				pages, or NULL, in which case a new
 				transaction is created. */
-	__attribute__((warn_unused_result));
+	MY_ATTRIBUTE((warn_unused_result));
 #ifdef UNIV_DEBUG
 /** Checks if a page is a level 2 or 3 page in the ibuf hierarchy of
 pages.  Must not be called when recv_no_ibuf_operations==TRUE.
@@ -445,7 +445,7 @@ ibuf_check_bitmap_on_import(
 /*========================*/
 	const trx_t*	trx,		/*!< in: transaction */
 	ulint		space_id)	/*!< in: tablespace identifier */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 #define IBUF_HEADER_PAGE_NO	FSP_IBUF_HEADER_PAGE_NO
 #define IBUF_TREE_ROOT_PAGE_NO	FSP_IBUF_TREE_ROOT_PAGE_NO
--- a/storage/innobase/include/lock0lock.h
+++ b/storage/innobase/include/lock0lock.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1996, 2014, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1996, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -266,7 +266,7 @@ lock_rec_expl_exist_on_page(
 /*========================*/
 	ulint	space,	/*!< in: space id */
 	ulint	page_no)/*!< in: page number */
-	__attribute__((warn_unused_result));
+	MY_ATTRIBUTE((warn_unused_result));
 /*********************************************************************//**
 Checks if locks of other transactions prevent an immediate insert of
 a record. If they do, first tests if the query thread should anyway
@@ -289,7 +289,7 @@ lock_rec_insert_check_and_lock(
 				inserted record maybe should inherit
 				LOCK_GAP type locks from the successor
 				record */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*********************************************************************//**
 Checks if locks of other transactions prevent an immediate modify (update,
 delete mark, or delete unmark) of a clustered index record. If they do,
@@ -310,7 +310,7 @@ lock_clust_rec_modify_check_and_lock(
 	dict_index_t*		index,	/*!< in: clustered index */
 	const ulint*		offsets,/*!< in: rec_get_offsets(rec, index) */
 	que_thr_t*		thr)	/*!< in: query thread */
-	__attribute__((warn_unused_result, nonnull));
+	MY_ATTRIBUTE((warn_unused_result, nonnull));
 /*********************************************************************//**
 Checks if locks of other transactions prevent an immediate modify
 (delete mark or delete unmark) of a secondary index record.
@@ -331,7 +331,7 @@ lock_sec_rec_modify_check_and_lock(
 	que_thr_t*	thr,	/*!< in: query thread
 				(can be NULL if BTR_NO_LOCKING_FLAG) */
 	mtr_t*		mtr)	/*!< in/out: mini-transaction */
-	__attribute__((warn_unused_result, nonnull(2,3,4,6)));
+	MY_ATTRIBUTE((warn_unused_result, nonnull(2,3,4,6)));
 /*********************************************************************//**
 Like lock_clust_rec_read_check_and_lock(), but reads a
 secondary index record.
@@ -418,7 +418,7 @@ lock_clust_rec_read_check_and_lock_alt(
 	ulint			gap_mode,/*!< in: LOCK_ORDINARY, LOCK_GAP, or
 					LOCK_REC_NOT_GAP */
 	que_thr_t*		thr)	/*!< in: query thread */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*********************************************************************//**
 Checks that a record is seen in a consistent read.
 @return true if sees, or false if an earlier version of the record
@@ -450,7 +450,7 @@ lock_sec_rec_cons_read_sees(
 					should be read or passed over
 					by a read cursor */
 	const read_view_t*	view)	/*!< in: consistent read view */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*********************************************************************//**
 Locks the specified database table in the mode given. If the lock cannot
 be granted immediately, the query thread is put to wait.
@@ -465,7 +465,7 @@ lock_table(
 				in dictionary cache */
 	enum lock_mode	mode,	/*!< in: lock mode */
 	que_thr_t*	thr)	/*!< in: query thread */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*********************************************************************//**
 Creates a table IX lock object for a resurrected transaction. */
 UNIV_INTERN
@@ -520,7 +520,7 @@ lock_rec_fold(
 /*==========*/
 	ulint	space,	/*!< in: space */
 	ulint	page_no)/*!< in: page number */
-	__attribute__((const));
+	MY_ATTRIBUTE((const));
 /*********************************************************************//**
 Calculates the hash value of a page file address: used in inserting or
 searching for a lock in the hash table.
@@ -570,7 +570,7 @@ lock_is_table_exclusive(
 /*====================*/
 	const dict_table_t*	table,	/*!< in: table */
 	const trx_t*		trx)	/*!< in: transaction */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*********************************************************************//**
 Checks if a lock request lock1 has to wait for request lock2.
 @return	TRUE if lock1 has to wait for lock2 to be removed */
@@ -594,7 +594,7 @@ lock_report_trx_id_insanity(
 	dict_index_t*	index,		/*!< in: index */
 	const ulint*	offsets,	/*!< in: rec_get_offsets(rec, index) */
 	trx_id_t	max_trx_id)	/*!< in: trx_sys_get_max_trx_id() */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*********************************************************************//**
 Prints info of a table lock. */
 UNIV_INTERN
@@ -621,7 +621,7 @@ lock_print_info_summary(
 /*====================*/
 	FILE*	file,	/*!< in: file where to print */
 	ibool   nowait)	/*!< in: whether to wait for the lock mutex */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*********************************************************************//**
 Prints info of locks for each transaction. This function assumes that the
 caller holds the lock mutex and more importantly it will release the lock
@@ -641,7 +641,7 @@ ulint
 lock_number_of_rows_locked(
 /*=======================*/
 	const trx_lock_t*	trx_lock)	/*!< in: transaction locks */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 /*******************************************************************//**
 Gets the type of a lock. Non-inline version for using outside of the
@@ -799,7 +799,7 @@ dberr_t
 lock_trx_handle_wait(
 /*=================*/
 	trx_t*	trx)	/*!< in/out: trx lock state */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*********************************************************************//**
 Get the number of locks on a table.
 @return number of locks */
@@ -808,7 +808,7 @@ ulint
 lock_table_get_n_locks(
 /*===================*/
 	const dict_table_t*	table)	/*!< in: table */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 #ifdef UNIV_DEBUG
 /*********************************************************************//**
 Checks that a transaction id is sensible, i.e., not in the future.
@@ -821,7 +821,7 @@ lock_check_trx_id_sanity(
 	const rec_t*	rec,		/*!< in: user record */
 	dict_index_t*	index,		/*!< in: index */
 	const ulint*	offsets)	/*!< in: rec_get_offsets(rec, index) */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*******************************************************************//**
 Check if the transaction holds any locks on the sys tables
 or its records.
@@ -831,7 +831,7 @@ const lock_t*
 lock_trx_has_sys_table_locks(
 /*=========================*/
 	const trx_t*	trx)	/*!< in: transaction to check */
-	__attribute__((warn_unused_result));
+	MY_ATTRIBUTE((warn_unused_result));
 
 /*******************************************************************//**
 Check if the transaction holds an exclusive lock on a record.
@@ -844,7 +844,7 @@ lock_trx_has_rec_x_lock(
 	const dict_table_t*	table,	/*!< in: table to check */
 	const buf_block_t*	block,	/*!< in: buffer block of the record */
 	ulint			heap_no)/*!< in: record heap number */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 #endif /* UNIV_DEBUG */
 
 /** Lock modes and types */
--- a/storage/innobase/include/lock0priv.h
+++ b/storage/innobase/include/lock0priv.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 2007, 2011, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 2007, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -117,7 +117,7 @@ lock_clust_rec_some_has_impl(
 	const rec_t*		rec,	/*!< in: user record */
 	const dict_index_t*	index,	/*!< in: clustered index */
 	const ulint*		offsets)/*!< in: rec_get_offsets(rec, index) */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 #ifndef UNIV_NONINL
 #include "lock0priv.ic"
--- a/storage/innobase/include/log0recv.h
+++ b/storage/innobase/include/log0recv.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1997, 2014, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1997, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -51,7 +51,7 @@ recv_read_checkpoint_info_for_backup(
 	lsn_t*		first_header_lsn)
 				/*!< out: lsn of of the start of the
 				first log file */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*******************************************************************//**
 Scans the log segment and n_bytes_scanned is set to the length of valid
 log scanned. */
--- a/storage/innobase/include/mach0data.h
+++ b/storage/innobase/include/mach0data.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1995, 2009, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1995, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -53,7 +53,7 @@ ulint
 mach_read_from_1(
 /*=============*/
 	const byte*	b)	/*!< in: pointer to byte */
-	__attribute__((nonnull, pure));
+	MY_ATTRIBUTE((nonnull, pure));
 /*******************************************************//**
 The following function is used to store data in two consecutive
 bytes. We store the most significant byte to the lower address. */
@@ -72,7 +72,7 @@ ulint
 mach_read_from_2(
 /*=============*/
 	const byte*	b)	/*!< in: pointer to two bytes */
-	__attribute__((nonnull, pure));
+	MY_ATTRIBUTE((nonnull, pure));
 
 /********************************************************//**
 The following function is used to convert a 16-bit data item
@@ -84,7 +84,7 @@ uint16
 mach_encode_2(
 /*==========*/
 	ulint	n)	/*!< in: integer in machine-dependent format */
-	__attribute__((const));
+	MY_ATTRIBUTE((const));
 /********************************************************//**
 The following function is used to convert a 16-bit data item
 from the canonical format, for fast bytewise equality test
@@ -95,7 +95,7 @@ ulint
 mach_decode_2(
 /*==========*/
 	uint16	n)	/*!< in: 16-bit integer in canonical format */
-	__attribute__((const));
+	MY_ATTRIBUTE((const));
 /*******************************************************//**
 The following function is used to store data in 3 consecutive
 bytes. We store the most significant byte to the lowest address. */
@@ -114,7 +114,7 @@ ulint
 mach_read_from_3(
 /*=============*/
 	const byte*	b)	/*!< in: pointer to 3 bytes */
-	__attribute__((nonnull, pure));
+	MY_ATTRIBUTE((nonnull, pure));
 /*******************************************************//**
 The following function is used to store data in four consecutive
 bytes. We store the most significant byte to the lowest address. */
@@ -133,7 +133,7 @@ ulint
 mach_read_from_4(
 /*=============*/
 	const byte*	b)	/*!< in: pointer to four bytes */
-	__attribute__((nonnull, pure));
+	MY_ATTRIBUTE((nonnull, pure));
 /*********************************************************//**
 Writes a ulint in a compressed form (1..5 bytes).
 @return	stored size in bytes */
@@ -151,7 +151,7 @@ ulint
 mach_get_compressed_size(
 /*=====================*/
 	ulint	n)	/*!< in: ulint integer to be stored */
-	__attribute__((const));
+	MY_ATTRIBUTE((const));
 /*********************************************************//**
 Reads a ulint in a compressed form.
 @return	read integer */
@@ -160,7 +160,7 @@ ulint
 mach_read_compressed(
 /*=================*/
 	const byte*	b)	/*!< in: pointer to memory from where to read */
-	__attribute__((nonnull, pure));
+	MY_ATTRIBUTE((nonnull, pure));
 /*******************************************************//**
 The following function is used to store data in 6 consecutive
 bytes. We store the most significant byte to the lowest address. */
@@ -179,7 +179,7 @@ ib_uint64_t
 mach_read_from_6(
 /*=============*/
 	const byte*	b)	/*!< in: pointer to 6 bytes */
-	__attribute__((nonnull, pure));
+	MY_ATTRIBUTE((nonnull, pure));
 /*******************************************************//**
 The following function is used to store data in 7 consecutive
 bytes. We store the most significant byte to the lowest address. */
@@ -198,7 +198,7 @@ ib_uint64_t
 mach_read_from_7(
 /*=============*/
 	const byte*	b)	/*!< in: pointer to 7 bytes */
-	__attribute__((nonnull, pure));
+	MY_ATTRIBUTE((nonnull, pure));
 /*******************************************************//**
 The following function is used to store data in 8 consecutive
 bytes. We store the most significant byte to the lowest address. */
@@ -217,7 +217,7 @@ ib_uint64_t
 mach_read_from_8(
 /*=============*/
 	const byte*	b)	/*!< in: pointer to 8 bytes */
-	__attribute__((nonnull, pure));
+	MY_ATTRIBUTE((nonnull, pure));
 /*********************************************************//**
 Writes a 64-bit integer in a compressed form (5..9 bytes).
 @return	size in bytes */
@@ -243,7 +243,7 @@ ib_uint64_t
 mach_ull_read_compressed(
 /*=====================*/
 	const byte*	b)	/*!< in: pointer to memory from where to read */
-	__attribute__((nonnull, pure));
+	MY_ATTRIBUTE((nonnull, pure));
 /*********************************************************//**
 Writes a 64-bit integer in a compressed form (1..11 bytes).
 @return	size in bytes */
@@ -261,7 +261,7 @@ ulint
 mach_ull_get_much_compressed_size(
 /*==============================*/
 	ib_uint64_t	n)	/*!< in: 64-bit integer to be stored */
-	__attribute__((const));
+	MY_ATTRIBUTE((const));
 /*********************************************************//**
 Reads a 64-bit integer in a compressed form.
 @return	the value read */
@@ -270,7 +270,7 @@ ib_uint64_t
 mach_ull_read_much_compressed(
 /*==========================*/
 	const byte*	b)	/*!< in: pointer to memory from where to read */
-	__attribute__((nonnull, pure));
+	MY_ATTRIBUTE((nonnull, pure));
 /*********************************************************//**
 Reads a ulint in a compressed form if the log record fully contains it.
 @return	pointer to end of the stored field, NULL if not complete */
@@ -301,7 +301,7 @@ double
 mach_double_read(
 /*=============*/
 	const byte*	b)	/*!< in: pointer to memory from where to read */
-	__attribute__((nonnull, pure));
+	MY_ATTRIBUTE((nonnull, pure));
 /*********************************************************//**
 Writes a double. It is stored in a little-endian format. */
 UNIV_INLINE
@@ -318,7 +318,7 @@ float
 mach_float_read(
 /*============*/
 	const byte*	b)	/*!< in: pointer to memory from where to read */
-	__attribute__((nonnull, pure));
+	MY_ATTRIBUTE((nonnull, pure));
 /*********************************************************//**
 Writes a float. It is stored in a little-endian format. */
 UNIV_INLINE
@@ -336,7 +336,7 @@ mach_read_from_n_little_endian(
 /*===========================*/
 	const byte*	buf,		/*!< in: from where to read */
 	ulint		buf_size)	/*!< in: from how many bytes to read */
-	__attribute__((nonnull, pure));
+	MY_ATTRIBUTE((nonnull, pure));
 /*********************************************************//**
 Writes a ulint in the little-endian format. */
 UNIV_INLINE
@@ -354,7 +354,7 @@ ulint
 mach_read_from_2_little_endian(
 /*===========================*/
 	const byte*	buf)		/*!< in: from where to read */
-	__attribute__((nonnull, pure));
+	MY_ATTRIBUTE((nonnull, pure));
 /*********************************************************//**
 Writes a ulint in the little-endian format. */
 UNIV_INLINE
--- a/storage/innobase/include/mem0mem.h
+++ b/storage/innobase/include/mem0mem.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1994, 2010, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1994, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -353,7 +353,7 @@ mem_heap_printf(
 /*============*/
 	mem_heap_t*	heap,	/*!< in: memory heap */
 	const char*	format,	/*!< in: format string */
-	...) __attribute__ ((format (printf, 2, 3)));
+	...) MY_ATTRIBUTE ((format (printf, 2, 3)));
 
 #ifdef MEM_PERIODIC_CHECK
 /******************************************************************//**
--- a/storage/innobase/include/mem0mem.ic
+++ b/storage/innobase/include/mem0mem.ic
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1994, 2010, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1994, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -476,9 +476,9 @@ void
 mem_heap_free_func(
 /*===============*/
 	mem_heap_t*	heap,		/*!< in, own: heap to be freed */
-	const char*	file_name __attribute__((unused)),
+	const char*	file_name MY_ATTRIBUTE((unused)),
 					/*!< in: file name where freed */
-	ulint		line  __attribute__((unused)))
+	ulint		line  MY_ATTRIBUTE((unused)))
 {
 	mem_block_t*	block;
 	mem_block_t*	prev_block;
--- a/storage/innobase/include/mtr0mtr.h
+++ b/storage/innobase/include/mtr0mtr.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1995, 2013, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1995, 2016, Oracle and/or its affiliates. All Rights Reserved.
 Copyright (c) 2012, Facebook Inc.
 
 This program is free software; you can redistribute it and/or modify it under
@@ -207,7 +207,7 @@ void
 mtr_start(
 /*======*/
 	mtr_t*	mtr)	/*!< out: mini-transaction */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /***************************************************************//**
 Commits a mini-transaction. */
 UNIV_INTERN
@@ -215,7 +215,7 @@ void
 mtr_commit(
 /*=======*/
 	mtr_t*	mtr)	/*!< in/out: mini-transaction */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /**********************************************************//**
 Sets and returns a savepoint in mtr.
 @return	savepoint */
@@ -308,7 +308,7 @@ mtr_memo_release(
 	mtr_t*	mtr,	/*!< in/out: mini-transaction */
 	void*	object,	/*!< in: object */
 	ulint	type)	/*!< in: object type: MTR_MEMO_S_LOCK, ... */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 #ifdef UNIV_DEBUG
 # ifndef UNIV_HOTBACKUP
 /**********************************************************//**
@@ -321,7 +321,7 @@ mtr_memo_contains(
 	mtr_t*		mtr,	/*!< in: mtr */
 	const void*	object,	/*!< in: object to search */
 	ulint		type)	/*!< in: type of object */
-	__attribute__((warn_unused_result, nonnull));
+	MY_ATTRIBUTE((warn_unused_result, nonnull));
 
 /**********************************************************//**
 Checks if memo contains the given page.
--- a/storage/innobase/include/mtr0mtr.ic
+++ b/storage/innobase/include/mtr0mtr.ic
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1995, 2013, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1995, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -37,7 +37,7 @@ ibool
 mtr_block_dirtied(
 /*==============*/
 	const buf_block_t*	block)	/*!< in: block being x-fixed */
-	__attribute__((nonnull,warn_unused_result));
+	MY_ATTRIBUTE((nonnull,warn_unused_result));
 
 /***************************************************************//**
 Starts a mini-transaction. */
--- a/storage/innobase/include/os0file.h
+++ b/storage/innobase/include/os0file.h
@@ -1,6 +1,6 @@
 /***********************************************************************
 
-Copyright (c) 1995, 2015, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1995, 2016, Oracle and/or its affiliates. All Rights Reserved.
 Copyright (c) 2009, Percona Inc.
 
 Portions of this file contain modifications contributed and copyrighted
@@ -529,7 +529,7 @@ os_file_create_simple_no_error_handling_func(
 				OS_FILE_READ_ALLOW_DELETE; the last option is
 				used by a backup program reading the file */
 	ibool*		success)/*!< out: TRUE if succeed, FALSE if error */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /****************************************************************//**
 Tries to disable OS caching on an opened file descriptor. */
 UNIV_INTERN
@@ -563,7 +563,7 @@ os_file_create_func(
 				function source code for the exact rules */
 	ulint		type,	/*!< in: OS_DATA_FILE or OS_LOG_FILE */
 	ibool*		success)/*!< out: TRUE if succeed, FALSE if error */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /***********************************************************************//**
 Deletes a file. The file has to be closed before calling this.
 @return	TRUE if success */
@@ -629,7 +629,7 @@ pfs_os_file_create_simple_func(
 	ibool*		success,/*!< out: TRUE if succeed, FALSE if error */
 	const char*	src_file,/*!< in: file name where func invoked */
 	ulint		src_line)/*!< in: line where the func invoked */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 /****************************************************************//**
 NOTE! Please use the corresponding macro
@@ -654,7 +654,7 @@ pfs_os_file_create_simple_no_error_handling_func(
 	ibool*		success,/*!< out: TRUE if succeed, FALSE if error */
 	const char*	src_file,/*!< in: file name where func invoked */
 	ulint		src_line)/*!< in: line where the func invoked */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 /****************************************************************//**
 NOTE! Please use the corresponding macro os_file_create(), not directly
@@ -682,7 +682,7 @@ pfs_os_file_create_func(
 	ibool*		success,/*!< out: TRUE if succeed, FALSE if error */
 	const char*	src_file,/*!< in: file name where func invoked */
 	ulint		src_line)/*!< in: line where the func invoked */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 /***********************************************************************//**
 NOTE! Please use the corresponding macro os_file_close(), not directly
@@ -861,7 +861,7 @@ os_offset_t
 os_file_get_size(
 /*=============*/
 	os_file_t	file)	/*!< in: handle to a file */
-	__attribute__((warn_unused_result));
+	MY_ATTRIBUTE((warn_unused_result));
 /***********************************************************************//**
 Write the specified number of zeros to a newly created file.
 @return	TRUE if success */
@@ -873,7 +873,7 @@ os_file_set_size(
 				null-terminated string */
 	os_file_t	file,	/*!< in: handle to a file */
 	os_offset_t	size)	/*!< in: file size */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /***********************************************************************//**
 Truncates a file at its current position.
 @return	TRUE if success */
--- a/storage/innobase/include/os0thread.h
+++ b/storage/innobase/include/os0thread.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1995, 2011, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1995, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -125,7 +125,7 @@ os_thread_exit(
 /*===========*/
 	void*	exit_value)	/*!< in: exit value; in Windows this void*
 				is cast as a DWORD */
-	UNIV_COLD __attribute__((noreturn));
+	UNIV_COLD MY_ATTRIBUTE((noreturn));
 /*****************************************************************//**
 Returns the thread identifier of current thread.
 @return	current thread identifier */
--- a/storage/innobase/include/page0cur.h
+++ b/storage/innobase/include/page0cur.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1994, 2013, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1994, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -180,7 +180,7 @@ page_cur_tuple_insert(
 	mem_heap_t**	heap,	/*!< in/out: pointer to memory heap, or NULL */
 	ulint		n_ext,	/*!< in: number of externally stored columns */
 	mtr_t*		mtr)	/*!< in: mini-transaction handle, or NULL */
-	__attribute__((nonnull(1,2,3,4,5), warn_unused_result));
+	MY_ATTRIBUTE((nonnull(1,2,3,4,5), warn_unused_result));
 #endif /* !UNIV_HOTBACKUP */
 /***********************************************************//**
 Inserts a record next to page cursor. Returns pointer to inserted record if
@@ -218,7 +218,7 @@ page_cur_insert_rec_low(
 	const rec_t*	rec,	/*!< in: pointer to a physical record */
 	ulint*		offsets,/*!< in/out: rec_get_offsets(rec, index) */
 	mtr_t*		mtr)	/*!< in: mini-transaction handle, or NULL */
-	__attribute__((nonnull(1,2,3,4), warn_unused_result));
+	MY_ATTRIBUTE((nonnull(1,2,3,4), warn_unused_result));
 /***********************************************************//**
 Inserts a record next to page cursor on a compressed and uncompressed
 page. Returns pointer to inserted record if succeed, i.e.,
@@ -240,7 +240,7 @@ page_cur_insert_rec_zip(
 	const rec_t*	rec,	/*!< in: pointer to a physical record */
 	ulint*		offsets,/*!< in/out: rec_get_offsets(rec, index) */
 	mtr_t*		mtr)	/*!< in: mini-transaction handle, or NULL */
-	__attribute__((nonnull(1,2,3,4), warn_unused_result));
+	MY_ATTRIBUTE((nonnull(1,2,3,4), warn_unused_result));
 /*************************************************************//**
 Copies records from page to a newly created page, from a given record onward,
 including that record. Infimum and supremum records are not copied.
--- a/storage/innobase/include/page0page.h
+++ b/storage/innobase/include/page0page.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1994, 2015, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1994, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -165,7 +165,7 @@ page_t*
 page_align(
 /*=======*/
 	const void*	ptr)	/*!< in: pointer to page frame */
-		__attribute__((const));
+		MY_ATTRIBUTE((const));
 /************************************************************//**
 Gets the offset within a page.
 @return	offset from the start of the page */
@@ -174,7 +174,7 @@ ulint
 page_offset(
 /*========*/
 	const void*	ptr)	/*!< in: pointer to page frame */
-		__attribute__((const));
+		MY_ATTRIBUTE((const));
 /*************************************************************//**
 Returns the max trx id field value. */
 UNIV_INLINE
@@ -232,7 +232,7 @@ page_header_get_offs(
 /*=================*/
 	const page_t*	page,	/*!< in: page */
 	ulint		field)	/*!< in: PAGE_FREE, ... */
-	__attribute__((nonnull, pure));
+	MY_ATTRIBUTE((nonnull, pure));
 
 /*************************************************************//**
 Returns the pointer stored in the given header field, or NULL. */
@@ -292,7 +292,7 @@ page_rec_get_nth_const(
 /*===================*/
 	const page_t*	page,	/*!< in: page */
 	ulint		nth)	/*!< in: nth record */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /************************************************************//**
 Returns the nth record of the record list.
 This is the inverse function of page_rec_get_n_recs_before().
@@ -303,7 +303,7 @@ page_rec_get_nth(
 /*=============*/
 	page_t*	page,	/*< in: page */
 	ulint	nth)	/*!< in: nth record */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 #ifndef UNIV_HOTBACKUP
 /************************************************************//**
@@ -316,7 +316,7 @@ rec_t*
 page_get_middle_rec(
 /*================*/
 	page_t*	page)	/*!< in: page */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*************************************************************//**
 Compares a data tuple to a physical record. Differs from the function
 cmp_dtuple_rec_with_match in the way that the record must reside on an
@@ -524,7 +524,7 @@ bool
 page_is_leaf(
 /*=========*/
 	const page_t*	page)	/*!< in: page */
-	__attribute__((nonnull, pure));
+	MY_ATTRIBUTE((nonnull, pure));
 /************************************************************//**
 Determine whether the page is empty.
 @return	true if the page is empty (PAGE_N_RECS = 0) */
@@ -533,7 +533,7 @@ bool
 page_is_empty(
 /*==========*/
 	const page_t*	page)	/*!< in: page */
-	__attribute__((nonnull, pure));
+	MY_ATTRIBUTE((nonnull, pure));
 /************************************************************//**
 Determine whether the page contains garbage.
 @return	true if the page contains garbage (PAGE_GARBAGE is not 0) */
@@ -542,7 +542,7 @@ bool
 page_has_garbage(
 /*=============*/
 	const page_t*	page)	/*!< in: page */
-	__attribute__((nonnull, pure));
+	MY_ATTRIBUTE((nonnull, pure));
 /************************************************************//**
 Gets the pointer to the next record on the page.
 @return	pointer to next record */
@@ -614,7 +614,7 @@ ibool
 page_rec_is_user_rec_low(
 /*=====================*/
 	ulint	offset)	/*!< in: record offset on page */
-	__attribute__((const));
+	MY_ATTRIBUTE((const));
 /************************************************************//**
 TRUE if the record is the supremum record on a page.
 @return	TRUE if the supremum record */
@@ -623,7 +623,7 @@ ibool
 page_rec_is_supremum_low(
 /*=====================*/
 	ulint	offset)	/*!< in: record offset on page */
-	__attribute__((const));
+	MY_ATTRIBUTE((const));
 /************************************************************//**
 TRUE if the record is the infimum record on a page.
 @return	TRUE if the infimum record */
@@ -632,7 +632,7 @@ ibool
 page_rec_is_infimum_low(
 /*====================*/
 	ulint	offset)	/*!< in: record offset on page */
-	__attribute__((const));
+	MY_ATTRIBUTE((const));
 
 /************************************************************//**
 TRUE if the record is a user record on the page.
@@ -642,7 +642,7 @@ ibool
 page_rec_is_user_rec(
 /*=================*/
 	const rec_t*	rec)	/*!< in: record */
-	__attribute__((const));
+	MY_ATTRIBUTE((const));
 /************************************************************//**
 TRUE if the record is the supremum record on a page.
 @return	TRUE if the supremum record */
@@ -651,7 +651,7 @@ ibool
 page_rec_is_supremum(
 /*=================*/
 	const rec_t*	rec)	/*!< in: record */
-	__attribute__((const));
+	MY_ATTRIBUTE((const));
 
 /************************************************************//**
 TRUE if the record is the infimum record on a page.
@@ -661,7 +661,7 @@ ibool
 page_rec_is_infimum(
 /*================*/
 	const rec_t*	rec)	/*!< in: record */
-	__attribute__((const));
+	MY_ATTRIBUTE((const));
 /***************************************************************//**
 Looks for the record which owns the given record.
 @return	the owner record */
@@ -681,7 +681,7 @@ page_rec_write_field(
 	ulint	i,	/*!< in: index of the field to update */
 	ulint	val,	/*!< in: value to write */
 	mtr_t*	mtr)	/*!< in/out: mini-transaction */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 #endif /* !UNIV_HOTBACKUP */
 /************************************************************//**
 Returns the maximum combined size of records which can be inserted on top
@@ -711,7 +711,7 @@ ulint
 page_get_free_space_of_empty(
 /*=========================*/
 	ulint	comp)	/*!< in: nonzero=compact page format */
-		__attribute__((const));
+		MY_ATTRIBUTE((const));
 /**********************************************************//**
 Returns the base extra size of a physical record.  This is the
 size of the fixed header, independent of the record size.
@@ -797,7 +797,7 @@ page_create_zip(
 	ulint		level,		/*!< in: the B-tree level of the page */
 	trx_id_t	max_trx_id,	/*!< in: PAGE_MAX_TRX_ID */
 	mtr_t*		mtr)		/*!< in/out: mini-transaction */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /**********************************************************//**
 Empty a previously created B-tree index page. */
 UNIV_INTERN
@@ -807,7 +807,7 @@ page_create_empty(
 	buf_block_t*	block,	/*!< in/out: B-tree block */
 	dict_index_t*	index,	/*!< in: the index of the page */
 	mtr_t*		mtr)	/*!< in/out: mini-transaction */
-	__attribute__((nonnull(1,2)));
+	MY_ATTRIBUTE((nonnull(1,2)));
 /*************************************************************//**
 Differs from page_copy_rec_list_end, because this function does not
 touch the lock table and max trx id on page or compress the page.
@@ -846,7 +846,7 @@ page_copy_rec_list_end(
 	rec_t*		rec,		/*!< in: record on page */
 	dict_index_t*	index,		/*!< in: record descriptor */
 	mtr_t*		mtr)		/*!< in: mtr */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*************************************************************//**
 Copies records from page to new_page, up to the given record, NOT
 including that record. Infimum and supremum records are not copied.
@@ -868,7 +868,7 @@ page_copy_rec_list_start(
 	rec_t*		rec,		/*!< in: record on page */
 	dict_index_t*	index,		/*!< in: record descriptor */
 	mtr_t*		mtr)		/*!< in: mtr */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*************************************************************//**
 Deletes records from a page from a given record onward, including that record.
 The infimum and supremum records are not deleted. */
@@ -885,7 +885,7 @@ page_delete_rec_list_end(
 				records in the end of the chain to
 				delete, or ULINT_UNDEFINED if not known */
 	mtr_t*		mtr)	/*!< in: mtr */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*************************************************************//**
 Deletes records from page, up to the given record, NOT including
 that record. Infimum and supremum records are not deleted. */
@@ -897,7 +897,7 @@ page_delete_rec_list_start(
 	buf_block_t*	block,	/*!< in: buffer block of the page */
 	dict_index_t*	index,	/*!< in: record descriptor */
 	mtr_t*		mtr)	/*!< in: mtr */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*************************************************************//**
 Moves record list end to another page. Moved records include
 split_rec.
@@ -918,7 +918,7 @@ page_move_rec_list_end(
 	rec_t*		split_rec,	/*!< in: first record to move */
 	dict_index_t*	index,		/*!< in: record descriptor */
 	mtr_t*		mtr)		/*!< in: mtr */
-	__attribute__((nonnull(1, 2, 4, 5)));
+	MY_ATTRIBUTE((nonnull(1, 2, 4, 5)));
 /*************************************************************//**
 Moves record list start to another page. Moved records do not include
 split_rec.
@@ -938,7 +938,7 @@ page_move_rec_list_start(
 	rec_t*		split_rec,	/*!< in: first record not to move */
 	dict_index_t*	index,		/*!< in: record descriptor */
 	mtr_t*		mtr)		/*!< in: mtr */
-	__attribute__((nonnull(1, 2, 4, 5)));
+	MY_ATTRIBUTE((nonnull(1, 2, 4, 5)));
 /****************************************************************//**
 Splits a directory slot which owns too many records. */
 UNIV_INTERN
@@ -949,7 +949,7 @@ page_dir_split_slot(
 	page_zip_des_t*	page_zip,/*!< in/out: compressed page whose
 				uncompressed part will be written, or NULL */
 	ulint		slot_no)/*!< in: the directory slot */
-	__attribute__((nonnull(1)));
+	MY_ATTRIBUTE((nonnull(1)));
 /*************************************************************//**
 Tries to balance the given directory slot with too few records
 with the upper neighbor, so that there are at least the minimum number
@@ -962,7 +962,7 @@ page_dir_balance_slot(
 	page_t*		page,	/*!< in/out: index page */
 	page_zip_des_t*	page_zip,/*!< in/out: compressed page, or NULL */
 	ulint		slot_no)/*!< in: the directory slot */
-	__attribute__((nonnull(1)));
+	MY_ATTRIBUTE((nonnull(1)));
 /**********************************************************//**
 Parses a log record of a record list end or start deletion.
 @return	end of log record or NULL */
--- a/storage/innobase/include/page0types.h
+++ b/storage/innobase/include/page0types.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1994, 2013, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1994, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -129,7 +129,7 @@ page_zip_rec_set_deleted(
 	page_zip_des_t*	page_zip,/*!< in/out: compressed page */
 	const byte*	rec,	/*!< in: record on the uncompressed page */
 	ulint		flag)	/*!< in: the deleted flag (nonzero=TRUE) */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /**********************************************************************//**
 Write the "owned" flag of a record on a compressed page.  The n_owned field
@@ -141,7 +141,7 @@ page_zip_rec_set_owned(
 	page_zip_des_t*	page_zip,/*!< in/out: compressed page */
 	const byte*	rec,	/*!< in: record on the uncompressed page */
 	ulint		flag)	/*!< in: the owned flag (nonzero=TRUE) */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /**********************************************************************//**
 Shift the dense page directory when a record is deleted. */
@@ -154,7 +154,7 @@ page_zip_dir_delete(
 	dict_index_t*	index,	/*!< in: index of rec */
 	const ulint*	offsets,/*!< in: rec_get_offsets(rec) */
 	const byte*	free)	/*!< in: previous start of the free list */
-	__attribute__((nonnull(1,2,3,4)));
+	MY_ATTRIBUTE((nonnull(1,2,3,4)));
 
 /**********************************************************************//**
 Add a slot to the dense page directory. */
@@ -165,5 +165,5 @@ page_zip_dir_add_slot(
 	page_zip_des_t*	page_zip,	/*!< in/out: compressed page */
 	ulint		is_clustered)	/*!< in: nonzero for clustered index,
 					zero for others */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 #endif
--- a/storage/innobase/include/page0zip.h
+++ b/storage/innobase/include/page0zip.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 2005, 2013, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 2005, 2016, Oracle and/or its affiliates. All Rights Reserved.
 Copyright (c) 2012, Facebook Inc.
 
 This program is free software; you can redistribute it and/or modify it under
@@ -58,7 +58,7 @@ ulint
 page_zip_get_size(
 /*==============*/
 	const page_zip_des_t*	page_zip)	/*!< in: compressed page */
-	__attribute__((nonnull, pure));
+	MY_ATTRIBUTE((nonnull, pure));
 /**********************************************************************//**
 Set the size of a compressed page in bytes. */
 UNIV_INLINE
@@ -81,7 +81,7 @@ page_zip_rec_needs_ext(
 	ulint	n_fields,	/*!< in: number of fields in the record;
 				ignored if zip_size == 0 */
 	ulint	zip_size)	/*!< in: compressed page size in bytes, or 0 */
-	__attribute__((const));
+	MY_ATTRIBUTE((const));
 
 /**********************************************************************//**
 Determine the guaranteed free space on an empty page.
@@ -92,7 +92,7 @@ page_zip_empty_size(
 /*================*/
 	ulint	n_fields,	/*!< in: number of columns in the index */
 	ulint	zip_size)	/*!< in: compressed page size in bytes */
-	__attribute__((const));
+	MY_ATTRIBUTE((const));
 #endif /* !UNIV_HOTBACKUP */
 
 /**********************************************************************//**
@@ -127,7 +127,7 @@ page_zip_compress(
 	dict_index_t*	index,	/*!< in: index of the B-tree node */
 	ulint		level,	/*!< in: compression level */
 	mtr_t*		mtr)	/*!< in: mini-transaction, or NULL */
-	__attribute__((nonnull(1,2,3)));
+	MY_ATTRIBUTE((nonnull(1,2,3)));
 
 /**********************************************************************//**
 Decompress a page.  This function should tolerate errors on the compressed
@@ -145,7 +145,7 @@ page_zip_decompress(
 				FALSE=verify but do not copy some
 				page header fields that should not change
 				after page creation */
-	__attribute__((nonnull(1,2)));
+	MY_ATTRIBUTE((nonnull(1,2)));
 
 #ifdef UNIV_DEBUG
 /**********************************************************************//**
@@ -172,7 +172,7 @@ page_zip_validate_low(
 	const dict_index_t*	index,	/*!< in: index of the page, if known */
 	ibool			sloppy)	/*!< in: FALSE=strict,
 					TRUE=ignore the MIN_REC_FLAG */
-	__attribute__((nonnull(1,2)));
+	MY_ATTRIBUTE((nonnull(1,2)));
 /**********************************************************************//**
 Check that the compressed and decompressed pages match. */
 UNIV_INTERN
@@ -182,7 +182,7 @@ page_zip_validate(
 	const page_zip_des_t*	page_zip,/*!< in: compressed page */
 	const page_t*		page,	/*!< in: uncompressed page */
 	const dict_index_t*	index)	/*!< in: index of the page, if known */
-	__attribute__((nonnull(1,2)));
+	MY_ATTRIBUTE((nonnull(1,2)));
 #endif /* UNIV_ZIP_DEBUG */
 
 /**********************************************************************//**
@@ -195,7 +195,7 @@ page_zip_max_ins_size(
 /*==================*/
 	const page_zip_des_t*	page_zip,/*!< in: compressed page */
 	ibool			is_clust)/*!< in: TRUE if clustered index */
-	__attribute__((nonnull, pure));
+	MY_ATTRIBUTE((nonnull, pure));
 
 /**********************************************************************//**
 Determine if enough space is available in the modification log.
@@ -209,7 +209,7 @@ page_zip_available(
 	ulint			length,	/*!< in: combined size of the record */
 	ulint			create)	/*!< in: nonzero=add the record to
 					the heap */
-	__attribute__((nonnull, pure));
+	MY_ATTRIBUTE((nonnull, pure));
 
 /**********************************************************************//**
 Write data to the uncompressed header portion of a page.  The data must
@@ -222,7 +222,7 @@ page_zip_write_header(
 	const byte*	str,	/*!< in: address on the uncompressed page */
 	ulint		length,	/*!< in: length of the data */
 	mtr_t*		mtr)	/*!< in: mini-transaction, or NULL */
-	__attribute__((nonnull(1,2)));
+	MY_ATTRIBUTE((nonnull(1,2)));
 
 /**********************************************************************//**
 Write an entire record on the compressed page.  The data must already
@@ -236,7 +236,7 @@ page_zip_write_rec(
 	dict_index_t*	index,	/*!< in: the index the record belongs to */
 	const ulint*	offsets,/*!< in: rec_get_offsets(rec, index) */
 	ulint		create)	/*!< in: nonzero=insert, zero=update */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /***********************************************************//**
 Parses a log record of writing a BLOB pointer of a record.
@@ -265,7 +265,7 @@ page_zip_write_blob_ptr(
 	ulint		n,	/*!< in: column index */
 	mtr_t*		mtr)	/*!< in: mini-transaction handle,
 				or NULL if no logging is needed */
-	__attribute__((nonnull(1,2,3,4)));
+	MY_ATTRIBUTE((nonnull(1,2,3,4)));
 
 /***********************************************************//**
 Parses a log record of writing the node pointer of a record.
@@ -290,7 +290,7 @@ page_zip_write_node_ptr(
 	ulint		size,	/*!< in: data size of rec */
 	ulint		ptr,	/*!< in: node pointer */
 	mtr_t*		mtr)	/*!< in: mini-transaction, or NULL */
-	__attribute__((nonnull(1,2)));
+	MY_ATTRIBUTE((nonnull(1,2)));
 
 /**********************************************************************//**
 Write the trx_id and roll_ptr of a record on a B-tree leaf node page. */
@@ -304,7 +304,7 @@ page_zip_write_trx_id_and_roll_ptr(
 	ulint		trx_id_col,/*!< in: column number of TRX_ID in rec */
 	trx_id_t	trx_id,	/*!< in: transaction identifier */
 	roll_ptr_t	roll_ptr)/*!< in: roll_ptr */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /**********************************************************************//**
 Write the "deleted" flag of a record on a compressed page.  The flag must
@@ -316,7 +316,7 @@ page_zip_rec_set_deleted(
 	page_zip_des_t*	page_zip,/*!< in/out: compressed page */
 	const byte*	rec,	/*!< in: record on the uncompressed page */
 	ulint		flag)	/*!< in: the deleted flag (nonzero=TRUE) */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /**********************************************************************//**
 Write the "owned" flag of a record on a compressed page.  The n_owned field
@@ -328,7 +328,7 @@ page_zip_rec_set_owned(
 	page_zip_des_t*	page_zip,/*!< in/out: compressed page */
 	const byte*	rec,	/*!< in: record on the uncompressed page */
 	ulint		flag)	/*!< in: the owned flag (nonzero=TRUE) */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /**********************************************************************//**
 Insert a record to the dense page directory. */
@@ -355,7 +355,7 @@ page_zip_dir_delete(
 	const ulint*		offsets,	/*!< in: rec_get_offsets(rec) */
 	const byte*		free)		/*!< in: previous start of
 						the free list */
-	__attribute__((nonnull(1,2,3,4)));
+	MY_ATTRIBUTE((nonnull(1,2,3,4)));
 
 /**********************************************************************//**
 Add a slot to the dense page directory. */
@@ -366,7 +366,7 @@ page_zip_dir_add_slot(
 	page_zip_des_t*	page_zip,	/*!< in/out: compressed page */
 	ulint		is_clustered)	/*!< in: nonzero for clustered index,
 					zero for others */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /***********************************************************//**
 Parses a log record of writing to the header of a page.
@@ -394,7 +394,7 @@ page_zip_write_header(
 	const byte*	str,	/*!< in: address on the uncompressed page */
 	ulint		length,	/*!< in: length of the data */
 	mtr_t*		mtr)	/*!< in: mini-transaction, or NULL */
-	__attribute__((nonnull(1,2)));
+	MY_ATTRIBUTE((nonnull(1,2)));
 
 /**********************************************************************//**
 Reorganize and compress a page.  This is a low-level operation for
@@ -417,7 +417,7 @@ page_zip_reorganize(
 				m_start, m_end, m_nonempty */
 	dict_index_t*	index,	/*!< in: index of the B-tree node */
 	mtr_t*		mtr)	/*!< in: mini-transaction */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 #ifndef UNIV_HOTBACKUP
 /**********************************************************************//**
 Copy the records of a page byte for byte.  Do not copy the page header
@@ -436,7 +436,7 @@ page_zip_copy_recs(
 	const page_t*		src,		/*!< in: page */
 	dict_index_t*		index,		/*!< in: index of the B-tree */
 	mtr_t*			mtr)		/*!< in: mini-transaction */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 #endif /* !UNIV_HOTBACKUP */
 
 /**********************************************************************//**
@@ -450,7 +450,7 @@ page_zip_parse_compress(
 	byte*		end_ptr,/*!< in: buffer end */
 	page_t*		page,	/*!< out: uncompressed page */
 	page_zip_des_t*	page_zip)/*!< out: compressed page */
-	__attribute__((nonnull(1,2)));
+	MY_ATTRIBUTE((nonnull(1,2)));
 
 /**********************************************************************//**
 Calculate the compressed page checksum.
@@ -462,7 +462,7 @@ page_zip_calc_checksum(
         const void*     data,   /*!< in: compressed page */
         ulint           size,   /*!< in: size of compressed page */
 	srv_checksum_algorithm_t algo) /*!< in: algorithm to use */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /**********************************************************************//**
 Verify a compressed page's checksum.
@@ -496,7 +496,7 @@ page_zip_parse_compress_no_data(
 	page_t*		page,		/*!< in: uncompressed page */
 	page_zip_des_t*	page_zip,	/*!< out: compressed page */
 	dict_index_t*	index)		/*!< in: index */
-	__attribute__((nonnull(1,2)));
+	MY_ATTRIBUTE((nonnull(1,2)));
 
 /**********************************************************************//**
 Reset the counters used for filling
--- a/storage/innobase/include/pars0pars.h
+++ b/storage/innobase/include/pars0pars.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1996, 2012, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1996, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -472,7 +472,7 @@ pars_complete_graph_for_exec(
 				query graph, or NULL for dummy graph */
 	trx_t*		trx,	/*!< in: transaction handle */
 	mem_heap_t*	heap)	/*!< in: memory heap from which allocated */
-	__attribute__((nonnull(2,3), warn_unused_result));
+	MY_ATTRIBUTE((nonnull(2,3), warn_unused_result));
 
 /****************************************************************//**
 Create parser info struct.
@@ -628,7 +628,7 @@ pars_info_bind_ull_literal(
 	pars_info_t*		info,	/*!< in: info struct */
 	const char*		name,	/*!< in: name */
 	const ib_uint64_t*	val)	/*!< in: value */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /****************************************************************//**
 Add bound id. */
--- a/storage/innobase/include/read0read.h
+++ b/storage/innobase/include/read0read.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1997, 2012, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1997, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -82,7 +82,7 @@ read_view_sees_trx_id(
 /*==================*/
 	const read_view_t*	view,	/*!< in: read view */
 	trx_id_t		trx_id)	/*!< in: trx id */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*********************************************************************//**
 Prints a read view to stderr. */
 UNIV_INTERN
--- a/storage/innobase/include/rem0cmp.h
+++ b/storage/innobase/include/rem0cmp.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1994, 2012, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1994, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -174,7 +174,7 @@ cmp_dtuple_rec_with_match_low(
 				bytes within the first field not completely
 				matched; when function returns, contains the
 				value for current comparison */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 #define cmp_dtuple_rec_with_match(tuple,rec,offsets,fields,bytes)	\
 	cmp_dtuple_rec_with_match_low(					\
 		tuple,rec,offsets,dtuple_get_n_fields_cmp(tuple),fields,bytes)
@@ -218,7 +218,7 @@ cmp_rec_rec_simple(
 	struct TABLE*		table)	/*!< in: MySQL table, for reporting
 					duplicate key value if applicable,
 					or NULL */
-	__attribute__((nonnull(1,2,3,4), warn_unused_result));
+	MY_ATTRIBUTE((nonnull(1,2,3,4), warn_unused_result));
 /*************************************************************//**
 This function is used to compare two physical records. Only the common
 first fields are compared, and if an externally stored field is
--- a/storage/innobase/include/rem0rec.h
+++ b/storage/innobase/include/rem0rec.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1994, 2012, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1994, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -98,7 +98,7 @@ rec_get_next_ptr_const(
 /*===================*/
 	const rec_t*	rec,	/*!< in: physical record */
 	ulint		comp)	/*!< in: nonzero=compact page format */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 /******************************************************//**
 The following function is used to get the pointer of the next chained record
 on the same page.
@@ -109,7 +109,7 @@ rec_get_next_ptr(
 /*=============*/
 	rec_t*	rec,	/*!< in: physical record */
 	ulint	comp)	/*!< in: nonzero=compact page format */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 /******************************************************//**
 The following function is used to get the offset of the
 next chained record on the same page.
@@ -120,7 +120,7 @@ rec_get_next_offs(
 /*==============*/
 	const rec_t*	rec,	/*!< in: physical record */
 	ulint		comp)	/*!< in: nonzero=compact page format */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 /******************************************************//**
 The following function is used to set the next record offset field
 of an old-style record. */
@@ -130,7 +130,7 @@ rec_set_next_offs_old(
 /*==================*/
 	rec_t*	rec,	/*!< in: old-style physical record */
 	ulint	next)	/*!< in: offset of the next record */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /******************************************************//**
 The following function is used to set the next record offset field
 of a new-style record. */
@@ -140,7 +140,7 @@ rec_set_next_offs_new(
 /*==================*/
 	rec_t*	rec,	/*!< in/out: new-style physical record */
 	ulint	next)	/*!< in: offset of the next record */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /******************************************************//**
 The following function is used to get the number of fields
 in an old-style record.
@@ -150,7 +150,7 @@ ulint
 rec_get_n_fields_old(
 /*=================*/
 	const rec_t*	rec)	/*!< in: physical record */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 /******************************************************//**
 The following function is used to get the number of fields
 in a record.
@@ -161,7 +161,7 @@ rec_get_n_fields(
 /*=============*/
 	const rec_t*		rec,	/*!< in: physical record */
 	const dict_index_t*	index)	/*!< in: record descriptor */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 /******************************************************//**
 The following function is used to get the number of records owned by the
 previous directory record.
@@ -171,7 +171,7 @@ ulint
 rec_get_n_owned_old(
 /*================*/
 	const rec_t*	rec)	/*!< in: old-style physical record */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 /******************************************************//**
 The following function is used to set the number of owned records. */
 UNIV_INLINE
@@ -180,7 +180,7 @@ rec_set_n_owned_old(
 /*================*/
 	rec_t*	rec,		/*!< in: old-style physical record */
 	ulint	n_owned)	/*!< in: the number of owned */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /******************************************************//**
 The following function is used to get the number of records owned by the
 previous directory record.
@@ -190,7 +190,7 @@ ulint
 rec_get_n_owned_new(
 /*================*/
 	const rec_t*	rec)	/*!< in: new-style physical record */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 /******************************************************//**
 The following function is used to set the number of owned records. */
 UNIV_INLINE
@@ -200,7 +200,7 @@ rec_set_n_owned_new(
 	rec_t*		rec,	/*!< in/out: new-style physical record */
 	page_zip_des_t*	page_zip,/*!< in/out: compressed page, or NULL */
 	ulint		n_owned)/*!< in: the number of owned */
-	__attribute__((nonnull(1)));
+	MY_ATTRIBUTE((nonnull(1)));
 /******************************************************//**
 The following function is used to retrieve the info bits of
 a record.
@@ -211,7 +211,7 @@ rec_get_info_bits(
 /*==============*/
 	const rec_t*	rec,	/*!< in: physical record */
 	ulint		comp)	/*!< in: nonzero=compact page format */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 /******************************************************//**
 The following function is used to set the info bits of a record. */
 UNIV_INLINE
@@ -220,7 +220,7 @@ rec_set_info_bits_old(
 /*==================*/
 	rec_t*	rec,	/*!< in: old-style physical record */
 	ulint	bits)	/*!< in: info bits */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /******************************************************//**
 The following function is used to set the info bits of a record. */
 UNIV_INLINE
@@ -229,7 +229,7 @@ rec_set_info_bits_new(
 /*==================*/
 	rec_t*	rec,	/*!< in/out: new-style physical record */
 	ulint	bits)	/*!< in: info bits */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /******************************************************//**
 The following function retrieves the status bits of a new-style record.
 @return	status bits */
@@ -238,7 +238,7 @@ ulint
 rec_get_status(
 /*===========*/
 	const rec_t*	rec)	/*!< in: physical record */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 
 /******************************************************//**
 The following function is used to set the status bits of a new-style record. */
@@ -248,7 +248,7 @@ rec_set_status(
 /*===========*/
 	rec_t*	rec,	/*!< in/out: physical record */
 	ulint	bits)	/*!< in: info bits */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /******************************************************//**
 The following function is used to retrieve the info and status
@@ -260,7 +260,7 @@ rec_get_info_and_status_bits(
 /*=========================*/
 	const rec_t*	rec,	/*!< in: physical record */
 	ulint		comp)	/*!< in: nonzero=compact page format */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 /******************************************************//**
 The following function is used to set the info and status
 bits of a record.  (Only compact records have status bits.) */
@@ -270,7 +270,7 @@ rec_set_info_and_status_bits(
 /*=========================*/
 	rec_t*	rec,	/*!< in/out: compact physical record */
 	ulint	bits)	/*!< in: info bits */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /******************************************************//**
 The following function tells if record is delete marked.
@@ -281,7 +281,7 @@ rec_get_deleted_flag(
 /*=================*/
 	const rec_t*	rec,	/*!< in: physical record */
 	ulint		comp)	/*!< in: nonzero=compact page format */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 /******************************************************//**
 The following function is used to set the deleted bit. */
 UNIV_INLINE
@@ -290,7 +290,7 @@ rec_set_deleted_flag_old(
 /*=====================*/
 	rec_t*	rec,	/*!< in: old-style physical record */
 	ulint	flag)	/*!< in: nonzero if delete marked */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /******************************************************//**
 The following function is used to set the deleted bit. */
 UNIV_INLINE
@@ -300,7 +300,7 @@ rec_set_deleted_flag_new(
 	rec_t*		rec,	/*!< in/out: new-style physical record */
 	page_zip_des_t*	page_zip,/*!< in/out: compressed page, or NULL */
 	ulint		flag)	/*!< in: nonzero if delete marked */
-	__attribute__((nonnull(1)));
+	MY_ATTRIBUTE((nonnull(1)));
 /******************************************************//**
 The following function tells if a new-style record is a node pointer.
 @return	TRUE if node pointer */
@@ -309,7 +309,7 @@ ibool
 rec_get_node_ptr_flag(
 /*==================*/
 	const rec_t*	rec)	/*!< in: physical record */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 /******************************************************//**
 The following function is used to get the order number
 of an old-style record in the heap of the index page.
@@ -319,7 +319,7 @@ ulint
 rec_get_heap_no_old(
 /*================*/
 	const rec_t*	rec)	/*!< in: physical record */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 /******************************************************//**
 The following function is used to set the heap number
 field in an old-style record. */
@@ -329,7 +329,7 @@ rec_set_heap_no_old(
 /*================*/
 	rec_t*	rec,	/*!< in: physical record */
 	ulint	heap_no)/*!< in: the heap number */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /******************************************************//**
 The following function is used to get the order number
 of a new-style record in the heap of the index page.
@@ -339,7 +339,7 @@ ulint
 rec_get_heap_no_new(
 /*================*/
 	const rec_t*	rec)	/*!< in: physical record */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 /******************************************************//**
 The following function is used to set the heap number
 field in a new-style record. */
@@ -349,7 +349,7 @@ rec_set_heap_no_new(
 /*================*/
 	rec_t*	rec,	/*!< in/out: physical record */
 	ulint	heap_no)/*!< in: the heap number */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /******************************************************//**
 The following function is used to test whether the data offsets
 in the record are stored in one-byte or two-byte format.
@@ -359,7 +359,7 @@ ibool
 rec_get_1byte_offs_flag(
 /*====================*/
 	const rec_t*	rec)	/*!< in: physical record */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 
 /******************************************************//**
 The following function is used to set the 1-byte offsets flag. */
@@ -369,7 +369,7 @@ rec_set_1byte_offs_flag(
 /*====================*/
 	rec_t*	rec,	/*!< in: physical record */
 	ibool	flag)	/*!< in: TRUE if 1byte form */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /******************************************************//**
 Returns the offset of nth field end if the record is stored in the 1-byte
@@ -382,7 +382,7 @@ rec_1_get_field_end_info(
 /*=====================*/
 	const rec_t*	rec,	/*!< in: record */
 	ulint		n)	/*!< in: field index */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 
 /******************************************************//**
 Returns the offset of nth field end if the record is stored in the 2-byte
@@ -396,7 +396,7 @@ rec_2_get_field_end_info(
 /*=====================*/
 	const rec_t*	rec,	/*!< in: record */
 	ulint		n)	/*!< in: field index */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 
 /******************************************************//**
 Returns nonzero if the field is stored off-page.
@@ -408,7 +408,7 @@ rec_2_is_field_extern(
 /*==================*/
 	const rec_t*	rec,	/*!< in: record */
 	ulint		n)	/*!< in: field index */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 
 /******************************************************//**
 Determine how many of the first n columns in a compact
@@ -421,7 +421,7 @@ rec_get_n_extern_new(
 	const rec_t*		rec,	/*!< in: compact physical record */
 	const dict_index_t*	index,	/*!< in: record descriptor */
 	ulint			n)	/*!< in: number of columns to scan */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 /******************************************************//**
 The following function determines the offsets to each field
@@ -446,9 +446,9 @@ rec_get_offsets_func(
 #endif /* UNIV_DEBUG */
 	mem_heap_t**		heap)	/*!< in/out: memory heap */
 #ifdef UNIV_DEBUG
-	__attribute__((nonnull(1,2,5,7),warn_unused_result));
+	MY_ATTRIBUTE((nonnull(1,2,5,7),warn_unused_result));
 #else /* UNIV_DEBUG */
-	__attribute__((nonnull(1,2,5),warn_unused_result));
+	MY_ATTRIBUTE((nonnull(1,2,5),warn_unused_result));
 #endif /* UNIV_DEBUG */
 
 #ifdef UNIV_DEBUG
@@ -475,7 +475,7 @@ rec_get_offsets_reverse(
 					0=leaf node */
 	ulint*			offsets)/*!< in/out: array consisting of
 					offsets[0] allocated elements */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 #ifdef UNIV_DEBUG
 /************************************************************//**
 Validates offsets returned by rec_get_offsets().
@@ -488,7 +488,7 @@ rec_offs_validate(
 	const dict_index_t*	index,	/*!< in: record descriptor or NULL */
 	const ulint*		offsets)/*!< in: array returned by
 					rec_get_offsets() */
-	__attribute__((nonnull(3), warn_unused_result));
+	MY_ATTRIBUTE((nonnull(3), warn_unused_result));
 /************************************************************//**
 Updates debug data in offsets, in order to avoid bogus
 rec_offs_validate() failures. */
@@ -500,7 +500,7 @@ rec_offs_make_valid(
 	const dict_index_t*	index,	/*!< in: record descriptor */
 	ulint*			offsets)/*!< in: array returned by
 					rec_get_offsets() */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 #else
 # define rec_offs_make_valid(rec, index, offsets) ((void) 0)
 #endif /* UNIV_DEBUG */
@@ -517,7 +517,7 @@ rec_get_nth_field_offs_old(
 	ulint		n,	/*!< in: index of the field */
 	ulint*		len)	/*!< out: length of the field; UNIV_SQL_NULL
 				if SQL null */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 #define rec_get_nth_field_old(rec, n, len) \
 ((rec) + rec_get_nth_field_offs_old(rec, n, len))
 /************************************************************//**
@@ -531,7 +531,7 @@ rec_get_nth_field_size(
 /*===================*/
 	const rec_t*	rec,	/*!< in: record */
 	ulint		n)	/*!< in: index of the field */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 /************************************************************//**
 The following function is used to get an offset to the nth
 data field in a record.
@@ -544,7 +544,7 @@ rec_get_nth_field_offs(
 	ulint		n,	/*!< in: index of the field */
 	ulint*		len)	/*!< out: length of the field; UNIV_SQL_NULL
 				if SQL null */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 #define rec_get_nth_field(rec, offsets, n, len) \
 ((rec) + rec_get_nth_field_offs(offsets, n, len))
 /******************************************************//**
@@ -556,7 +556,7 @@ ulint
 rec_offs_comp(
 /*==========*/
 	const ulint*	offsets)/*!< in: array returned by rec_get_offsets() */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 /******************************************************//**
 Determine if the offsets are for a record containing
 externally stored columns.
@@ -566,7 +566,7 @@ ulint
 rec_offs_any_extern(
 /*================*/
 	const ulint*	offsets)/*!< in: array returned by rec_get_offsets() */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 /******************************************************//**
 Determine if the offsets are for a record containing null BLOB pointers.
 @return	first field containing a null BLOB pointer, or NULL if none found */
@@ -576,7 +576,7 @@ rec_offs_any_null_extern(
 /*=====================*/
 	const rec_t*	rec,		/*!< in: record */
 	const ulint*	offsets)	/*!< in: rec_get_offsets(rec) */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 /******************************************************//**
 Returns nonzero if the extern bit is set in nth field of rec.
 @return	nonzero if externally stored */
@@ -586,7 +586,7 @@ rec_offs_nth_extern(
 /*================*/
 	const ulint*	offsets,/*!< in: array returned by rec_get_offsets() */
 	ulint		n)	/*!< in: nth field */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 /******************************************************//**
 Returns nonzero if the SQL NULL bit is set in nth field of rec.
 @return	nonzero if SQL NULL */
@@ -596,7 +596,7 @@ rec_offs_nth_sql_null(
 /*==================*/
 	const ulint*	offsets,/*!< in: array returned by rec_get_offsets() */
 	ulint		n)	/*!< in: nth field */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 /******************************************************//**
 Gets the physical size of a field.
 @return	length of field */
@@ -606,7 +606,7 @@ rec_offs_nth_size(
 /*==============*/
 	const ulint*	offsets,/*!< in: array returned by rec_get_offsets() */
 	ulint		n)	/*!< in: nth field */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 
 /******************************************************//**
 Returns the number of extern bits set in a record.
@@ -616,7 +616,7 @@ ulint
 rec_offs_n_extern(
 /*==============*/
 	const ulint*	offsets)/*!< in: array returned by rec_get_offsets() */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 /***********************************************************//**
 This is used to modify the value of an already existing field in a record.
 The previous value must have exactly the same size as the new value. If len
@@ -636,7 +636,7 @@ rec_set_nth_field(
 				length as the previous value.
 				If SQL null, previous value must be
 				SQL null. */
-	__attribute__((nonnull(1,2)));
+	MY_ATTRIBUTE((nonnull(1,2)));
 /**********************************************************//**
 The following function returns the data size of an old-style physical
 record, that is the sum of field lengths. SQL null fields
@@ -648,7 +648,7 @@ ulint
 rec_get_data_size_old(
 /*==================*/
 	const rec_t*	rec)	/*!< in: physical record */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 /**********************************************************//**
 The following function returns the number of allocated elements
 for an array of offsets.
@@ -658,7 +658,7 @@ ulint
 rec_offs_get_n_alloc(
 /*=================*/
 	const ulint*	offsets)/*!< in: array for rec_get_offsets() */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 /**********************************************************//**
 The following function sets the number of allocated elements
 for an array of offsets. */
@@ -669,7 +669,7 @@ rec_offs_set_n_alloc(
 	ulint*	offsets,	/*!< out: array for rec_get_offsets(),
 				must be allocated */
 	ulint	n_alloc)	/*!< in: number of elements */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 #define rec_offs_init(offsets) \
 	rec_offs_set_n_alloc(offsets, (sizeof offsets) / sizeof *offsets)
 /**********************************************************//**
@@ -680,7 +680,7 @@ ulint
 rec_offs_n_fields(
 /*==============*/
 	const ulint*	offsets)/*!< in: array returned by rec_get_offsets() */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 /**********************************************************//**
 The following function returns the data size of a physical
 record, that is the sum of field lengths. SQL null fields
@@ -692,7 +692,7 @@ ulint
 rec_offs_data_size(
 /*===============*/
 	const ulint*	offsets)/*!< in: array returned by rec_get_offsets() */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 /**********************************************************//**
 Returns the total size of record minus data size of record.
 The value returned by the function is the distance from record
@@ -703,7 +703,7 @@ ulint
 rec_offs_extra_size(
 /*================*/
 	const ulint*	offsets)/*!< in: array returned by rec_get_offsets() */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 /**********************************************************//**
 Returns the total size of a physical record.
 @return	size */
@@ -712,7 +712,7 @@ ulint
 rec_offs_size(
 /*==========*/
 	const ulint*	offsets)/*!< in: array returned by rec_get_offsets() */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 #ifdef UNIV_DEBUG
 /**********************************************************//**
 Returns a pointer to the start of the record.
@@ -723,7 +723,7 @@ rec_get_start(
 /*==========*/
 	const rec_t*	rec,	/*!< in: pointer to record */
 	const ulint*	offsets)/*!< in: array returned by rec_get_offsets() */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 /**********************************************************//**
 Returns a pointer to the end of the record.
 @return	pointer to end */
@@ -733,7 +733,7 @@ rec_get_end(
 /*========*/
 	const rec_t*	rec,	/*!< in: pointer to record */
 	const ulint*	offsets)/*!< in: array returned by rec_get_offsets() */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 #else /* UNIV_DEBUG */
 # define rec_get_start(rec, offsets) ((rec) - rec_offs_extra_size(offsets))
 # define rec_get_end(rec, offsets) ((rec) + rec_offs_data_size(offsets))
@@ -748,7 +748,7 @@ rec_copy(
 	void*		buf,	/*!< in: buffer */
 	const rec_t*	rec,	/*!< in: physical record */
 	const ulint*	offsets)/*!< in: array returned by rec_get_offsets() */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 #ifndef UNIV_HOTBACKUP
 /**********************************************************//**
 Determines the size of a data tuple prefix in a temporary file.
@@ -761,7 +761,7 @@ rec_get_converted_size_temp(
 	const dfield_t*		fields,	/*!< in: array of data fields */
 	ulint			n_fields,/*!< in: number of data fields */
 	ulint*			extra)	/*!< out: extra size */
-	__attribute__((warn_unused_result, nonnull));
+	MY_ATTRIBUTE((warn_unused_result, nonnull));
 
 /******************************************************//**
 Determine the offset to each field in temporary file.
@@ -774,7 +774,7 @@ rec_init_offsets_temp(
 	const dict_index_t*	index,	/*!< in: record descriptor */
 	ulint*			offsets)/*!< in/out: array of offsets;
 					in: n=rec_offs_n_fields(offsets) */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /*********************************************************//**
 Builds a temporary file record out of a data tuple.
@@ -787,7 +787,7 @@ rec_convert_dtuple_to_temp(
 	const dict_index_t*	index,		/*!< in: record descriptor */
 	const dfield_t*		fields,		/*!< in: array of data fields */
 	ulint			n_fields)	/*!< in: number of fields */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /**************************************************************//**
 Copies the first n fields of a physical record to a new physical record in
@@ -805,7 +805,7 @@ rec_copy_prefix_to_buf(
 						for the copied prefix,
 						or NULL */
 	ulint*			buf_size)	/*!< in/out: buffer size */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /************************************************************//**
 Folds a prefix of a physical record to a ulint.
 @return	the folded value */
@@ -821,7 +821,7 @@ rec_fold(
 	ulint		n_bytes,	/*!< in: number of bytes to fold
 					in an incomplete last field */
 	index_id_t	tree_id)	/*!< in: index tree id */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 #endif /* !UNIV_HOTBACKUP */
 /*********************************************************//**
 Builds a physical record out of a data tuple and
@@ -837,7 +837,7 @@ rec_convert_dtuple_to_rec(
 	const dtuple_t*		dtuple,	/*!< in: data tuple */
 	ulint			n_ext)	/*!< in: number of
 					externally stored columns */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /**********************************************************//**
 Returns the extra size of an old-style physical record if we know its
 data size and number of fields.
@@ -849,7 +849,7 @@ rec_get_converted_extra_size(
 	ulint	data_size,	/*!< in: data size */
 	ulint	n_fields,	/*!< in: number of fields */
 	ulint	n_ext)		/*!< in: number of externally stored columns */
-	__attribute__((const));
+	MY_ATTRIBUTE((const));
 /**********************************************************//**
 Determines the size of a data tuple prefix in ROW_FORMAT=COMPACT.
 @return	total size */
@@ -861,7 +861,7 @@ rec_get_converted_size_comp_prefix(
 	const dfield_t*		fields,	/*!< in: array of data fields */
 	ulint			n_fields,/*!< in: number of data fields */
 	ulint*			extra)	/*!< out: extra size */
-	__attribute__((warn_unused_result, nonnull(1,2)));
+	MY_ATTRIBUTE((warn_unused_result, nonnull(1,2)));
 /**********************************************************//**
 Determines the size of a data tuple in ROW_FORMAT=COMPACT.
 @return	total size */
@@ -877,7 +877,7 @@ rec_get_converted_size_comp(
 	const dfield_t*		fields,	/*!< in: array of data fields */
 	ulint			n_fields,/*!< in: number of data fields */
 	ulint*			extra)	/*!< out: extra size */
-	__attribute__((nonnull(1,3)));
+	MY_ATTRIBUTE((nonnull(1,3)));
 /**********************************************************//**
 The following function returns the size of a data tuple when converted to
 a physical record.
@@ -889,7 +889,7 @@ rec_get_converted_size(
 	dict_index_t*	index,	/*!< in: record descriptor */
 	const dtuple_t*	dtuple,	/*!< in: data tuple */
 	ulint		n_ext)	/*!< in: number of externally stored columns */
-	__attribute__((warn_unused_result, nonnull));
+	MY_ATTRIBUTE((warn_unused_result, nonnull));
 #ifndef UNIV_HOTBACKUP
 /**************************************************************//**
 Copies the first n fields of a physical record to a data tuple.
@@ -904,7 +904,7 @@ rec_copy_prefix_to_dtuple(
 	ulint			n_fields,	/*!< in: number of fields
 						to copy */
 	mem_heap_t*		heap)		/*!< in: memory heap */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 #endif /* !UNIV_HOTBACKUP */
 /***************************************************************//**
 Validates the consistency of a physical record.
@@ -915,7 +915,7 @@ rec_validate(
 /*=========*/
 	const rec_t*	rec,	/*!< in: physical record */
 	const ulint*	offsets)/*!< in: array returned by rec_get_offsets() */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /***************************************************************//**
 Prints an old-style physical record. */
 UNIV_INTERN
@@ -924,7 +924,7 @@ rec_print_old(
 /*==========*/
 	FILE*		file,	/*!< in: file where to print */
 	const rec_t*	rec)	/*!< in: physical record */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 #ifndef UNIV_HOTBACKUP
 /***************************************************************//**
 Prints a physical record in ROW_FORMAT=COMPACT.  Ignores the
@@ -936,7 +936,7 @@ rec_print_comp(
 	FILE*		file,	/*!< in: file where to print */
 	const rec_t*	rec,	/*!< in: physical record */
 	const ulint*	offsets)/*!< in: array returned by rec_get_offsets() */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /***************************************************************//**
 Prints a physical record. */
 UNIV_INTERN
@@ -946,7 +946,7 @@ rec_print_new(
 	FILE*		file,	/*!< in: file where to print */
 	const rec_t*	rec,	/*!< in: physical record */
 	const ulint*	offsets)/*!< in: array returned by rec_get_offsets() */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /***************************************************************//**
 Prints a physical record. */
 UNIV_INTERN
@@ -956,7 +956,7 @@ rec_print(
 	FILE*			file,	/*!< in: file where to print */
 	const rec_t*		rec,	/*!< in: physical record */
 	const dict_index_t*	index)	/*!< in: record descriptor */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 # ifdef UNIV_DEBUG
 /************************************************************//**
@@ -968,7 +968,7 @@ rec_get_trx_id(
 /*===========*/
 	const rec_t*		rec,	/*!< in: record */
 	const dict_index_t*	index)	/*!< in: clustered index */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 # endif /* UNIV_DEBUG */
 #endif /* UNIV_HOTBACKUP */
 
--- a/storage/innobase/include/row0ftsort.h
+++ b/storage/innobase/include/row0ftsort.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 2010, 2012, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 2010, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -187,7 +187,7 @@ row_fts_psort_info_init(
 					instantiated */
 	fts_psort_t**		merge)	/*!< out: parallel merge info
 					to be instantiated */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /********************************************************************//**
 Clean up and deallocate FTS parallel sort structures, and close
 temparary merge sort files */
@@ -275,5 +275,5 @@ row_fts_merge_insert(
 	fts_psort_t*	psort_info,	/*!< parallel sort info */
 	ulint		id)		/* !< in: which auxiliary table's data
 					to insert to */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 #endif /* row0ftsort_h */
--- a/storage/innobase/include/row0import.h
+++ b/storage/innobase/include/row0import.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 2012, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 2012, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -46,7 +46,7 @@ row_import_for_mysql(
 	dict_table_t*	table,		/*!< in/out: table */
 	row_prebuilt_t*	prebuilt)	/*!< in: prebuilt struct
 						in MySQL */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 /*****************************************************************//**
 Update the DICT_TF2_DISCARDED flag in SYS_TABLES.
@@ -64,7 +64,7 @@ row_import_update_discarded_flag(
 	bool		dict_locked)		/*!< in: Set to true if the
 						caller already owns the
 						dict_sys_t:: mutex. */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 /*****************************************************************//**
 Update the (space, root page) of a table's indexes from the values
@@ -83,7 +83,7 @@ row_import_update_index_root(
 	bool			dict_locked)	/*!< in: Set to true if the
 						caller already owns the
 						dict_sys_t:: mutex. */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 #ifndef UNIV_NONINL
 #include "row0import.ic"
 #endif
--- a/storage/innobase/include/row0ins.h
+++ b/storage/innobase/include/row0ins.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1996, 2012, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1996, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -53,7 +53,7 @@ row_ins_check_foreign_constraint(
 				table, else the referenced table */
 	dtuple_t*	entry,	/*!< in: index entry for index */
 	que_thr_t*	thr)	/*!< in: query thread */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*********************************************************************//**
 Creates an insert node struct.
 @return	own: insert node struct */
@@ -98,7 +98,7 @@ row_ins_clust_index_entry_low(
 	dtuple_t*	entry,	/*!< in/out: index entry to insert */
 	ulint		n_ext,	/*!< in: number of externally stored columns */
 	que_thr_t*	thr)	/*!< in: query thread or NULL */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /***************************************************************//**
 Tries to insert an entry into a secondary index. If a record with exactly the
 same fields is found, the other record is necessarily marked deleted.
@@ -123,7 +123,7 @@ row_ins_sec_index_entry_low(
 	trx_id_t	trx_id,	/*!< in: PAGE_MAX_TRX_ID during
 				row_log_table_apply(), or 0 */
 	que_thr_t*	thr)	/*!< in: query thread */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /***************************************************************//**
 Tries to insert the externally stored fields (off-page columns)
 of a clustered index entry.
@@ -142,7 +142,7 @@ row_ins_index_entry_big_rec_func(
 	const void*		thd,	/*!< in: connection, or NULL */
 #endif /* DBUG_OFF */
 	ulint			line)	/*!< in: line number of caller */
-	__attribute__((nonnull(1,2,3,4,5,6), warn_unused_result));
+	MY_ATTRIBUTE((nonnull(1,2,3,4,5,6), warn_unused_result));
 #ifdef DBUG_OFF
 # define row_ins_index_entry_big_rec(e,big,ofs,heap,index,thd,file,line) \
 	row_ins_index_entry_big_rec_func(e,big,ofs,heap,index,file,line)
@@ -164,7 +164,7 @@ row_ins_clust_index_entry(
 	dtuple_t*	entry,	/*!< in/out: index entry to insert */
 	que_thr_t*	thr,	/*!< in: query thread */
 	ulint		n_ext)	/*!< in: number of externally stored columns */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /***************************************************************//**
 Inserts an entry into a secondary index. Tries first optimistic,
 then pessimistic descent down the tree. If the entry matches enough
@@ -178,7 +178,7 @@ row_ins_sec_index_entry(
 	dict_index_t*	index,	/*!< in: secondary index */
 	dtuple_t*	entry,	/*!< in/out: index entry to insert */
 	que_thr_t*	thr)	/*!< in: query thread */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /***********************************************************//**
 Inserts a row to a table. This is a high-level function used in
 SQL execution graphs.
--- a/storage/innobase/include/row0log.h
+++ b/storage/innobase/include/row0log.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 2011, 2015, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 2011, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -54,7 +54,7 @@ row_log_allocate(
 	const ulint*	col_map,/*!< in: mapping of old column
 				numbers to new ones, or NULL if !table */
 	const char*	path)	/*!< in: where to create temporary file */
-	__attribute__((nonnull(1), warn_unused_result));
+	MY_ATTRIBUTE((nonnull(1), warn_unused_result));
 
 /******************************************************//**
 Free the row log for an index that was being created online. */
@@ -63,7 +63,7 @@ void
 row_log_free(
 /*=========*/
 	row_log_t*&	log)	/*!< in,own: row log */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /******************************************************//**
 Free the row log for an index on which online creation was aborted. */
@@ -72,7 +72,7 @@ void
 row_log_abort_sec(
 /*==============*/
 	dict_index_t*	index)	/*!< in/out: index (x-latched) */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /******************************************************//**
 Try to log an operation to a secondary index that is
@@ -87,7 +87,7 @@ row_log_online_op_try(
 	const dtuple_t* tuple,	/*!< in: index tuple */
 	trx_id_t	trx_id)	/*!< in: transaction ID for insert,
 				or 0 for delete */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /******************************************************//**
 Logs an operation to a secondary index that is (or was) being created. */
 UNIV_INTERN
@@ -98,7 +98,7 @@ row_log_online_op(
 	const dtuple_t*	tuple,	/*!< in: index tuple */
 	trx_id_t	trx_id)	/*!< in: transaction ID for insert,
 				or 0 for delete */
-	UNIV_COLD __attribute__((nonnull));
+	UNIV_COLD MY_ATTRIBUTE((nonnull));
 
 /******************************************************//**
 Gets the error status of the online index rebuild log.
@@ -109,7 +109,7 @@ row_log_table_get_error(
 /*====================*/
 	const dict_index_t*	index)	/*!< in: clustered index of a table
 					that is being rebuilt online */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 /******************************************************//**
 Logs a delete operation to a table that is being rebuilt.
@@ -125,7 +125,7 @@ row_log_table_delete(
 	const ulint*	offsets,/*!< in: rec_get_offsets(rec,index) */
 	const byte*	sys)	/*!< in: DB_TRX_ID,DB_ROLL_PTR that should
 				be logged, or NULL to use those in rec */
-	UNIV_COLD __attribute__((nonnull(1,2,3)));
+	UNIV_COLD MY_ATTRIBUTE((nonnull(1,2,3)));
 
 /******************************************************//**
 Logs an update operation to a table that is being rebuilt.
@@ -141,7 +141,7 @@ row_log_table_update(
 	const ulint*	offsets,/*!< in: rec_get_offsets(rec,index) */
 	const dtuple_t*	old_pk)	/*!< in: row_log_table_get_pk()
 				before the update */
-	UNIV_COLD __attribute__((nonnull(1,2,3)));
+	UNIV_COLD MY_ATTRIBUTE((nonnull(1,2,3)));
 
 /******************************************************//**
 Constructs the old PRIMARY KEY and DB_TRX_ID,DB_ROLL_PTR
@@ -161,7 +161,7 @@ row_log_table_get_pk(
 	byte*		sys,	/*!< out: DB_TRX_ID,DB_ROLL_PTR for
 				row_log_table_delete(), or NULL */
 	mem_heap_t**	heap)	/*!< in/out: memory heap where allocated */
-	UNIV_COLD __attribute__((nonnull(1,2,5), warn_unused_result));
+	UNIV_COLD MY_ATTRIBUTE((nonnull(1,2,5), warn_unused_result));
 
 /******************************************************//**
 Logs an insert to a table that is being rebuilt.
@@ -175,7 +175,7 @@ row_log_table_insert(
 	dict_index_t*	index,	/*!< in/out: clustered index, S-latched
 				or X-latched */
 	const ulint*	offsets)/*!< in: rec_get_offsets(rec,index) */
-	UNIV_COLD __attribute__((nonnull));
+	UNIV_COLD MY_ATTRIBUTE((nonnull));
 /******************************************************//**
 Notes that a BLOB is being freed during online ALTER TABLE. */
 UNIV_INTERN
@@ -184,7 +184,7 @@ row_log_table_blob_free(
 /*====================*/
 	dict_index_t*	index,	/*!< in/out: clustered index, X-latched */
 	ulint		page_no)/*!< in: starting page number of the BLOB */
-	UNIV_COLD __attribute__((nonnull));
+	UNIV_COLD MY_ATTRIBUTE((nonnull));
 /******************************************************//**
 Notes that a BLOB is being allocated during online ALTER TABLE. */
 UNIV_INTERN
@@ -193,7 +193,7 @@ row_log_table_blob_alloc(
 /*=====================*/
 	dict_index_t*	index,	/*!< in/out: clustered index, X-latched */
 	ulint		page_no)/*!< in: starting page number of the BLOB */
-	UNIV_COLD __attribute__((nonnull));
+	UNIV_COLD MY_ATTRIBUTE((nonnull));
 /******************************************************//**
 Apply the row_log_table log to a table upon completing rebuild.
 @return DB_SUCCESS, or error code on failure */
@@ -206,7 +206,7 @@ row_log_table_apply(
 				/*!< in: old table */
 	struct TABLE*	table)	/*!< in/out: MySQL table
 				(for reporting duplicates) */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 /******************************************************//**
 Get the latest transaction ID that has invoked row_log_online_op()
@@ -217,7 +217,7 @@ trx_id_t
 row_log_get_max_trx(
 /*================*/
 	dict_index_t*	index)	/*!< in: index, must be locked */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 /******************************************************//**
 Merge the row log to the index upon completing index creation.
@@ -231,7 +231,7 @@ row_log_apply(
 	dict_index_t*	index,	/*!< in/out: secondary index */
 	struct TABLE*	table)	/*!< in/out: MySQL table
 				(for reporting duplicates) */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 #ifndef UNIV_NONINL
 #include "row0log.ic"
--- a/storage/innobase/include/row0merge.h
+++ b/storage/innobase/include/row0merge.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 2005, 2015, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 2005, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -127,7 +127,7 @@ row_merge_dup_report(
 /*=================*/
 	row_merge_dup_t*	dup,	/*!< in/out: for reporting duplicates */
 	const dfield_t*		entry)	/*!< in: duplicate index entry */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*********************************************************************//**
 Sets an exclusive lock on a table, for the duration of creating indexes.
 @return	error code or DB_SUCCESS */
@@ -138,7 +138,7 @@ row_merge_lock_table(
 	trx_t*		trx,		/*!< in/out: transaction */
 	dict_table_t*	table,		/*!< in: table to lock */
 	enum lock_mode	mode)		/*!< in: LOCK_X or LOCK_S */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*********************************************************************//**
 Drop indexes that were created before an error occurred.
 The data dictionary must have been locked exclusively by the caller,
@@ -149,7 +149,7 @@ row_merge_drop_indexes_dict(
 /*========================*/
 	trx_t*		trx,	/*!< in/out: dictionary transaction */
 	table_id_t	table_id)/*!< in: table identifier */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*********************************************************************//**
 Drop those indexes which were created before an error occurred.
 The data dictionary must have been locked exclusively by the caller,
@@ -162,7 +162,7 @@ row_merge_drop_indexes(
 	dict_table_t*	table,	/*!< in/out: table containing the indexes */
 	ibool		locked)	/*!< in: TRUE=table locked,
 				FALSE=may need to do a lazy drop */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*********************************************************************//**
 Drop all partially created indexes during crash recovery. */
 UNIV_INTERN
@@ -178,7 +178,7 @@ UNIV_INTERN
 int
 row_merge_file_create_low(
 	const char*	path)
-	__attribute__((warn_unused_result));
+	MY_ATTRIBUTE((warn_unused_result));
 /*********************************************************************//**
 Destroy a merge file. And de-register the file from Performance Schema
 if UNIV_PFS_IO is defined. */
@@ -214,7 +214,7 @@ row_merge_rename_tables_dict(
 					old_table->name */
 	const char*	tmp_name,	/*!< in: new name for old_table */
 	trx_t*		trx)		/*!< in/out: dictionary transaction */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 /*********************************************************************//**
 Rename an index in the dictionary that was created. The data
@@ -228,7 +228,7 @@ row_merge_rename_index_to_add(
 	trx_t*		trx,		/*!< in/out: transaction */
 	table_id_t	table_id,	/*!< in: table identifier */
 	index_id_t	index_id)	/*!< in: index identifier */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*********************************************************************//**
 Rename an index in the dictionary that is to be dropped. The data
 dictionary must have been locked exclusively by the caller, because
@@ -241,7 +241,7 @@ row_merge_rename_index_to_drop(
 	trx_t*		trx,		/*!< in/out: transaction */
 	table_id_t	table_id,	/*!< in: table identifier */
 	index_id_t	index_id)	/*!< in: index identifier */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*********************************************************************//**
 Create the index and load in to the dictionary.
 @return	index, or NULL on error */
@@ -274,7 +274,7 @@ row_merge_drop_table(
 /*=================*/
 	trx_t*		trx,		/*!< in: transaction */
 	dict_table_t*	table)		/*!< in: table instance to drop */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*********************************************************************//**
 Build indexes on a table by reading a clustered index,
 creating a temporary file containing index entries, merge sorting
@@ -307,7 +307,7 @@ row_merge_build_indexes(
 					AUTO_INCREMENT column, or
 					ULINT_UNDEFINED if none is added */
 	ib_sequence_t&	sequence)	/*!< in/out: autoinc sequence */
-	__attribute__((nonnull(1,2,3,5,6,8), warn_unused_result));
+	MY_ATTRIBUTE((nonnull(1,2,3,5,6,8), warn_unused_result));
 /********************************************************************//**
 Write a buffer to a block. */
 UNIV_INTERN
@@ -317,7 +317,7 @@ row_merge_buf_write(
 	const row_merge_buf_t*	buf,	/*!< in: sorted buffer */
 	const merge_file_t*	of,	/*!< in: output file */
 	row_merge_block_t*	block)	/*!< out: buffer for writing to file */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /********************************************************************//**
 Sort a buffer. */
 UNIV_INTERN
@@ -327,7 +327,7 @@ row_merge_buf_sort(
 	row_merge_buf_t*	buf,	/*!< in/out: sort buffer */
 	row_merge_dup_t*	dup)	/*!< in/out: reporter of duplicates
 					(NULL if non-unique index) */
-	__attribute__((nonnull(1)));
+	MY_ATTRIBUTE((nonnull(1)));
 /********************************************************************//**
 Write a merge block to the file system.
 @return TRUE if request was successful, FALSE if fail */
@@ -347,7 +347,7 @@ row_merge_buf_t*
 row_merge_buf_empty(
 /*================*/
 	row_merge_buf_t*	buf)	/*!< in,own: sort buffer */
-	__attribute__((warn_unused_result, nonnull));
+	MY_ATTRIBUTE((warn_unused_result, nonnull));
 
 /** Create a merge file in the given location.
 @param[out]	merge_file	merge file structure
@@ -373,7 +373,7 @@ row_merge_sort(
 					index entries */
 	row_merge_block_t*	block,	/*!< in/out: 3 buffers */
 	int*			tmpfd)	/*!< in/out: temporary file handle */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*********************************************************************//**
 Allocate a sort buffer.
 @return own: sort buffer */
@@ -382,7 +382,7 @@ row_merge_buf_t*
 row_merge_buf_create(
 /*=================*/
 	dict_index_t*	index)	/*!< in: secondary index */
-	__attribute__((warn_unused_result, nonnull, malloc));
+	MY_ATTRIBUTE((warn_unused_result, nonnull, malloc));
 /*********************************************************************//**
 Deallocate a sort buffer. */
 UNIV_INTERN
@@ -390,7 +390,7 @@ void
 row_merge_buf_free(
 /*===============*/
 	row_merge_buf_t*	buf)	/*!< in,own: sort buffer to be freed */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*********************************************************************//**
 Destroy a merge file. */
 UNIV_INTERN
@@ -398,7 +398,7 @@ void
 row_merge_file_destroy(
 /*===================*/
 	merge_file_t*	merge_file)	/*!< in/out: merge file structure */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /********************************************************************//**
 Read a merge block from the file system.
 @return TRUE if request was successful, FALSE if fail */
@@ -428,5 +428,5 @@ row_merge_read_rec(
 					or NULL on end of list
 					(non-NULL on I/O error) */
 	ulint*			offsets)/*!< out: offsets of mrec */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 #endif /* row0merge.h */
--- a/storage/innobase/include/row0mysql.h
+++ b/storage/innobase/include/row0mysql.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 2000, 2012, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 2000, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -167,7 +167,7 @@ row_mysql_handle_errors(
 	trx_t*		trx,	/*!< in: transaction */
 	que_thr_t*	thr,	/*!< in: query thread, or NULL */
 	trx_savept_t*	savept)	/*!< in: savepoint, or NULL */
-	__attribute__((nonnull(1,2)));
+	MY_ATTRIBUTE((nonnull(1,2)));
 /********************************************************************//**
 Create a prebuilt struct for a MySQL table handle.
 @return	own: a prebuilt struct */
@@ -209,7 +209,7 @@ row_lock_table_autoinc_for_mysql(
 /*=============================*/
 	row_prebuilt_t*	prebuilt)	/*!< in: prebuilt struct in the MySQL
 					table handle */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*********************************************************************//**
 Sets a table lock on the table mentioned in prebuilt.
 @return	error code or DB_SUCCESS */
@@ -225,7 +225,7 @@ row_lock_table_for_mysql(
 					prebuilt->select_lock_type */
 	ulint		mode)		/*!< in: lock mode of table
 					(ignored if table==NULL) */
-	__attribute__((nonnull(1)));
+	MY_ATTRIBUTE((nonnull(1)));
 /*********************************************************************//**
 Does an insert for MySQL.
 @return	error code or DB_SUCCESS */
@@ -236,7 +236,7 @@ row_insert_for_mysql(
 	byte*		mysql_rec,	/*!< in: row in the MySQL format */
 	row_prebuilt_t*	prebuilt)	/*!< in: prebuilt struct in MySQL
 					handle */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*********************************************************************//**
 Builds a dummy query graph used in selects. */
 UNIV_INTERN
@@ -276,7 +276,7 @@ row_update_for_mysql(
 					the MySQL format */
 	row_prebuilt_t*	prebuilt)	/*!< in: prebuilt struct in MySQL
 					handle */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*********************************************************************//**
 This can only be used when srv_locks_unsafe_for_binlog is TRUE or this
 session is using a READ COMMITTED or READ UNCOMMITTED isolation level.
@@ -297,7 +297,7 @@ row_unlock_for_mysql(
 					the records under pcur and
 					clust_pcur, and we do not need
 					to reposition the cursors. */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*********************************************************************//**
 Checks if a table name contains the string "/#sql" which denotes temporary
 tables in MySQL.
@@ -306,7 +306,7 @@ UNIV_INTERN
 bool
 row_is_mysql_tmp_table_name(
 /*========================*/
-	const char*	name) __attribute__((warn_unused_result));
+	const char*	name) MY_ATTRIBUTE((warn_unused_result));
 				/*!< in: table name in the form
 				'database/tablename' */
 
@@ -331,7 +331,7 @@ row_update_cascade_for_mysql(
 	upd_node_t*	node,	/*!< in: update node used in the cascade
 				or set null operation */
 	dict_table_t*	table)	/*!< in: table where we do the operation */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*********************************************************************//**
 Locks the data dictionary exclusively for performing a table create or other
 data dictionary modification operation. */
@@ -387,7 +387,7 @@ row_create_table_for_mysql(
 				added to the data dictionary cache) */
 	trx_t*		trx,	/*!< in/out: transaction */
 	bool		commit)	/*!< in: if true, commit the transaction */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*********************************************************************//**
 Does an index creation operation for MySQL. TODO: currently failure
 to create an index results in dropping the whole table! This is no problem
@@ -406,7 +406,7 @@ row_create_index_for_mysql(
 					index columns, which are
 					then checked for not being too
 					large. */
-	__attribute__((nonnull(1,2), warn_unused_result));
+	MY_ATTRIBUTE((nonnull(1,2), warn_unused_result));
 /*********************************************************************//**
 Scans a table create SQL string and adds to the data dictionary
 the foreign key constraints declared in the string. This function
@@ -432,7 +432,7 @@ row_table_add_foreign_constraints(
 	ibool		reject_fks)	/*!< in: if TRUE, fail with error
 					code DB_CANNOT_ADD_CONSTRAINT if
 					any foreign keys are found. */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*********************************************************************//**
 The master thread in srv0srv.cc calls this regularly to drop tables which
 we must drop in background after queries to them have ended. Such lazy
@@ -461,7 +461,7 @@ row_mysql_lock_table(
 	dict_table_t*	table,		/*!< in: table to lock */
 	enum lock_mode	mode,		/*!< in: LOCK_X or LOCK_S */
 	const char*	op_info)	/*!< in: string for trx->op_info */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 /*********************************************************************//**
 Truncates a table for MySQL.
@@ -472,7 +472,7 @@ row_truncate_table_for_mysql(
 /*=========================*/
 	dict_table_t*	table,	/*!< in: table handle */
 	trx_t*		trx)	/*!< in: transaction handle */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*********************************************************************//**
 Drops a table for MySQL.  If the name of the dropped table ends in
 one of "innodb_monitor", "innodb_lock_monitor", "innodb_tablespace_monitor",
@@ -491,7 +491,7 @@ row_drop_table_for_mysql(
 	bool		nonatomic = true)
 				/*!< in: whether it is permitted
 				to release and reacquire dict_operation_lock */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*********************************************************************//**
 Drop all temporary tables during crash recovery. */
 UNIV_INTERN
@@ -510,7 +510,7 @@ row_discard_tablespace_for_mysql(
 /*=============================*/
 	const char*	name,	/*!< in: table name */
 	trx_t*		trx)	/*!< in: transaction handle */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*****************************************************************//**
 Imports a tablespace. The space id in the .ibd file must match the space id
 of the table in the data dictionary.
@@ -521,7 +521,7 @@ row_import_tablespace_for_mysql(
 /*============================*/
 	dict_table_t*	table,		/*!< in/out: table */
 	row_prebuilt_t*	prebuilt)	/*!< in: prebuilt struct in MySQL */
-        __attribute__((nonnull, warn_unused_result));
+        MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*********************************************************************//**
 Drops a database for MySQL.
 @return	error code or DB_SUCCESS */
@@ -531,7 +531,7 @@ row_drop_database_for_mysql(
 /*========================*/
 	const char*	name,	/*!< in: database name which ends to '/' */
 	trx_t*		trx)	/*!< in: transaction handle */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*********************************************************************//**
 Renames a table for MySQL.
 @return	error code or DB_SUCCESS */
@@ -543,7 +543,7 @@ row_rename_table_for_mysql(
 	const char*	new_name,	/*!< in: new table name */
 	trx_t*		trx,		/*!< in/out: transaction */
 	bool		commit)		/*!< in: whether to commit trx */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*********************************************************************//**
 Checks that the index contains entries in an ascending order, unique
 constraint is not broken, and calculates the number of index entries
@@ -558,7 +558,7 @@ row_check_index_for_mysql(
 	const dict_index_t*	index,		/*!< in: index */
 	ulint*			n_rows)		/*!< out: number of entries
 						seen in the consistent read */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*********************************************************************//**
 Determines if a table is a magic monitor table.
 @return	true if monitor table */
@@ -568,7 +568,7 @@ row_is_magic_monitor_table(
 /*=======================*/
 	const char*	table_name)	/*!< in: name of the table, in the
 					form database/table_name */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*********************************************************************//**
 Initialize this module */
 UNIV_INTERN
@@ -593,7 +593,7 @@ row_mysql_table_id_reassign(
 	dict_table_t*	table,	/*!< in/out: table */
 	trx_t*		trx,	/*!< in/out: transaction */
 	table_id_t*	new_id) /*!< out: new table id */
-        __attribute__((nonnull, warn_unused_result));
+        MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 /* A struct describing a place for an individual column in the MySQL
 row format which is presented to the table handler in ha_innobase.
--- a/storage/innobase/include/row0purge.h
+++ b/storage/innobase/include/row0purge.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1997, 2015, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1997, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -47,7 +47,7 @@ row_purge_node_create(
 	que_thr_t*	parent,		/*!< in: parent node, i.e., a
 					thr node */
 	mem_heap_t*	heap)		/*!< in: memory heap where created */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /***********************************************************//**
 Determines if it is possible to remove a secondary index entry.
 Removal is possible if the secondary index entry does not refer to any
@@ -70,7 +70,7 @@ row_purge_poss_sec(
 	purge_node_t*	node,	/*!< in/out: row purge node */
 	dict_index_t*	index,	/*!< in: secondary index */
 	const dtuple_t*	entry)	/*!< in: secondary index entry */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /***************************************************************
 Does the purge operation for a single undo log record. This is a high-level
 function used in an SQL execution graph.
@@ -80,7 +80,7 @@ que_thr_t*
 row_purge_step(
 /*===========*/
 	que_thr_t*	thr)	/*!< in: query thread */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 /* Purge node structure */
 
--- a/storage/innobase/include/row0quiesce.h
+++ b/storage/innobase/include/row0quiesce.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 2012, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 2012, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -43,7 +43,7 @@ row_quiesce_table_start(
 /*====================*/
 	dict_table_t*	table,		/*!< in: quiesce this table */
 	trx_t*		trx)		/*!< in/out: transaction/session */
-        __attribute__((nonnull));
+        MY_ATTRIBUTE((nonnull));
 
 /*********************************************************************//**
 Set a table's quiesce state.
@@ -55,7 +55,7 @@ row_quiesce_set_state(
 	dict_table_t*	table,		/*!< in: quiesce this table */
 	ib_quiesce_t	state,		/*!< in: quiesce state to set */
 	trx_t*		trx)		/*!< in/out: transaction */
-        __attribute__((nonnull, warn_unused_result));
+        MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 /*********************************************************************//**
 Cleanup after table quiesce. */
@@ -65,7 +65,7 @@ row_quiesce_table_complete(
 /*=======================*/
 	dict_table_t*	table,		/*!< in: quiesce this table */
 	trx_t*		trx)		/*!< in/out: transaction/session */
-        __attribute__((nonnull));
+        MY_ATTRIBUTE((nonnull));
 
 #ifndef UNIV_NONINL
 #include "row0quiesce.ic"
--- a/storage/innobase/include/row0row.h
+++ b/storage/innobase/include/row0row.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1996, 2012, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1996, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -47,7 +47,7 @@ row_get_trx_id_offset(
 /*==================*/
 	const dict_index_t*	index,	/*!< in: clustered index */
 	const ulint*		offsets)/*!< in: record offsets */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*********************************************************************//**
 Reads the trx id field from a clustered index record.
 @return	value of the field */
@@ -58,7 +58,7 @@ row_get_rec_trx_id(
 	const rec_t*		rec,	/*!< in: record */
 	const dict_index_t*	index,	/*!< in: clustered index */
 	const ulint*		offsets)/*!< in: rec_get_offsets(rec, index) */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*********************************************************************//**
 Reads the roll pointer field from a clustered index record.
 @return	value of the field */
@@ -69,7 +69,7 @@ row_get_rec_roll_ptr(
 	const rec_t*		rec,	/*!< in: record */
 	const dict_index_t*	index,	/*!< in: clustered index */
 	const ulint*		offsets)/*!< in: rec_get_offsets(rec, index) */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*****************************************************************//**
 When an insert or purge to a table is performed, this function builds
 the entry to be inserted into or purged from an index on the table.
@@ -88,7 +88,7 @@ row_build_index_entry_low(
 	mem_heap_t*		heap)	/*!< in: memory heap from which
 					the memory for the index entry
 					is allocated */
-	__attribute__((warn_unused_result, nonnull(1,3,4)));
+	MY_ATTRIBUTE((warn_unused_result, nonnull(1,3,4)));
 /*****************************************************************//**
 When an insert or purge to a table is performed, this function builds
 the entry to be inserted into or purged from an index on the table.
@@ -107,7 +107,7 @@ row_build_index_entry(
 	mem_heap_t*		heap)	/*!< in: memory heap from which
 					the memory for the index entry
 					is allocated */
-	__attribute__((warn_unused_result, nonnull(1,3,4)));
+	MY_ATTRIBUTE((warn_unused_result, nonnull(1,3,4)));
 /*******************************************************************//**
 An inverse function to row_build_index_entry. Builds a row from a
 record in a clustered index.
@@ -155,7 +155,7 @@ row_build(
 					prefixes, or NULL */
 	mem_heap_t*		heap)	/*!< in: memory heap from which
 					the memory needed is allocated */
-	__attribute__((nonnull(2,3,9)));
+	MY_ATTRIBUTE((nonnull(2,3,9)));
 /*******************************************************************//**
 Converts an index record to a typed data tuple.
 @return index entry built; does not set info_bits, and the data fields
@@ -171,7 +171,7 @@ row_rec_to_index_entry_low(
 					stored columns */
 	mem_heap_t*		heap)	/*!< in: memory heap from which
 					the memory needed is allocated */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*******************************************************************//**
 Converts an index record to a typed data tuple. NOTE that externally
 stored (often big) fields are NOT copied to heap.
@@ -187,7 +187,7 @@ row_rec_to_index_entry(
 					stored columns */
 	mem_heap_t*		heap)	/*!< in: memory heap from which
 					the memory needed is allocated */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*******************************************************************//**
 Builds from a secondary index record a row reference with which we can
 search the clustered index record.
@@ -210,7 +210,7 @@ row_build_row_ref(
 				as long as the row reference is used! */
 	mem_heap_t*	heap)	/*!< in: memory heap from which the memory
 				needed is allocated */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*******************************************************************//**
 Builds from a secondary index record a row reference with which we can
 search the clustered index record. */
@@ -232,7 +232,7 @@ row_build_row_ref_in_tuple(
 	ulint*			offsets,/*!< in: rec_get_offsets(rec, index)
 					or NULL */
 	trx_t*			trx)	/*!< in: transaction or NULL */
-	__attribute__((nonnull(1,2,3)));
+	MY_ATTRIBUTE((nonnull(1,2,3)));
 /*******************************************************************//**
 Builds from a secondary index record a row reference with which we can
 search the clustered index record. */
@@ -263,7 +263,7 @@ row_search_on_row_ref(
 	const dict_table_t*	table,	/*!< in: table */
 	const dtuple_t*		ref,	/*!< in: row reference */
 	mtr_t*			mtr)	/*!< in/out: mtr */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*********************************************************************//**
 Fetches the clustered index record for a secondary index record. The latches
 on the secondary index record are preserved.
@@ -277,7 +277,7 @@ row_get_clust_rec(
 	dict_index_t*	index,	/*!< in: secondary index */
 	dict_index_t**	clust_index,/*!< out: clustered index */
 	mtr_t*		mtr)	/*!< in: mtr */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 /** Result of row_search_index_entry */
 enum row_search_result {
@@ -305,7 +305,7 @@ row_search_index_entry(
 	btr_pcur_t*	pcur,	/*!< in/out: persistent cursor, which must
 				be closed by the caller */
 	mtr_t*		mtr)	/*!< in: mtr */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 #define ROW_COPY_DATA		1
 #define ROW_COPY_POINTERS	2
@@ -334,7 +334,7 @@ row_raw_format(
 	char*			buf,		/*!< out: output buffer */
 	ulint			buf_size)	/*!< in: output buffer size
 						in bytes */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 #ifndef UNIV_NONINL
 #include "row0row.ic"
--- a/storage/innobase/include/row0sel.h
+++ b/storage/innobase/include/row0sel.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1997, 2012, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1997, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -168,7 +168,7 @@ row_search_for_mysql(
 					then prebuilt must have a pcur
 					with stored position! In opening of a
 					cursor 'direction' should be 0. */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*******************************************************************//**
 Checks if MySQL at the moment is allowed for this table to retrieve a
 consistent read result, or store it to the query cache.
@@ -190,7 +190,7 @@ row_search_max_autoinc(
 	dict_index_t*	index,		/*!< in: index to search */
 	const char*	col_name,	/*!< in: autoinc column name */
 	ib_uint64_t*	value)		/*!< out: AUTOINC value read */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 /** A structure for caching column values for prefetched rows */
 struct sel_buf_t{
--- a/storage/innobase/include/row0uins.h
+++ b/storage/innobase/include/row0uins.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1997, 2012, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1997, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -46,7 +46,7 @@ dberr_t
 row_undo_ins(
 /*=========*/
 	undo_node_t*	node)	/*!< in: row undo node */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 #ifndef UNIV_NONINL
 #include "row0uins.ic"
 #endif
--- a/storage/innobase/include/row0umod.h
+++ b/storage/innobase/include/row0umod.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1997, 2012, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1997, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -43,7 +43,7 @@ row_undo_mod(
 /*=========*/
 	undo_node_t*	node,	/*!< in: row undo node */
 	que_thr_t*	thr)	/*!< in: query thread */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 #ifndef UNIV_NONINL
 #include "row0umod.ic"
--- a/storage/innobase/include/row0upd.h
+++ b/storage/innobase/include/row0upd.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1996, 2012, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1996, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -91,7 +91,7 @@ upd_get_field_by_field_no(
 /*======================*/
 	const upd_t*	update,	/*!< in: update vector */
 	ulint		no)	/*!< in: field_no */
-	__attribute__((nonnull, pure));
+	MY_ATTRIBUTE((nonnull, pure));
 /*********************************************************************//**
 Writes into the redo log the values of trx id and roll ptr and enough info
 to determine their positions within a clustered index record.
@@ -174,7 +174,7 @@ bool
 row_upd_changes_disowned_external(
 /*==============================*/
 	const upd_t*	update)	/*!< in: update vector */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 #endif /* !UNIV_HOTBACKUP */
 /***********************************************************//**
 Replaces the new column values stored in the update vector to the
@@ -207,7 +207,7 @@ row_upd_build_sec_rec_difference_binary(
 	const ulint*	offsets,/*!< in: rec_get_offsets(rec, index) */
 	const dtuple_t*	entry,	/*!< in: entry to insert */
 	mem_heap_t*	heap)	/*!< in: memory heap from which allocated */
-	__attribute__((warn_unused_result, nonnull));
+	MY_ATTRIBUTE((warn_unused_result, nonnull));
 /***************************************************************//**
 Builds an update vector from those fields, excluding the roll ptr and
 trx id fields, which in an index entry differ from a record that has
@@ -227,7 +227,7 @@ row_upd_build_difference_binary(
 	trx_t*		trx,	/*!< in: transaction (for diagnostics),
 				or NULL */
 	mem_heap_t*	heap)	/*!< in: memory heap from which allocated */
-	__attribute__((nonnull(1,2,3,7), warn_unused_result));
+	MY_ATTRIBUTE((nonnull(1,2,3,7), warn_unused_result));
 /***********************************************************//**
 Replaces the new column values stored in the update vector to the index entry
 given. */
@@ -250,7 +250,7 @@ row_upd_index_replace_new_col_vals_index_pos(
 				does not work for non-clustered indexes. */
 	mem_heap_t*	heap)	/*!< in: memory heap for allocating and
 				copying the new values */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /***********************************************************//**
 Replaces the new column values stored in the update vector to the index entry
 given. */
@@ -269,7 +269,7 @@ row_upd_index_replace_new_col_vals(
 				an upd_field is the clustered index position */
 	mem_heap_t*	heap)	/*!< in: memory heap for allocating and
 				copying the new values */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /***********************************************************//**
 Replaces the new column values stored in the update vector. */
 UNIV_INTERN
@@ -311,7 +311,7 @@ row_upd_changes_ord_field_binary_func(
 				compile time */
 	const row_ext_t*ext)	/*!< NULL, or prefixes of the externally
 				stored columns in the old row */
-	__attribute__((nonnull(1,2), warn_unused_result));
+	MY_ATTRIBUTE((nonnull(1,2), warn_unused_result));
 #ifdef UNIV_DEBUG
 # define row_upd_changes_ord_field_binary(index,update,thr,row,ext)	\
 	row_upd_changes_ord_field_binary_func(index,update,thr,row,ext)
@@ -338,7 +338,7 @@ row_upd_changes_doc_id(
 /*===================*/
 	dict_table_t*	table,		/*!< in: table */
 	upd_field_t*	upd_field)	/*!< in: field to check */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /***********************************************************//**
 Checks if an update vector changes an ordering field of an index record.
 This function is fast if the update vector is short or the number of ordering
--- a/storage/innobase/include/row0vers.h
+++ b/storage/innobase/include/row0vers.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1997, 2012, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1997, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -110,7 +110,7 @@ row_vers_build_for_consistent_read(
 				if the history is missing or the record
 				does not exist in the view, that is,
 				it was freshly inserted afterwards */
-	__attribute__((nonnull(1,2,3,4,5,6,7)));
+	MY_ATTRIBUTE((nonnull(1,2,3,4,5,6,7)));
 
 /*****************************************************************//**
 Constructs the last committed version of a clustered index record,
@@ -136,7 +136,7 @@ row_vers_build_for_semi_consistent_read(
 	const rec_t**	old_vers)/*!< out: rec, old version, or NULL if the
 				record does not exist in the view, that is,
 				it was freshly inserted afterwards */
-	__attribute__((nonnull(1,2,3,4,5)));
+	MY_ATTRIBUTE((nonnull(1,2,3,4,5)));
 
 
 #ifndef UNIV_NONINL
--- a/storage/innobase/include/srv0srv.h
+++ b/storage/innobase/include/srv0srv.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1995, 2015, Oracle and/or its affiliates. All rights reserved.
+Copyright (c) 1995, 2016, Oracle and/or its affiliates. All rights reserved.
 Copyright (c) 2008, 2009, Google Inc.
 Copyright (c) 2009, Percona Inc.
 
@@ -734,7 +734,7 @@ UNIV_INTERN
 os_thread_ret_t
 DECLARE_THREAD(srv_purge_coordinator_thread)(
 /*=========================================*/
-	void*	arg __attribute__((unused)));	/*!< in: a dummy parameter
+	void*	arg MY_ATTRIBUTE((unused)));	/*!< in: a dummy parameter
 						required by os_thread_create */
 
 /*********************************************************************//**
@@ -744,7 +744,7 @@ UNIV_INTERN
 os_thread_ret_t
 DECLARE_THREAD(srv_worker_thread)(
 /*==============================*/
-	void*	arg __attribute__((unused)));	/*!< in: a dummy parameter
+	void*	arg MY_ATTRIBUTE((unused)));	/*!< in: a dummy parameter
 						required by os_thread_create */
 } /* extern "C" */
 
--- a/storage/innobase/include/srv0start.h
+++ b/storage/innobase/include/srv0start.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1995, 2012, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1995, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -105,7 +105,7 @@ srv_path_copy(
 	ulint		dest_len,	/*!< in: max bytes to copy */
 	const char*	basedir,	/*!< in: base directory */
 	const char*	table_name)	/*!< in: source table name */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 
 /*****************************************************************//**
 Get the meta-data filename from the table name. */
@@ -116,7 +116,7 @@ srv_get_meta_data_filename(
 	dict_table_t*	table,		/*!< in: table */
 	char*			filename,	/*!< out: filename */
 	ulint			max_len)	/*!< in: filename max length */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /** Log sequence number at shutdown */
 extern	lsn_t	srv_shutdown_lsn;
--- a/storage/innobase/include/sync0arr.h
+++ b/storage/innobase/include/sync0arr.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1995, 2013, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1995, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -110,7 +110,7 @@ sync_array_print_long_waits(
 /*========================*/
 	os_thread_id_t*	waiter,	/*!< out: longest waiting thread */
 	const void**	sema)	/*!< out: longest-waited-for semaphore */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /********************************************************************//**
 Validates the integrity of the wait array. Checks
 that the number of reserved cells equals the count variable. */
--- a/storage/innobase/include/sync0rw.h
+++ b/storage/innobase/include/sync0rw.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1995, 2014, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1995, 2016, Oracle and/or its affiliates. All Rights Reserved.
 Copyright (c) 2008, Google Inc.
 
 Portions of this file contain modifications contributed and copyrighted by
@@ -333,7 +333,7 @@ ibool
 rw_lock_s_lock_low(
 /*===============*/
 	rw_lock_t*	lock,	/*!< in: pointer to rw-lock */
-	ulint		pass __attribute__((unused)),
+	ulint		pass MY_ATTRIBUTE((unused)),
 				/*!< in: pass value; != 0, if the lock will be
 				passed to another thread to unlock */
 	const char*	file_name, /*!< in: file name where lock requested */
@@ -501,7 +501,7 @@ rw_lock_own(
 	rw_lock_t*	lock,		/*!< in: rw-lock */
 	ulint		lock_type)	/*!< in: lock type: RW_LOCK_SHARED,
 					RW_LOCK_EX */
-	__attribute__((warn_unused_result));
+	MY_ATTRIBUTE((warn_unused_result));
 #endif /* UNIV_SYNC_DEBUG */
 /******************************************************************//**
 Checks if somebody has locked the rw-lock in the specified mode. */
--- a/storage/innobase/include/sync0rw.ic
+++ b/storage/innobase/include/sync0rw.ic
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1995, 2011, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1995, 2016, Oracle and/or its affiliates. All Rights Reserved.
 Copyright (c) 2008, Google Inc.
 
 Portions of this file contain modifications contributed and copyrighted by
@@ -306,7 +306,7 @@ ibool
 rw_lock_s_lock_low(
 /*===============*/
 	rw_lock_t*	lock,	/*!< in: pointer to rw-lock */
-	ulint		pass __attribute__((unused)),
+	ulint		pass MY_ATTRIBUTE((unused)),
 				/*!< in: pass value; != 0, if the lock will be
 				passed to another thread to unlock */
 	const char*	file_name, /*!< in: file name where lock requested */
--- a/storage/innobase/include/sync0sync.h
+++ b/storage/innobase/include/sync0sync.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1995, 2015, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1995, 2016, Oracle and/or its affiliates. All Rights Reserved.
 Copyright (c) 2008, Google Inc.
 Copyright (c) 2012, Facebook Inc.
 
@@ -400,7 +400,7 @@ ibool
 mutex_own(
 /*======*/
 	const ib_mutex_t*	mutex)	/*!< in: mutex */
-	__attribute__((warn_unused_result));
+	MY_ATTRIBUTE((warn_unused_result));
 #endif /* UNIV_DEBUG */
 #ifdef UNIV_SYNC_DEBUG
 /******************************************************************//**
@@ -415,7 +415,7 @@ sync_thread_add_level(
 	ulint	level,	/*!< in: level in the latching order; if
 			SYNC_LEVEL_VARYING, nothing is done */
 	ibool	relock)	/*!< in: TRUE if re-entering an x-lock */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /******************************************************************//**
 Removes a latch from the thread level array if it is found there.
 @return TRUE if found in the array; it is no error if the latch is
@@ -445,7 +445,7 @@ sync_thread_levels_nonempty_gen(
 /*============================*/
 	ibool	dict_mutex_allowed)	/*!< in: TRUE if dictionary mutex is
 					allowed to be owned by the thread */
-	__attribute__((warn_unused_result));
+	MY_ATTRIBUTE((warn_unused_result));
 /******************************************************************//**
 Checks if the level array for the current thread is empty,
 except for data dictionary latches. */
@@ -462,7 +462,7 @@ sync_thread_levels_nonempty_trx(
 	ibool	has_search_latch)
 				/*!< in: TRUE if and only if the thread
 				is supposed to hold btr_search_latch */
-	__attribute__((warn_unused_result));
+	MY_ATTRIBUTE((warn_unused_result));
 
 /******************************************************************//**
 Gets the debug information for a reserved mutex. */
--- a/storage/innobase/include/trx0rec.h
+++ b/storage/innobase/include/trx0rec.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1996, 2013, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1996, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -86,7 +86,7 @@ ulint
 trx_undo_rec_get_offset(
 /*====================*/
 	undo_no_t	undo_no)	/*!< in: undo no read from node */
-	__attribute__((const));
+	MY_ATTRIBUTE((const));
 
 /**********************************************************************//**
 Returns the start of the undo record data area. */
@@ -109,7 +109,7 @@ trx_undo_rec_get_pars(
 					externally stored fild */
 	undo_no_t*	undo_no,	/*!< out: undo log record number */
 	table_id_t*	table_id)	/*!< out: table id */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*******************************************************************//**
 Builds a row reference from an undo log record.
 @return	pointer to remaining part of undo record */
@@ -201,7 +201,7 @@ trx_undo_rec_get_partial_row(
 				only in the assertion. */
 	mem_heap_t*	heap)	/*!< in: memory heap from which the memory
 				needed is allocated */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /***********************************************************************//**
 Writes information to an undo log about an insert, update, or a delete marking
 of a clustered index record. This information is used in a rollback of the
@@ -233,7 +233,7 @@ trx_undo_report_row_operation(
 					inserted undo log record,
 					0 if BTR_NO_UNDO_LOG
 					flag was specified */
-	__attribute__((nonnull(3,4,10), warn_unused_result));
+	MY_ATTRIBUTE((nonnull(3,4,10), warn_unused_result));
 /******************************************************************//**
 Copies an undo record to heap. This function can be called if we know that
 the undo log record exists.
@@ -244,7 +244,7 @@ trx_undo_get_undo_rec_low(
 /*======================*/
 	roll_ptr_t	roll_ptr,	/*!< in: roll pointer to record */
 	mem_heap_t*	heap)		/*!< in: memory heap where copied */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*******************************************************************//**
 Build a previous version of a clustered index record. The caller must
 hold a latch on the index page of the clustered index record.
@@ -268,7 +268,7 @@ trx_undo_prev_version_build(
 	rec_t**		old_vers)/*!< out, own: previous version, or NULL if
 				rec is the first inserted version, or if
 				history data has been deleted */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 #endif /* !UNIV_HOTBACKUP */
 /***********************************************************//**
 Parses a redo log record of adding an undo log record.
--- a/storage/innobase/include/trx0roll.h
+++ b/storage/innobase/include/trx0roll.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1996, 2014, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1996, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -125,7 +125,7 @@ extern "C" UNIV_INTERN
 os_thread_ret_t
 DECLARE_THREAD(trx_rollback_or_clean_all_recovered)(
 /*================================================*/
-	void*	arg __attribute__((unused)));
+	void*	arg MY_ATTRIBUTE((unused)));
 			/*!< in: a dummy parameter required by
 			os_thread_create */
 /*********************************************************************//**
@@ -152,7 +152,7 @@ dberr_t
 trx_rollback_for_mysql(
 /*===================*/
 	trx_t*	trx)	/*!< in/out: transaction */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*******************************************************************//**
 Rollback the latest SQL statement for MySQL.
 @return	error code or DB_SUCCESS */
@@ -161,7 +161,7 @@ dberr_t
 trx_rollback_last_sql_stat_for_mysql(
 /*=================================*/
 	trx_t*	trx)	/*!< in/out: transaction */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*******************************************************************//**
 Rollback a transaction to a given savepoint or do a complete rollback.
 @return	error code or DB_SUCCESS */
@@ -173,7 +173,7 @@ trx_rollback_to_savepoint(
 	trx_savept_t*	savept)	/*!< in: pointer to savepoint undo number, if
 				partial rollback requested, or NULL for
 				complete rollback */
-	__attribute__((nonnull(1)));
+	MY_ATTRIBUTE((nonnull(1)));
 /*******************************************************************//**
 Rolls back a transaction back to a named savepoint. Modifications after the
 savepoint are undone but InnoDB does NOT release the corresponding locks
@@ -195,7 +195,7 @@ trx_rollback_to_savepoint_for_mysql(
 						information to remove the
 						binlog entries of the queries
 						executed after the savepoint */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*******************************************************************//**
 Creates a named savepoint. If the transaction is not yet started, starts it.
 If there is already a savepoint of the same name, this call erases that old
@@ -212,7 +212,7 @@ trx_savepoint_for_mysql(
 						position corresponding to this
 						connection at the time of the
 						savepoint */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /*******************************************************************//**
 Releases a named savepoint. Savepoints which
 were set after this savepoint are deleted.
@@ -224,7 +224,7 @@ trx_release_savepoint_for_mysql(
 /*============================*/
 	trx_t*		trx,			/*!< in: transaction handle */
 	const char*	savepoint_name)		/*!< in: savepoint name */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /*******************************************************************//**
 Frees savepoint structs starting from savep. */
 UNIV_INTERN
--- a/storage/innobase/include/trx0sys.h
+++ b/storage/innobase/include/trx0sys.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1996, 2012, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1996, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -267,7 +267,7 @@ ibool
 trx_in_trx_list(
 /*============*/
 	const trx_t*	in_trx)		/*!< in: transaction */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 #endif /* UNIV_DEBUG */
 #if defined UNIV_DEBUG || defined UNIV_BLOB_LIGHT_DEBUG
 /***********************************************************//**
@@ -278,7 +278,7 @@ ibool
 trx_assert_recovered(
 /*=================*/
 	trx_id_t	trx_id)		/*!< in: transaction identifier */
-	__attribute__((warn_unused_result));
+	MY_ATTRIBUTE((warn_unused_result));
 #endif /* UNIV_DEBUG || UNIV_BLOB_LIGHT_DEBUG */
 /*****************************************************************//**
 Updates the offset information about the end of the MySQL binlog entry
--- a/storage/innobase/include/trx0trx.h
+++ b/storage/innobase/include/trx0trx.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1996, 2013, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1996, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -103,7 +103,7 @@ void
 trx_free_prepared(
 /*==============*/
 	trx_t*	trx)	/*!< in, own: trx object */
-	UNIV_COLD __attribute__((nonnull));
+	UNIV_COLD MY_ATTRIBUTE((nonnull));
 /********************************************************************//**
 Frees a transaction object for MySQL. */
 UNIV_INTERN
@@ -169,7 +169,7 @@ trx_start_for_ddl_low(
 /*==================*/
 	trx_t*		trx,	/*!< in/out: transaction */
 	trx_dict_op_t	op)	/*!< in: dictionary operation type */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 #ifdef UNIV_DEBUG
 #define trx_start_for_ddl(t, o)					\
@@ -191,7 +191,7 @@ void
 trx_commit(
 /*=======*/
 	trx_t*	trx)	/*!< in/out: transaction */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /****************************************************************//**
 Commits a transaction and a mini-transaction. */
 UNIV_INTERN
@@ -201,7 +201,7 @@ trx_commit_low(
 	trx_t*	trx,	/*!< in/out: transaction */
 	mtr_t*	mtr)	/*!< in/out: mini-transaction (will be committed),
 			or NULL if trx made no modifications */
-	__attribute__((nonnull(1)));
+	MY_ATTRIBUTE((nonnull(1)));
 /****************************************************************//**
 Cleans up a transaction at database startup. The cleanup is needed if
 the transaction already got to the middle of a commit when the database
@@ -255,7 +255,7 @@ void
 trx_commit_complete_for_mysql(
 /*==========================*/
 	trx_t*	trx)	/*!< in/out: transaction */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 /**********************************************************************//**
 Marks the latest SQL statement ended. */
 UNIV_INTERN
@@ -317,7 +317,7 @@ trx_print_low(
 			/*!< in: length of trx->lock.trx_locks */
 	ulint		heap_size)
 			/*!< in: mem_heap_get_size(trx->lock.lock_heap) */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /**********************************************************************//**
 Prints info about a transaction.
@@ -331,7 +331,7 @@ trx_print_latched(
 	const trx_t*	trx,		/*!< in: transaction */
 	ulint		max_query_len)	/*!< in: max query length to print,
 					or 0 to use the default max length */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /**********************************************************************//**
 Prints info about a transaction.
@@ -344,7 +344,7 @@ trx_print(
 	const trx_t*	trx,		/*!< in: transaction */
 	ulint		max_query_len)	/*!< in: max query length to print,
 					or 0 to use the default max length */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 /**********************************************************************//**
 Determine if a transaction is a dictionary operation.
@@ -354,7 +354,7 @@ enum trx_dict_op_t
 trx_get_dict_operation(
 /*===================*/
 	const trx_t*	trx)	/*!< in: transaction */
-	__attribute__((pure));
+	MY_ATTRIBUTE((pure));
 /**********************************************************************//**
 Flag a transaction a dictionary operation. */
 UNIV_INLINE
@@ -383,7 +383,7 @@ trx_state_eq(
 				if state != TRX_STATE_NOT_STARTED
 				asserts that
 				trx->state != TRX_STATE_NOT_STARTED */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 # ifdef UNIV_DEBUG
 /**********************************************************************//**
 Asserts that a transaction has been started.
@@ -394,7 +394,7 @@ ibool
 trx_assert_started(
 /*===============*/
 	const trx_t*	trx)	/*!< in: transaction */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 # endif /* UNIV_DEBUG */
 
 /**********************************************************************//**
--- a/storage/innobase/include/trx0undo.h
+++ b/storage/innobase/include/trx0undo.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1996, 2013, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1996, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -73,7 +73,7 @@ bool
 trx_undo_trx_id_is_insert(
 /*======================*/
 	const byte*	trx_id)	/*!< in: DB_TRX_ID, followed by DB_ROLL_PTR */
-	__attribute__((nonnull, pure, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, pure, warn_unused_result));
 #endif /* !UNIV_HOTBACKUP */
 /*****************************************************************//**
 Writes a roll ptr to an index page. In case that the size changes in
@@ -214,7 +214,7 @@ trx_undo_add_page(
 	mtr_t*		mtr)	/*!< in: mtr which does not have a latch to any
 				undo log page; the caller must have reserved
 				the rollback segment mutex */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /********************************************************************//**
 Frees the last undo log page.
 The caller must hold the rollback segment mutex. */
@@ -229,7 +229,7 @@ trx_undo_free_last_page_func(
 	mtr_t*		mtr)	/*!< in/out: mini-transaction which does not
 				have a latch to any undo log page or which
 				has allocated the undo log page */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 #ifdef UNIV_DEBUG
 # define trx_undo_free_last_page(trx,undo,mtr)	\
 	trx_undo_free_last_page_func(trx,undo,mtr)
@@ -251,7 +251,7 @@ trx_undo_truncate_end_func(
 	trx_undo_t*	undo,	/*!< in/out: undo log */
 	undo_no_t	limit)	/*!< in: all undo records with undo number
 				>= this value should be truncated */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 #ifdef UNIV_DEBUG
 # define trx_undo_truncate_end(trx,undo,limit)		\
 	trx_undo_truncate_end_func(trx,undo,limit)
@@ -300,7 +300,7 @@ trx_undo_assign_undo(
 /*=================*/
 	trx_t*		trx,	/*!< in: transaction */
 	ulint		type)	/*!< in: TRX_UNDO_INSERT or TRX_UNDO_UPDATE */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 /******************************************************************//**
 Sets the state of the undo log segment at a transaction finish.
 @return	undo log segment header page, x-latched */
@@ -350,7 +350,7 @@ void
 trx_undo_free_prepared(
 /*===================*/
 	trx_t*	trx)	/*!< in/out: PREPARED transaction */
-	UNIV_COLD __attribute__((nonnull));
+	UNIV_COLD MY_ATTRIBUTE((nonnull));
 #endif /* !UNIV_HOTBACKUP */
 /***********************************************************//**
 Parses the redo log entry of an undo log page initialization.
--- a/storage/innobase/include/univ.i
+++ b/storage/innobase/include/univ.i
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1994, 2013, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1994, 2016, Oracle and/or its affiliates. All Rights Reserved.
 Copyright (c) 2008, Google Inc.
 
 Portions of this file contain modifications contributed and copyrighted by
@@ -249,7 +249,7 @@ that are only referenced from within InnoDB, not from MySQL. We disable the
 GCC visibility directive on all Sun operating systems because there is no
 easy way to get it to work. See http://bugs.mysql.com/bug.php?id=52263. */
 #if defined(__GNUC__) && (__GNUC__ >= 4) && !defined(sun) || defined(__INTEL_COMPILER)
-# define UNIV_INTERN __attribute__((visibility ("hidden")))
+# define UNIV_INTERN MY_ATTRIBUTE((visibility ("hidden")))
 #else
 # define UNIV_INTERN
 #endif
@@ -264,7 +264,7 @@ appears close together improving code locality of non-cold parts of
 program.  The paths leading to call of cold functions within code are
 marked as unlikely by the branch prediction mechanism.  optimize a
 rarely invoked function for size instead for speed. */
-# define UNIV_COLD __attribute__((cold))
+# define UNIV_COLD MY_ATTRIBUTE((cold))
 #else
 # define UNIV_COLD /* empty */
 #endif
@@ -528,7 +528,7 @@ contains the sum of the following flag and the locally stored len. */
 #if defined(__GNUC__) && (__GNUC__ > 2) && ! defined(__INTEL_COMPILER)
 #define HAVE_GCC_GT_2
 /* Tell the compiler that variable/function is unused. */
-# define UNIV_UNUSED    __attribute__ ((unused))
+# define UNIV_UNUSED    MY_ATTRIBUTE ((unused))
 #else
 # define UNIV_UNUSED
 #endif /* CHECK FOR GCC VER_GT_2 */
--- a/storage/innobase/include/ut0byte.h
+++ b/storage/innobase/include/ut0byte.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1994, 2009, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1994, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -39,7 +39,7 @@ ut_ull_create(
 /*==========*/
 	ulint	high,	/*!< in: high-order 32 bits */
 	ulint	low)	/*!< in: low-order 32 bits */
-	__attribute__((const));
+	MY_ATTRIBUTE((const));
 
 /********************************************************//**
 Rounds a 64-bit integer downward to a multiple of a power of 2.
@@ -80,7 +80,7 @@ ut_align_down(
 /*==========*/
 	const void*	ptr,		/*!< in: pointer */
 	ulint		align_no)	/*!< in: align by this number */
-		__attribute__((const));
+		MY_ATTRIBUTE((const));
 /*********************************************************//**
 The following function computes the offset of a pointer from the nearest
 aligned address.
@@ -91,7 +91,7 @@ ut_align_offset(
 /*============*/
 	const void*	ptr,		/*!< in: pointer */
 	ulint		align_no)	/*!< in: align by this number */
-			__attribute__((const));
+			MY_ATTRIBUTE((const));
 /*****************************************************************//**
 Gets the nth bit of a ulint.
 @return	TRUE if nth bit is 1; 0th bit is defined to be the least significant */
--- a/storage/innobase/include/ut0dbg.h
+++ b/storage/innobase/include/ut0dbg.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1994, 2009, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1994, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -59,7 +59,7 @@ ut_dbg_assertion_failed(
 	const char*	expr,	/*!< in: the failed assertion */
 	const char*	file,	/*!< in: source file containing the assertion */
 	ulint		line)	/*!< in: line number of the assertion */
-	UNIV_COLD __attribute__((nonnull(2)));
+	UNIV_COLD MY_ATTRIBUTE((nonnull(2)));
 
 /** Abort the execution. */
 # define UT_DBG_PANIC abort()
--- a/storage/innobase/include/ut0mem.h
+++ b/storage/innobase/include/ut0mem.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1994, 2011, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1994, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -87,7 +87,7 @@ ut_malloc_low(
 	ulint	n,			/*!< in: number of bytes to allocate */
 	ibool	assert_on_error)	/*!< in: if TRUE, we crash mysqld if
 					the memory cannot be allocated */
-	__attribute__((malloc));
+	MY_ATTRIBUTE((malloc));
 /**********************************************************************//**
 Allocates memory. */
 #define ut_malloc(n) ut_malloc_low(n, TRUE)
--- a/storage/innobase/include/ut0rnd.h
+++ b/storage/innobase/include/ut0rnd.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1994, 2009, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1994, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -96,7 +96,7 @@ ulint
 ut_fold_ull(
 /*========*/
 	ib_uint64_t	d)	/*!< in: 64-bit integer */
-	__attribute__((const));
+	MY_ATTRIBUTE((const));
 /*************************************************************//**
 Folds a character string ending in the null character.
 @return	folded value */
@@ -105,7 +105,7 @@ ulint
 ut_fold_string(
 /*===========*/
 	const char*	str)	/*!< in: null-terminated string */
-	__attribute__((pure));
+	MY_ATTRIBUTE((pure));
 /***********************************************************//**
 Looks for a prime number slightly greater than the given argument.
 The prime is chosen so that it is not near any power of 2.
@@ -115,7 +115,7 @@ ulint
 ut_find_prime(
 /*==========*/
 	ulint	n)	/*!< in: positive number > 100 */
-	__attribute__((const));
+	MY_ATTRIBUTE((const));
 
 #endif /* !UNIV_INNOCHECKSUM */
 
@@ -128,7 +128,7 @@ ut_fold_ulint_pair(
 /*===============*/
 	ulint	n1,	/*!< in: ulint */
 	ulint	n2)	/*!< in: ulint */
-	__attribute__((const));
+	MY_ATTRIBUTE((const));
 /*************************************************************//**
 Folds a binary string.
 @return	folded value */
@@ -138,7 +138,7 @@ ut_fold_binary(
 /*===========*/
 	const byte*	str,	/*!< in: string of bytes */
 	ulint		len)	/*!< in: length */
-	__attribute__((pure));
+	MY_ATTRIBUTE((pure));
 
 
 #ifndef UNIV_NONINL
--- a/storage/innobase/include/ut0ut.h
+++ b/storage/innobase/include/ut0ut.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1994, 2014, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1994, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -217,7 +217,7 @@ ulint
 ut_2_power_up(
 /*==========*/
 	ulint	n)	/*!< in: number != 0 */
-	__attribute__((const));
+	MY_ATTRIBUTE((const));
 
 /** Determine how many bytes (groups of 8 bits) are needed to
 store the given number of bits.
@@ -297,7 +297,7 @@ void
 ut_print_timestamp(
 /*===============*/
 	FILE*	file)	/*!< in: file where to print */
-	UNIV_COLD __attribute__((nonnull));
+	UNIV_COLD MY_ATTRIBUTE((nonnull));
 
 #ifndef UNIV_INNOCHECKSUM
 
@@ -485,7 +485,7 @@ ut_ulint_sort(
 	ulint*	aux_arr,	/*!< in/out: aux array to use in sort */
 	ulint	low,		/*!< in: lower bound */
 	ulint	high)		/*!< in: upper bound */
-	__attribute__((nonnull));
+	MY_ATTRIBUTE((nonnull));
 
 #ifndef UNIV_NONINL
 #include "ut0ut.ic"
--- a/storage/innobase/lock/lock0lock.cc
+++ b/storage/innobase/lock/lock0lock.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1996, 2015, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1996, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -409,7 +409,7 @@ ibool
 lock_rec_validate_page(
 /*===================*/
 	const buf_block_t*	block)	/*!< in: buffer block */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 #endif /* UNIV_DEBUG */
 
 /* The lock system */
@@ -493,7 +493,7 @@ Checks that a transaction id is sensible, i.e., not in the future.
 #ifdef UNIV_DEBUG
 UNIV_INTERN
 #else
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 #endif
 bool
 lock_check_trx_id_sanity(
@@ -5779,7 +5779,7 @@ lock_validate_table_locks(
 /*********************************************************************//**
 Validate record locks up to a limit.
 @return lock at limit or NULL if no more locks in the hash bucket */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 const lock_t*
 lock_rec_validate(
 /*==============*/
--- a/storage/innobase/lock/lock0wait.cc
+++ b/storage/innobase/lock/lock0wait.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1996, 2013, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1996, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -479,7 +479,7 @@ extern "C" UNIV_INTERN
 os_thread_ret_t
 DECLARE_THREAD(lock_wait_timeout_thread)(
 /*=====================================*/
-	void*	arg __attribute__((unused)))
+	void*	arg MY_ATTRIBUTE((unused)))
 			/* in: a dummy parameter required by
 			os_thread_create */
 {
--- a/storage/innobase/log/log0log.cc
+++ b/storage/innobase/log/log0log.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1995, 2015, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1995, 2016, Oracle and/or its affiliates. All Rights Reserved.
 Copyright (c) 2009, Google Inc.
 
 Portions of this file contain modifications contributed and copyrighted by
@@ -975,7 +975,7 @@ log_group_init(
 	ulint	space_id,		/*!< in: space id of the file space
 					which contains the log files of this
 					group */
-	ulint	archive_space_id __attribute__((unused)))
+	ulint	archive_space_id MY_ATTRIBUTE((unused)))
 					/*!< in: space id of the file space
 					which contains some archived log
 					files for this group; currently, only
@@ -2352,7 +2352,7 @@ void
 log_archived_file_name_gen(
 /*=======================*/
 	char*	buf,	/*!< in: buffer where to write */
-	ulint	id __attribute__((unused)),
+	ulint	id MY_ATTRIBUTE((unused)),
 			/*!< in: group id;
 			currently we only archive the first group */
 	ulint	file_no)/*!< in: file number */
--- a/storage/innobase/log/log0recv.cc
+++ b/storage/innobase/log/log0recv.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1997, 2015, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1997, 2016, Oracle and/or its affiliates. All Rights Reserved.
 Copyright (c) 2012, Facebook Inc.
 
 This program is free software; you can redistribute it and/or modify it under
@@ -328,7 +328,7 @@ extern "C" UNIV_INTERN
 os_thread_ret_t
 DECLARE_THREAD(recv_writer_thread)(
 /*===============================*/
-	void*	arg __attribute__((unused)))
+	void*	arg MY_ATTRIBUTE((unused)))
 			/*!< in: a dummy parameter required by
 			os_thread_create */
 {
@@ -742,7 +742,7 @@ recv_check_cp_is_consistent(
 /********************************************************//**
 Looks for the maximum consistent checkpoint from the log groups.
 @return	error code or DB_SUCCESS */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 recv_find_max_checkpoint(
 /*=====================*/
--- a/storage/innobase/mem/mem0dbg.cc
+++ b/storage/innobase/mem/mem0dbg.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1994, 2011, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1994, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -248,7 +248,7 @@ void
 mem_field_erase(
 /*============*/
 	byte*	buf,	/*!< in: memory field */
-	ulint	n __attribute__((unused)))
+	ulint	n MY_ATTRIBUTE((unused)))
 			/*!< in: how many bytes the user requested */
 {
 	byte*	usr_buf;
@@ -450,7 +450,7 @@ void
 mem_heap_validate_or_print(
 /*=======================*/
 	mem_heap_t*	heap,	/*!< in: memory heap */
-	byte*		top __attribute__((unused)),
+	byte*		top MY_ATTRIBUTE((unused)),
 				/*!< in: calculate and validate only until
 				this top pointer in the heap is reached,
 				if this pointer is NULL, ignored */
--- a/storage/innobase/mtr/mtr0mtr.cc
+++ b/storage/innobase/mtr/mtr0mtr.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1995, 2013, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1995, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -58,7 +58,7 @@ mtr_block_dirtied(
 
 /*****************************************************************//**
 Releases the item in the slot given. */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 void
 mtr_memo_slot_release_func(
 /*=======================*/
@@ -105,7 +105,7 @@ mtr_memo_slot_release_func(
 Releases the mlocks and other objects stored in an mtr memo.
 They are released in the order opposite to which they were pushed
 to the memo. */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 void
 mtr_memo_pop_all(
 /*=============*/
@@ -395,7 +395,7 @@ mtr_read_ulint(
 /*===========*/
 	const byte*	ptr,	/*!< in: pointer from where to read */
 	ulint		type,	/*!< in: MLOG_1BYTE, MLOG_2BYTES, MLOG_4BYTES */
-	mtr_t*		mtr __attribute__((unused)))
+	mtr_t*		mtr MY_ATTRIBUTE((unused)))
 				/*!< in: mini-transaction handle */
 {
 	ut_ad(mtr->state == MTR_ACTIVE);
--- a/storage/innobase/os/os0file.cc
+++ b/storage/innobase/os/os0file.cc
@@ -1,6 +1,6 @@
 /***********************************************************************
 
-Copyright (c) 1995, 2015, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1995, 2016, Oracle and/or its affiliates. All Rights Reserved.
 Copyright (c) 2009, Percona Inc.
 
 Portions of this file contain modifications contributed and copyrighted
@@ -1469,11 +1469,11 @@ void
 os_file_set_nocache(
 /*================*/
 	int		fd		/*!< in: file descriptor to alter */
-					__attribute__((unused)),
+					MY_ATTRIBUTE((unused)),
 	const char*	file_name	/*!< in: used in the diagnostic
 					message */
-					__attribute__((unused)),
-	const char*	operation_name __attribute__((unused)))
+					MY_ATTRIBUTE((unused)),
+	const char*	operation_name MY_ATTRIBUTE((unused)))
 					/*!< in: "open" or "create"; used
 					in the diagnostic message */
 {
@@ -2353,7 +2353,7 @@ os_file_flush_func(
 /*******************************************************************//**
 Does a synchronous read operation in Posix.
 @return	number of bytes read, -1 if error */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 ssize_t
 os_file_pread(
 /*==========*/
@@ -2464,7 +2464,7 @@ os_file_pread(
 /*******************************************************************//**
 Does a synchronous write operation in Posix.
 @return	number of bytes written, -1 if error */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 ssize_t
 os_file_pwrite(
 /*===========*/
--- a/storage/innobase/page/page0page.cc
+++ b/storage/innobase/page/page0page.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1994, 2015, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1994, 2016, Oracle and/or its affiliates. All Rights Reserved.
 Copyright (c) 2012, Facebook Inc.
 
 This program is free software; you can redistribute it and/or modify it under
@@ -304,7 +304,7 @@ byte*
 page_parse_create(
 /*==============*/
 	byte*		ptr,	/*!< in: buffer */
-	byte*		end_ptr __attribute__((unused)), /*!< in: buffer end */
+	byte*		end_ptr MY_ATTRIBUTE((unused)), /*!< in: buffer end */
 	ulint		comp,	/*!< in: nonzero=compact page format */
 	buf_block_t*	block,	/*!< in: block or NULL */
 	mtr_t*		mtr)	/*!< in: mtr or NULL */
--- a/storage/innobase/page/page0zip.cc
+++ b/storage/innobase/page/page0zip.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 2005, 2015, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 2005, 2016, Oracle and/or its affiliates. All Rights Reserved.
 Copyright (c) 2012, Facebook Inc.
 
 This program is free software; you can redistribute it and/or modify it under
@@ -119,7 +119,7 @@ Compare at most sizeof(field_ref_zero) bytes.
 independently of any UNIV_ debugging conditions. */
 #if defined UNIV_DEBUG || defined UNIV_ZIP_DEBUG
 # include <stdarg.h>
-__attribute__((format (printf, 1, 2)))
+MY_ATTRIBUTE((format (printf, 1, 2)))
 /**********************************************************************//**
 Report a failure to decompress or compress.
 @return	number of characters printed */
@@ -738,8 +738,8 @@ static
 void
 page_zip_free(
 /*==========*/
-	void*	opaque __attribute__((unused)),	/*!< in: memory heap */
-	void*	address __attribute__((unused)))/*!< in: object to free */
+	void*	opaque MY_ATTRIBUTE((unused)),	/*!< in: memory heap */
+	void*	address MY_ATTRIBUTE((unused)))/*!< in: object to free */
 {
 }
 
--- a/storage/innobase/pars/lexyy.cc
+++ b/storage/innobase/pars/lexyy.cc
@@ -295,7 +295,7 @@ static int yy_start = 0;	/* start state number */
 static int yy_did_buffer_switch_on_eof;
 
 void yyrestart (FILE *input_file  );
-__attribute__((unused)) static void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+MY_ATTRIBUTE((unused)) static void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
 static YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
 void yy_delete_buffer (YY_BUFFER_STATE b  );
 void yy_flush_buffer (YY_BUFFER_STATE b  );
@@ -916,7 +916,7 @@ char *yytext;
 #line 1 "pars0lex.l"
 /*****************************************************************************
 
-Copyright (c) 1997, 2011, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1997, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -1027,7 +1027,7 @@ static int yy_init_globals (void );
 /* Accessor methods to globals.
    These are made visible to non-reentrant scanners for convenience. */
 
-__attribute__((unused)) static int yylex_destroy (void );
+MY_ATTRIBUTE((unused)) static int yylex_destroy (void );
 
 int yyget_debug (void );
 
@@ -2664,7 +2664,7 @@ static int yy_get_next_buffer (void)
  * @param new_buffer The new input buffer.
  *
  */
-    __attribute__((unused)) static void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+    MY_ATTRIBUTE((unused)) static void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
 {
 
 	/* TODO. We should be able to replace this entire function body
@@ -3042,7 +3042,7 @@ static int yy_init_globals (void)
 }
 
 /* yylex_destroy is for both reentrant and non-reentrant scanners. */
-__attribute__((unused)) static int yylex_destroy  (void)
+MY_ATTRIBUTE((unused)) static int yylex_destroy  (void)
 {
 
     /* Pop the buffer stack, destroying each element. */
--- a/storage/innobase/pars/make_flex.sh
+++ b/storage/innobase/pars/make_flex.sh
@@ -1,6 +1,6 @@
 #!/bin/bash
 #
-# Copyright (c) 1994, 2011, Oracle and/or its affiliates. All Rights Reserved.
+# Copyright (c) 1994, 2016, Oracle and/or its affiliates. All Rights Reserved.
 #
 # This program is free software; you can redistribute it and/or modify it under
 # the terms of the GNU General Public License as published by the Free Software
@@ -33,15 +33,15 @@ sed -e '
 s/'"$TMPFILE"'/'"$OUTFILE"'/;
 s/\(int offset = \)\((yy_c_buf_p) - (yytext_ptr)\);/\1(int)(\2);/;
 s/\(void yy\(restart\|_\(delete\|flush\)_buffer\)\)/static \1/;
-s/\(void yy_switch_to_buffer\)/__attribute__((unused)) static \1/;
-s/\(void yy\(push\|pop\)_buffer_state\)/__attribute__((unused)) static \1/;
+s/\(void yy_switch_to_buffer\)/MY_ATTRIBUTE((unused)) static \1/;
+s/\(void yy\(push\|pop\)_buffer_state\)/MY_ATTRIBUTE((unused)) static \1/;
 s/\(YY_BUFFER_STATE yy_create_buffer\)/static \1/;
-s/\(\(int\|void\) yy[gs]et_\)/__attribute__((unused)) static \1/;
+s/\(\(int\|void\) yy[gs]et_\)/MY_ATTRIBUTE((unused)) static \1/;
 s/\(void \*\?yy\(\(re\)\?alloc\|free\)\)/static \1/;
 s/\(extern \)\?\(int yy\(leng\|lineno\|_flex_debug\)\)/static \2/;
-s/\(int yylex_destroy\)/__attribute__((unused)) static \1/;
+s/\(int yylex_destroy\)/MY_ATTRIBUTE((unused)) static \1/;
 s/\(extern \)\?\(int yylex \)/UNIV_INTERN \2/;
-s/^\(\(FILE\|char\) *\* *yyget\)/__attribute__((unused)) static \1/;
+s/^\(\(FILE\|char\) *\* *yyget\)/MY_ATTRIBUTE((unused)) static \1/;
 s/^\(extern \)\?\(\(FILE\|char\) *\* *yy\)/static \2/;
 ' < $TMPFILE >> $OUTFILE
 
--- a/storage/innobase/pars/pars0pars.cc
+++ b/storage/innobase/pars/pars0pars.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1996, 2013, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1996, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -1925,7 +1925,7 @@ pars_create_table(
 	sym_node_t*	column_defs,	/*!< in: list of column names */
 	sym_node_t*	compact,	/* in: non-NULL if COMPACT table. */
 	sym_node_t*	block_size,	/* in: block size (can be NULL) */
-	void*		not_fit_in_memory __attribute__((unused)))
+	void*		not_fit_in_memory MY_ATTRIBUTE((unused)))
 					/*!< in: a non-NULL pointer means that
 					this is a table which in simulations
 					should be simulated as not fitting
@@ -2141,7 +2141,7 @@ UNIV_INTERN
 que_fork_t*
 pars_stored_procedure_call(
 /*=======================*/
-	sym_node_t*	sym_node __attribute__((unused)))
+	sym_node_t*	sym_node MY_ATTRIBUTE((unused)))
 					/*!< in: stored procedure name */
 {
 	ut_error;
@@ -2201,7 +2201,7 @@ UNIV_INTERN
 void
 yyerror(
 /*====*/
-	const char*	s __attribute__((unused)))
+	const char*	s MY_ATTRIBUTE((unused)))
 				/*!< in: error message string */
 {
 	ut_ad(s);
--- a/storage/innobase/rem/rem0cmp.cc
+++ b/storage/innobase/rem/rem0cmp.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1994, 2012, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1994, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -75,7 +75,7 @@ cmp_debug_dtuple_rec_with_match(
 				completely  matched fields; when function
 				returns, contains the value for current
 				comparison */
-	__attribute__((nonnull, warn_unused_result));
+	MY_ATTRIBUTE((nonnull, warn_unused_result));
 #endif /* UNIV_DEBUG */
 /*************************************************************//**
 This function is used to compare two data fields for which the data type
@@ -920,7 +920,7 @@ Compare two physical record fields.
 @retval 1 if rec1 field is greater than rec2
 @retval -1 if rec1 field is less than rec2
 @retval 0 if rec1 field equals to rec2 */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 int
 cmp_rec_rec_simple_field(
 /*=====================*/
--- a/storage/innobase/rem/rem0rec.cc
+++ b/storage/innobase/rem/rem0rec.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1994, 2013, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1994, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -241,7 +241,7 @@ rec_get_n_extern_new(
 Determine the offset to each field in a leaf-page record
 in ROW_FORMAT=COMPACT.  This is a special case of
 rec_init_offsets() and rec_get_offsets_func(). */
-UNIV_INLINE __attribute__((nonnull))
+UNIV_INLINE MY_ATTRIBUTE((nonnull))
 void
 rec_init_offsets_comp_ordinary(
 /*===========================*/
@@ -785,7 +785,7 @@ rec_get_nth_field_offs_old(
 /**********************************************************//**
 Determines the size of a data tuple prefix in ROW_FORMAT=COMPACT.
 @return	total size */
-UNIV_INLINE __attribute__((warn_unused_result, nonnull(1,2)))
+UNIV_INLINE MY_ATTRIBUTE((warn_unused_result, nonnull(1,2)))
 ulint
 rec_get_converted_size_comp_prefix_low(
 /*===================================*/
@@ -1130,7 +1130,7 @@ rec_convert_dtuple_to_rec_old(
 
 /*********************************************************//**
 Builds a ROW_FORMAT=COMPACT record out of a data tuple. */
-UNIV_INLINE __attribute__((nonnull))
+UNIV_INLINE MY_ATTRIBUTE((nonnull))
 void
 rec_convert_dtuple_to_rec_comp(
 /*===========================*/
--- a/storage/innobase/row/row0ftsort.cc
+++ b/storage/innobase/row/row0ftsort.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 2010, 2015, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 2010, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -976,7 +976,7 @@ row_fts_start_parallel_merge(
 /********************************************************************//**
 Insert processed FTS data to auxillary index tables.
 @return	DB_SUCCESS if insertion runs fine */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 dberr_t
 row_merge_write_fts_word(
 /*=====================*/
--- a/storage/innobase/row/row0import.cc
+++ b/storage/innobase/row/row0import.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 2012, 2015, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 2012, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -2179,7 +2179,7 @@ PageConverter::operator() (
 Clean up after import tablespace failure, this function will acquire
 the dictionary latches on behalf of the transaction if the transaction
 hasn't already acquired them. */
-static	__attribute__((nonnull))
+static	MY_ATTRIBUTE((nonnull))
 void
 row_import_discard_changes(
 /*=======================*/
@@ -2230,7 +2230,7 @@ row_import_discard_changes(
 
 /*****************************************************************//**
 Clean up after import tablespace. */
-static	__attribute__((nonnull, warn_unused_result))
+static	MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_import_cleanup(
 /*===============*/
@@ -2265,7 +2265,7 @@ row_import_cleanup(
 
 /*****************************************************************//**
 Report error during tablespace import. */
-static	__attribute__((nonnull, warn_unused_result))
+static	MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_import_error(
 /*=============*/
@@ -2293,7 +2293,7 @@ row_import_error(
 Adjust the root page index node and leaf node segment headers, update
 with the new space id. For all the table's secondary indexes.
 @return error code */
-static	__attribute__((nonnull, warn_unused_result))
+static	MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_import_adjust_root_pages_of_secondary_indexes(
 /*==============================================*/
@@ -2409,7 +2409,7 @@ row_import_adjust_root_pages_of_secondary_indexes(
 /*****************************************************************//**
 Ensure that dict_sys->row_id exceeds SELECT MAX(DB_ROW_ID).
 @return error code */
-static	__attribute__((nonnull, warn_unused_result))
+static	MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_import_set_sys_max_row_id(
 /*==========================*/
@@ -2559,7 +2559,7 @@ row_import_cfg_read_string(
 /*********************************************************************//**
 Write the meta data (index user fields) config file.
 @return DB_SUCCESS or error code. */
-static	__attribute__((nonnull, warn_unused_result))
+static	MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_import_cfg_read_index_fields(
 /*=============================*/
@@ -2642,7 +2642,7 @@ row_import_cfg_read_index_fields(
 Read the index names and root page numbers of the indexes and set the values.
 Row format [root_page_no, len of str, str ... ]
 @return DB_SUCCESS or error code. */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_import_read_index_data(
 /*=======================*/
@@ -2837,7 +2837,7 @@ row_import_read_indexes(
 /*********************************************************************//**
 Read the meta data (table columns) config file. Deserialise the contents of
 dict_col_t structure, along with the column name. */
-static	__attribute__((nonnull, warn_unused_result))
+static	MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_import_read_columns(
 /*====================*/
@@ -2962,7 +2962,7 @@ row_import_read_columns(
 /*****************************************************************//**
 Read the contents of the <tablespace>.cfg file.
 @return DB_SUCCESS or error code. */
-static	__attribute__((nonnull, warn_unused_result))
+static	MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_import_read_v1(
 /*===============*/
@@ -3128,7 +3128,7 @@ row_import_read_v1(
 /**
 Read the contents of the <tablespace>.cfg file.
 @return DB_SUCCESS or error code. */
-static	__attribute__((nonnull, warn_unused_result))
+static	MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_import_read_meta_data(
 /*======================*/
@@ -3171,7 +3171,7 @@ row_import_read_meta_data(
 /**
 Read the contents of the <tablename>.cfg file.
 @return DB_SUCCESS or error code. */
-static	__attribute__((nonnull, warn_unused_result))
+static	MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_import_read_cfg(
 /*================*/
--- a/storage/innobase/row/row0ins.cc
+++ b/storage/innobase/row/row0ins.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1996, 2015, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1996, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -224,7 +224,7 @@ Does an insert operation by updating a delete-marked existing record
 in the index. This situation can occur if the delete-marked record is
 kept in the index for consistent reads.
 @return	DB_SUCCESS or error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_ins_sec_index_entry_by_modify(
 /*==============================*/
@@ -319,7 +319,7 @@ Does an insert operation by delete unmarking and updating a delete marked
 existing record in the index. This situation can occur if the delete marked
 record is kept in the index for consistent reads.
 @return	DB_SUCCESS, DB_FAIL, or error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_ins_clust_index_entry_by_modify(
 /*================================*/
@@ -427,7 +427,7 @@ row_ins_cascade_ancestor_updates_table(
 Returns the number of ancestor UPDATE or DELETE nodes of a
 cascaded update/delete node.
 @return	number of ancestors */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 ulint
 row_ins_cascade_n_ancestors(
 /*========================*/
@@ -453,7 +453,7 @@ a cascaded update.
 can also be 0 if no foreign key fields changed; the returned value is
 ULINT_UNDEFINED if the column type in the child table is too short to
 fit the new value in the parent table: that means the update fails */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 ulint
 row_ins_cascade_calc_update_vec(
 /*============================*/
@@ -926,7 +926,7 @@ Perform referential actions or checks when a parent row is deleted or updated
 and the constraint had an ON DELETE or ON UPDATE condition which was not
 RESTRICT.
 @return	DB_SUCCESS, DB_LOCK_WAIT, or error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_ins_foreign_check_on_constraint(
 /*================================*/
@@ -1747,7 +1747,7 @@ Otherwise does searches to the indexes of referenced tables and
 sets shared locks which lock either the success or the failure of
 a constraint.
 @return	DB_SUCCESS or error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_ins_check_foreign_constraints(
 /*==============================*/
@@ -1888,7 +1888,7 @@ Scans a unique non-clustered index at a given index entry to determine
 whether a uniqueness violation has occurred for the key value of the entry.
 Set shared locks on possible duplicate records.
 @return	DB_SUCCESS, DB_DUPLICATE_KEY, or DB_LOCK_WAIT */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_ins_scan_sec_index_for_duplicate(
 /*=================================*/
@@ -2030,7 +2030,7 @@ end_scan:
 @retval DB_SUCCESS_LOCKED_REC	when rec is an exact match of entry or
 a newer version of entry (the entry should not be inserted)
 @retval DB_DUPLICATE_KEY	when entry is a duplicate of rec */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_ins_duplicate_online(
 /*=====================*/
@@ -2071,7 +2071,7 @@ row_ins_duplicate_online(
 @retval DB_SUCCESS_LOCKED_REC	when rec is an exact match of entry or
 a newer version of entry (the entry should not be inserted)
 @retval DB_DUPLICATE_KEY	when entry is a duplicate of rec */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_ins_duplicate_error_in_clust_online(
 /*====================================*/
@@ -2114,7 +2114,7 @@ for a clustered index!
 record
 @retval DB_SUCCESS_LOCKED_REC if an exact match of the record was found
 in online table rebuild (flags & (BTR_KEEP_SYS_FLAG | BTR_NO_LOCKING_FLAG)) */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_ins_duplicate_error_in_clust(
 /*=============================*/
@@ -2532,7 +2532,7 @@ func_exit:
 /***************************************************************//**
 Starts a mini-transaction and checks if the index will be dropped.
 @return true if the index is to be dropped */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 bool
 row_ins_sec_mtr_start_and_check_if_aborted(
 /*=======================================*/
@@ -2973,7 +2973,7 @@ row_ins_index_entry(
 /***********************************************************//**
 Sets the values of the dtuple fields in entry from the values of appropriate
 columns in row. */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 void
 row_ins_index_entry_set_vals(
 /*=========================*/
@@ -3026,7 +3026,7 @@ row_ins_index_entry_set_vals(
 Inserts a single index entry to the table.
 @return DB_SUCCESS if operation successfully completed, else error
 code or DB_LOCK_WAIT */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_ins_index_entry_step(
 /*=====================*/
@@ -3149,7 +3149,7 @@ row_ins_get_row_from_select(
 Inserts a row to a table.
 @return DB_SUCCESS if operation successfully completed, else error
 code or DB_LOCK_WAIT */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_ins(
 /*====*/
--- a/storage/innobase/row/row0log.cc
+++ b/storage/innobase/row/row0log.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 2011, 2015, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 2011, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -201,7 +201,7 @@ struct row_log_t {
 /** Create the file or online log if it does not exist.
 @param[in,out]	log	online rebuild log
 @return file descriptor. */
-static __attribute__((warn_unused_result))
+static MY_ATTRIBUTE((warn_unused_result))
 int
 row_log_tmpfile(
 	row_log_t*	log)
@@ -217,7 +217,7 @@ row_log_tmpfile(
 /** Allocate the memory for the log buffer.
 @param[in,out]	log_buf	Buffer used for log operation
 @return TRUE if success, false if not */
-static __attribute__((warn_unused_result))
+static MY_ATTRIBUTE((warn_unused_result))
 bool
 row_log_block_allocate(
 	row_log_buf_t&	log_buf)
@@ -407,7 +407,7 @@ row_log_table_get_error(
 /******************************************************//**
 Starts logging an operation to a table that is being rebuilt.
 @return pointer to log, or NULL if no logging is necessary */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 byte*
 row_log_table_open(
 /*===============*/
@@ -442,7 +442,7 @@ err_exit:
 
 /******************************************************//**
 Stops logging an operation to a table that is being rebuilt. */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 void
 row_log_table_close_func(
 /*=====================*/
@@ -812,7 +812,7 @@ row_log_table_low_redundant(
 
 /******************************************************//**
 Logs an insert or update to a table that is being rebuilt. */
-static __attribute__((nonnull(1,2,3)))
+static MY_ATTRIBUTE((nonnull(1,2,3)))
 void
 row_log_table_low(
 /*==============*/
@@ -1312,7 +1312,7 @@ row_log_table_blob_alloc(
 /******************************************************//**
 Converts a log record to a table row.
 @return converted row, or NULL if the conversion fails */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 const dtuple_t*
 row_log_table_apply_convert_mrec(
 /*=============================*/
@@ -1466,7 +1466,7 @@ blob_done:
 /******************************************************//**
 Replays an insert operation on a table that was rebuilt.
 @return DB_SUCCESS or error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_log_table_apply_insert_low(
 /*===========================*/
@@ -1548,7 +1548,7 @@ row_log_table_apply_insert_low(
 /******************************************************//**
 Replays an insert operation on a table that was rebuilt.
 @return DB_SUCCESS or error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_log_table_apply_insert(
 /*=======================*/
@@ -1600,7 +1600,7 @@ row_log_table_apply_insert(
 /******************************************************//**
 Deletes a record from a table that is being rebuilt.
 @return DB_SUCCESS or error code */
-static __attribute__((nonnull(1, 2, 4, 5), warn_unused_result))
+static MY_ATTRIBUTE((nonnull(1, 2, 4, 5), warn_unused_result))
 dberr_t
 row_log_table_apply_delete_low(
 /*===========================*/
@@ -1698,7 +1698,7 @@ flag_ok:
 /******************************************************//**
 Replays a delete operation on a table that was rebuilt.
 @return DB_SUCCESS or error code */
-static __attribute__((nonnull(1, 3, 4, 5, 6, 7), warn_unused_result))
+static MY_ATTRIBUTE((nonnull(1, 3, 4, 5, 6, 7), warn_unused_result))
 dberr_t
 row_log_table_apply_delete(
 /*=======================*/
@@ -1820,7 +1820,7 @@ all_done:
 /******************************************************//**
 Replays an update operation on a table that was rebuilt.
 @return DB_SUCCESS or error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_log_table_apply_update(
 /*=======================*/
@@ -2183,7 +2183,7 @@ func_exit_committed:
 Applies an operation to a table that was rebuilt.
 @return NULL on failure (mrec corruption) or when out of data;
 pointer to next record on success */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 const mrec_t*
 row_log_table_apply_op(
 /*===================*/
@@ -2474,7 +2474,7 @@ row_log_table_apply_op(
 /******************************************************//**
 Applies operations to a table was rebuilt.
 @return DB_SUCCESS, or error code on failure */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_log_table_apply_ops(
 /*====================*/
@@ -2971,7 +2971,7 @@ row_log_get_max_trx(
 
 /******************************************************//**
 Applies an operation to a secondary index that was being created. */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 void
 row_log_apply_op_low(
 /*=================*/
@@ -3198,7 +3198,7 @@ func_exit:
 Applies an operation to a secondary index that was being created.
 @return NULL on failure (mrec corruption) or when out of data;
 pointer to next record on success */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 const mrec_t*
 row_log_apply_op(
 /*=============*/
@@ -3323,7 +3323,7 @@ corrupted:
 /******************************************************//**
 Applies operations to a secondary index that was being created.
 @return DB_SUCCESS, or error code on failure */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 dberr_t
 row_log_apply_ops(
 /*==============*/
--- a/storage/innobase/row/row0merge.cc
+++ b/storage/innobase/row/row0merge.cc
@@ -70,7 +70,7 @@ UNIV_INTERN char	srv_disable_sort_file_cache;
 #ifdef UNIV_DEBUG
 /******************************************************//**
 Display a merge tuple. */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 void
 row_merge_tuple_print(
 /*==================*/
@@ -105,7 +105,7 @@ row_merge_tuple_print(
 
 /******************************************************//**
 Encode an index record. */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 void
 row_merge_buf_encode(
 /*=================*/
@@ -142,7 +142,7 @@ row_merge_buf_encode(
 /******************************************************//**
 Allocate a sort buffer.
 @return	own: sort buffer */
-static __attribute__((malloc, nonnull))
+static MY_ATTRIBUTE((malloc, nonnull))
 row_merge_buf_t*
 row_merge_buf_create_low(
 /*=====================*/
@@ -642,7 +642,7 @@ row_merge_dup_report(
 /*************************************************************//**
 Compare two tuples.
 @return	1, 0, -1 if a is greater, equal, less, respectively, than b */
-static __attribute__((warn_unused_result))
+static MY_ATTRIBUTE((warn_unused_result))
 int
 row_merge_tuple_cmp(
 /*================*/
@@ -721,7 +721,7 @@ UT_SORT_FUNCTION_BODY().
 
 /**********************************************************************//**
 Merge sort the tuple buffer in main memory. */
-static __attribute__((nonnull(4,5)))
+static MY_ATTRIBUTE((nonnull(4,5)))
 void
 row_merge_tuple_sort(
 /*=================*/
@@ -1245,7 +1245,7 @@ row_merge_write_eof(
 @param[in,out]	tmpfd	temporary file handle
 @param[in]	path	path to create temporary file
 @return file descriptor, or -1 on failure */
-static __attribute__((warn_unused_result))
+static MY_ATTRIBUTE((warn_unused_result))
 int
 row_merge_tmpfile_if_needed(
 	int*		tmpfd,
@@ -1264,7 +1264,7 @@ row_merge_tmpfile_if_needed(
 @param[in]	nrec	number of records in the file
 @param[in]	path	path to create temporary files
 @return file descriptor, or -1 on failure */
-static __attribute__((warn_unused_result))
+static MY_ATTRIBUTE((warn_unused_result))
 int
 row_merge_file_create_if_needed(
 	merge_file_t*	file,
@@ -1310,7 +1310,7 @@ containing the index entries for the indexes to be built.
 @param[in,out] block		file buffer
 @param[in,out] tmpfd		temporary file handle
 return	DB_SUCCESS or error */
-static __attribute__((nonnull(1,2,3,4,6,9,10,16), warn_unused_result))
+static MY_ATTRIBUTE((nonnull(1,2,3,4,6,9,10,16), warn_unused_result))
 dberr_t
 row_merge_read_clustered_index(
 	trx_t*			trx,
@@ -2028,7 +2028,7 @@ wait_again:
 /*************************************************************//**
 Merge two blocks of records on disk and write a bigger block.
 @return	DB_SUCCESS or error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_merge_blocks(
 /*=============*/
@@ -2139,7 +2139,7 @@ done1:
 /*************************************************************//**
 Copy a block of index entries.
 @return	TRUE on success, FALSE on failure */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 ibool
 row_merge_blocks_copy(
 /*==================*/
@@ -2212,7 +2212,7 @@ done0:
 /*************************************************************//**
 Merge disk files.
 @return	DB_SUCCESS or error code */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 dberr_t
 row_merge(
 /*======*/
@@ -2398,7 +2398,7 @@ row_merge_sort(
 
 /*************************************************************//**
 Copy externally stored columns to the data tuple. */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 void
 row_merge_copy_blobs(
 /*=================*/
@@ -2443,7 +2443,7 @@ row_merge_copy_blobs(
 Read sorted file containing index data tuples and insert these data
 tuples to the index
 @return	DB_SUCCESS or error number */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_merge_insert_index_tuples(
 /*==========================*/
@@ -3456,7 +3456,7 @@ row_merge_rename_tables_dict(
 /*********************************************************************//**
 Create and execute a query graph for creating an index.
 @return	DB_SUCCESS or error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_merge_create_index_graph(
 /*=========================*/
--- a/storage/innobase/row/row0mysql.cc
+++ b/storage/innobase/row/row0mysql.cc
@@ -4476,7 +4476,7 @@ row_mysql_drop_temp_tables(void)
 Drop all foreign keys in a database, see Bug#18942.
 Called at the end of row_drop_database_for_mysql().
 @return	error code or DB_SUCCESS */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 drop_all_foreign_keys_in_db(
 /*========================*/
@@ -4668,7 +4668,7 @@ loop:
 Checks if a table name contains the string "/#sql" which denotes temporary
 tables in MySQL.
 @return	true if temporary table */
-UNIV_INTERN __attribute__((warn_unused_result))
+UNIV_INTERN MY_ATTRIBUTE((warn_unused_result))
 bool
 row_is_mysql_tmp_table_name(
 /*========================*/
@@ -4682,7 +4682,7 @@ row_is_mysql_tmp_table_name(
 /****************************************************************//**
 Delete a single constraint.
 @return	error code or DB_SUCCESS */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_delete_constraint_low(
 /*======================*/
@@ -4705,7 +4705,7 @@ row_delete_constraint_low(
 /****************************************************************//**
 Delete a single constraint.
 @return	error code or DB_SUCCESS */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_delete_constraint(
 /*==================*/
--- a/storage/innobase/row/row0purge.cc
+++ b/storage/innobase/row/row0purge.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1997, 2015, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1997, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -120,7 +120,7 @@ row_purge_reposition_pcur(
 Removes a delete marked clustered index record if possible.
 @retval true if the row was not found, or it was successfully removed
 @retval false if the row was modified after the delete marking */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 bool
 row_purge_remove_clust_if_poss_low(
 /*===============================*/
@@ -202,7 +202,7 @@ marking.
 @retval true if the row was not found, or it was successfully removed
 @retval false the purge needs to be suspended because of running out
 of file space. */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 bool
 row_purge_remove_clust_if_poss(
 /*===========================*/
@@ -274,7 +274,7 @@ row_purge_poss_sec(
 Removes a secondary index entry if possible, by modifying the
 index tree.  Does not try to buffer the delete.
 @return	TRUE if success or if not found */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 ibool
 row_purge_remove_sec_if_poss_tree(
 /*==============================*/
@@ -396,7 +396,7 @@ Removes a secondary index entry without modifying the index tree,
 if possible.
 @retval	true if success or if not found
 @retval	false if row_purge_remove_sec_if_poss_tree() should be invoked */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 bool
 row_purge_remove_sec_if_poss_leaf(
 /*==============================*/
@@ -507,7 +507,7 @@ row_purge_remove_sec_if_poss_leaf(
 
 /***********************************************************//**
 Removes a secondary index entry if possible. */
-UNIV_INLINE __attribute__((nonnull(1,2)))
+UNIV_INLINE MY_ATTRIBUTE((nonnull(1,2)))
 void
 row_purge_remove_sec_if_poss(
 /*=========================*/
@@ -554,7 +554,7 @@ Purges a delete marking of a record.
 @retval true if the row was not found, or it was successfully removed
 @retval false the purge needs to be suspended because of
 running out of file space */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 bool
 row_purge_del_mark(
 /*===============*/
@@ -830,7 +830,7 @@ err_exit:
 /***********************************************************//**
 Purges the parsed record.
 @return true if purged, false if skipped */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 bool
 row_purge_record_func(
 /*==================*/
@@ -895,7 +895,7 @@ row_purge_record_func(
 Fetches an undo log record and does the purge for the recorded operation.
 If none left, or the current purge completed, returns the control to the
 parent node, which is always a query thread node. */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 void
 row_purge(
 /*======*/
--- a/storage/innobase/row/row0quiesce.cc
+++ b/storage/innobase/row/row0quiesce.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 2012, 2014, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 2012, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -37,7 +37,7 @@ Created 2012-02-08 by Sunny Bains.
 /*********************************************************************//**
 Write the meta data (index user fields) config file.
 @return DB_SUCCESS or error code. */
-static	__attribute__((nonnull, warn_unused_result))
+static	MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_quiesce_write_index_fields(
 /*===========================*/
@@ -97,7 +97,7 @@ row_quiesce_write_index_fields(
 /*********************************************************************//**
 Write the meta data config file index information.
 @return DB_SUCCESS or error code. */
-static	__attribute__((nonnull, warn_unused_result))
+static	MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_quiesce_write_indexes(
 /*======================*/
@@ -210,7 +210,7 @@ Write the meta data (table columns) config file. Serialise the contents of
 dict_col_t structure, along with the column name. All fields are serialized
 as ib_uint32_t.
 @return DB_SUCCESS or error code. */
-static	__attribute__((nonnull, warn_unused_result))
+static	MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_quiesce_write_table(
 /*====================*/
@@ -293,7 +293,7 @@ row_quiesce_write_table(
 /*********************************************************************//**
 Write the meta data config file header.
 @return DB_SUCCESS or error code. */
-static	__attribute__((nonnull, warn_unused_result))
+static	MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_quiesce_write_header(
 /*=====================*/
@@ -415,7 +415,7 @@ row_quiesce_write_header(
 /*********************************************************************//**
 Write the table meta data after quiesce.
 @return DB_SUCCESS or error code */
-static	__attribute__((nonnull, warn_unused_result))
+static	MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_quiesce_write_cfg(
 /*==================*/
--- a/storage/innobase/row/row0sel.cc
+++ b/storage/innobase/row/row0sel.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1997, 2015, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1997, 2016, Oracle and/or its affiliates. All Rights Reserved.
 Copyright (c) 2008, Google Inc.
 
 Portions of this file contain modifications contributed and copyrighted by
@@ -675,7 +675,7 @@ sel_enqueue_prefetched_row(
 /*********************************************************************//**
 Builds a previous version of a clustered index record for a consistent read
 @return	DB_SUCCESS or error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_sel_build_prev_vers(
 /*====================*/
@@ -710,7 +710,7 @@ row_sel_build_prev_vers(
 /*********************************************************************//**
 Builds the last committed version of a clustered index record for a
 semi-consistent read. */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 void
 row_sel_build_committed_vers_for_mysql(
 /*===================================*/
@@ -808,7 +808,7 @@ row_sel_test_other_conds(
 Retrieves the clustered index record corresponding to a record in a
 non-clustered index. Does the necessary locking.
 @return	DB_SUCCESS or error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_sel_get_clust_rec(
 /*==================*/
@@ -1312,7 +1312,7 @@ func_exit:
 /*********************************************************************//**
 Performs a select step.
 @return	DB_SUCCESS or error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_sel(
 /*====*/
@@ -2563,7 +2563,7 @@ row_sel_store_row_id_to_prebuilt(
 /**************************************************************//**
 Stores a non-SQL-NULL field in the MySQL format. The counterpart of this
 function is row_mysql_store_col_in_innobase_format() in row0mysql.cc. */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 void
 row_sel_field_store_in_mysql_format_func(
 /*=====================================*/
@@ -2752,7 +2752,7 @@ row_sel_field_store_in_mysql_format_func(
 #endif /* UNIV_DEBUG */
 /**************************************************************//**
 Convert a field in the Innobase format to a field in the MySQL format. */
-static __attribute__((warn_unused_result))
+static MY_ATTRIBUTE((warn_unused_result))
 ibool
 row_sel_store_mysql_field_func(
 /*===========================*/
@@ -2902,7 +2902,7 @@ Note that the template in prebuilt may advise us to copy only a few
 columns to mysql_rec, other columns are left blank. All columns may not
 be needed in the query.
 @return TRUE on success, FALSE if not all columns could be retrieved */
-static __attribute__((warn_unused_result))
+static MY_ATTRIBUTE((warn_unused_result))
 ibool
 row_sel_store_mysql_rec(
 /*====================*/
@@ -2964,7 +2964,7 @@ row_sel_store_mysql_rec(
 /*********************************************************************//**
 Builds a previous version of a clustered index record for a consistent read
 @return	DB_SUCCESS or error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_sel_build_prev_vers_for_mysql(
 /*==============================*/
@@ -3001,7 +3001,7 @@ Retrieves the clustered index record corresponding to a record in a
 non-clustered index. Does the necessary locking. Used in the MySQL
 interface.
 @return	DB_SUCCESS, DB_SUCCESS_LOCKED_REC, or error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_sel_get_clust_rec_for_mysql(
 /*============================*/
--- a/storage/innobase/row/row0uins.cc
+++ b/storage/innobase/row/row0uins.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1997, 2014, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1997, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -61,7 +61,7 @@ introduced where a call to log_free_check() is bypassed. */
 Removes a clustered index record. The pcur in node was positioned on the
 record, now it is detached.
 @return	DB_SUCCESS or DB_OUT_OF_FILE_SPACE */
-static  __attribute__((nonnull, warn_unused_result))
+static  MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_undo_ins_remove_clust_rec(
 /*==========================*/
@@ -176,7 +176,7 @@ func_exit:
 /***************************************************************//**
 Removes a secondary index entry if found.
 @return	DB_SUCCESS, DB_FAIL, or DB_OUT_OF_FILE_SPACE */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_undo_ins_remove_sec_low(
 /*========================*/
@@ -251,7 +251,7 @@ func_exit_no_pcur:
 Removes a secondary index entry from the index if found. Tries first
 optimistic, then pessimistic descent down the tree.
 @return	DB_SUCCESS or DB_OUT_OF_FILE_SPACE */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_undo_ins_remove_sec(
 /*====================*/
@@ -350,7 +350,7 @@ close_table:
 /***************************************************************//**
 Removes secondary index records.
 @return	DB_SUCCESS or DB_OUT_OF_FILE_SPACE */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_undo_ins_remove_sec_rec(
 /*========================*/
--- a/storage/innobase/row/row0umod.cc
+++ b/storage/innobase/row/row0umod.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1997, 2014, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1997, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -72,7 +72,7 @@ introduced where a call to log_free_check() is bypassed. */
 /***********************************************************//**
 Undoes a modify in a clustered index record.
 @return	DB_SUCCESS, DB_FAIL, or error code: we may run out of file space */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_undo_mod_clust_low(
 /*===================*/
@@ -154,7 +154,7 @@ This is attempted when the record was inserted by updating a
 delete-marked record and there no longer exist transactions
 that would see the delete-marked record.
 @return	DB_SUCCESS, DB_FAIL, or error code: we may run out of file space */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_undo_mod_remove_clust_low(
 /*==========================*/
@@ -243,7 +243,7 @@ row_undo_mod_remove_clust_low(
 Undoes a modify in a clustered index record. Sets also the node state for the
 next round of undo.
 @return	DB_SUCCESS or error code: we may run out of file space */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_undo_mod_clust(
 /*===============*/
@@ -380,7 +380,7 @@ row_undo_mod_clust(
 /***********************************************************//**
 Delete marks or removes a secondary index entry if found.
 @return	DB_SUCCESS, DB_FAIL, or DB_OUT_OF_FILE_SPACE */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_undo_mod_del_mark_or_remove_sec_low(
 /*====================================*/
@@ -516,7 +516,7 @@ not cause problems because in row0sel.cc, in queries we always retrieve the
 clustered index record or an earlier version of it, if the secondary index
 record through which we do the search is delete-marked.
 @return	DB_SUCCESS or DB_OUT_OF_FILE_SPACE */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_undo_mod_del_mark_or_remove_sec(
 /*================================*/
@@ -549,7 +549,7 @@ fields but alphabetically they stayed the same, e.g., 'abc' -> 'aBc'.
 @retval	DB_OUT_OF_FILE_SPACE when running out of tablespace
 @retval	DB_DUPLICATE_KEY if the value was missing
 	and an insert would lead to a duplicate exists */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_undo_mod_del_unmark_sec_and_undo_update(
 /*========================================*/
@@ -745,7 +745,7 @@ func_exit_no_pcur:
 
 /***********************************************************//**
 Flags a secondary index corrupted. */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 void
 row_undo_mod_sec_flag_corrupted(
 /*============================*/
@@ -777,7 +777,7 @@ row_undo_mod_sec_flag_corrupted(
 /***********************************************************//**
 Undoes a modify in secondary indexes when undo record type is UPD_DEL.
 @return	DB_SUCCESS or DB_OUT_OF_FILE_SPACE */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_undo_mod_upd_del_sec(
 /*=====================*/
@@ -844,7 +844,7 @@ row_undo_mod_upd_del_sec(
 /***********************************************************//**
 Undoes a modify in secondary indexes when undo record type is DEL_MARK.
 @return	DB_SUCCESS or DB_OUT_OF_FILE_SPACE */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_undo_mod_del_mark_sec(
 /*======================*/
@@ -912,7 +912,7 @@ row_undo_mod_del_mark_sec(
 /***********************************************************//**
 Undoes a modify in secondary indexes when undo record type is UPD_EXIST.
 @return	DB_SUCCESS or DB_OUT_OF_FILE_SPACE */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_undo_mod_upd_exist_sec(
 /*=======================*/
@@ -1028,7 +1028,7 @@ row_undo_mod_upd_exist_sec(
 
 /***********************************************************//**
 Parses the row reference and other info in a modify undo log record. */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 void
 row_undo_mod_parse_undo_rec(
 /*========================*/
--- a/storage/innobase/row/row0undo.cc
+++ b/storage/innobase/row/row0undo.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1997, 2012, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1997, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -245,7 +245,7 @@ Fetches an undo log record and does the undo for the recorded operation.
 If none left, or a partial rollback completed, returns control to the
 parent node, which is always a query thread node.
 @return	DB_SUCCESS if operation successfully completed, else error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_undo(
 /*=====*/
--- a/storage/innobase/row/row0upd.cc
+++ b/storage/innobase/row/row0upd.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1996, 2014, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1996, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -170,7 +170,7 @@ NOTE that this function will temporarily commit mtr and lose the
 pcur position!
 
 @return	DB_SUCCESS or an error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_upd_check_references_constraints(
 /*=================================*/
@@ -607,7 +607,7 @@ row_upd_write_sys_vals_to_log(
 	roll_ptr_t	roll_ptr,/*!< in: roll ptr of the undo log record */
 	byte*		log_ptr,/*!< pointer to a buffer of size > 20 opened
 				in mlog */
-	mtr_t*		mtr __attribute__((unused))) /*!< in: mtr */
+	mtr_t*		mtr MY_ATTRIBUTE((unused))) /*!< in: mtr */
 {
 	ut_ad(dict_index_is_clust(index));
 	ut_ad(mtr);
@@ -1642,7 +1642,7 @@ row_upd_store_row(
 Updates a secondary index entry of a row.
 @return DB_SUCCESS if operation successfully completed, else error
 code or DB_LOCK_WAIT */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_upd_sec_index_entry(
 /*====================*/
@@ -1844,7 +1844,7 @@ Updates the secondary index record if it is changed in the row update or
 deletes it if this is a delete.
 @return DB_SUCCESS if operation successfully completed, else error
 code or DB_LOCK_WAIT */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_upd_sec_step(
 /*=============*/
@@ -1877,7 +1877,7 @@ updated. We must mark them as inherited in entry, so that they are not
 freed in a rollback. A limited version of this function used to be
 called btr_cur_mark_dtuple_inherited_extern().
 @return TRUE if any columns were inherited */
-static __attribute__((warn_unused_result))
+static MY_ATTRIBUTE((warn_unused_result))
 ibool
 row_upd_clust_rec_by_insert_inherit_func(
 /*=====================================*/
@@ -1956,7 +1956,7 @@ fields of the clustered index record change. This should be quite rare in
 database applications.
 @return DB_SUCCESS if operation successfully completed, else error
 code or DB_LOCK_WAIT */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_upd_clust_rec_by_insert(
 /*========================*/
@@ -2081,7 +2081,7 @@ Updates a clustered index record of a row when the ordering fields do
 not change.
 @return DB_SUCCESS if operation successfully completed, else error
 code or DB_LOCK_WAIT */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_upd_clust_rec(
 /*==============*/
@@ -2240,7 +2240,7 @@ func_exit:
 /***********************************************************//**
 Delete marks a clustered index record.
 @return	DB_SUCCESS if operation successfully completed, else error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_upd_del_mark_clust_rec(
 /*=======================*/
@@ -2292,7 +2292,7 @@ row_upd_del_mark_clust_rec(
 Updates the clustered index record.
 @return DB_SUCCESS if operation successfully completed, DB_LOCK_WAIT
 in case of a lock wait, else error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_upd_clust_step(
 /*===============*/
@@ -2488,7 +2488,7 @@ to this node, we assume that we have a persistent cursor which was on a
 record, and the position of the cursor is stored in the cursor.
 @return DB_SUCCESS if operation successfully completed, else error
 code or DB_LOCK_WAIT */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 row_upd(
 /*====*/
--- a/storage/innobase/srv/srv0srv.cc
+++ b/storage/innobase/srv/srv0srv.cc
@@ -1497,7 +1497,7 @@ extern "C" UNIV_INTERN
 os_thread_ret_t
 DECLARE_THREAD(srv_monitor_thread)(
 /*===============================*/
-	void*	arg __attribute__((unused)))
+	void*	arg MY_ATTRIBUTE((unused)))
 			/*!< in: a dummy parameter required by
 			os_thread_create */
 {
@@ -1674,7 +1674,7 @@ extern "C" UNIV_INTERN
 os_thread_ret_t
 DECLARE_THREAD(srv_error_monitor_thread)(
 /*=====================================*/
-	void*	arg __attribute__((unused)))
+	void*	arg MY_ATTRIBUTE((unused)))
 			/*!< in: a dummy parameter required by
 			os_thread_create */
 {
@@ -2310,7 +2310,7 @@ extern "C" UNIV_INTERN
 os_thread_ret_t
 DECLARE_THREAD(srv_master_thread)(
 /*==============================*/
-	void*	arg __attribute__((unused)))
+	void*	arg MY_ATTRIBUTE((unused)))
 			/*!< in: a dummy parameter required by
 			os_thread_create */
 {
@@ -2454,7 +2454,7 @@ extern "C" UNIV_INTERN
 os_thread_ret_t
 DECLARE_THREAD(srv_worker_thread)(
 /*==============================*/
-	void*	arg __attribute__((unused)))	/*!< in: a dummy parameter
+	void*	arg MY_ATTRIBUTE((unused)))	/*!< in: a dummy parameter
 						required by os_thread_create */
 {
 	srv_slot_t*	slot;
@@ -2712,7 +2712,7 @@ extern "C" UNIV_INTERN
 os_thread_ret_t
 DECLARE_THREAD(srv_purge_coordinator_thread)(
 /*=========================================*/
-	void*	arg __attribute__((unused)))	/*!< in: a dummy parameter
+	void*	arg MY_ATTRIBUTE((unused)))	/*!< in: a dummy parameter
 						required by os_thread_create */
 {
 	srv_slot_t*	slot;
--- a/storage/innobase/srv/srv0start.cc
+++ b/storage/innobase/srv/srv0start.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1996, 2015, Oracle and/or its affiliates. All rights reserved.
+Copyright (c) 1996, 2016, Oracle and/or its affiliates. All rights reserved.
 Copyright (c) 2008, Google Inc.
 Copyright (c) 2009, Percona Inc.
 
@@ -509,7 +509,7 @@ UNIV_INTERN
 void
 srv_normalize_path_for_win(
 /*=======================*/
-	char*	str __attribute__((unused)))	/*!< in/out: null-terminated
+	char*	str MY_ATTRIBUTE((unused)))	/*!< in/out: null-terminated
 						character string */
 {
 #ifdef __WIN__
@@ -526,7 +526,7 @@ srv_normalize_path_for_win(
 /*********************************************************************//**
 Creates a log file.
 @return	DB_SUCCESS or error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 create_log_file(
 /*============*/
@@ -733,7 +733,7 @@ create_log_files_rename(
 /*********************************************************************//**
 Opens a log file.
 @return	DB_SUCCESS or error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 open_log_file(
 /*==========*/
@@ -761,7 +761,7 @@ open_log_file(
 /*********************************************************************//**
 Creates or opens database data files and closes them.
 @return	DB_SUCCESS or error code */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 open_or_create_data_files(
 /*======================*/
--- a/storage/innobase/sync/sync0sync.cc
+++ b/storage/innobase/sync/sync0sync.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1995, 2015, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1995, 2016, Oracle and/or its affiliates. All Rights Reserved.
 Copyright (c) 2008, Google Inc.
 
 Portions of this file contain modifications contributed and copyrighted by
@@ -387,10 +387,10 @@ ulint
 mutex_enter_nowait_func(
 /*====================*/
 	ib_mutex_t*	mutex,		/*!< in: pointer to mutex */
-	const char*	file_name __attribute__((unused)),
+	const char*	file_name MY_ATTRIBUTE((unused)),
 					/*!< in: file name where mutex
 					requested */
-	ulint		line __attribute__((unused)))
+	ulint		line MY_ATTRIBUTE((unused)))
 					/*!< in: line where requested */
 {
 	ut_ad(mutex_validate(mutex));
--- a/storage/innobase/trx/trx0purge.cc
+++ b/storage/innobase/trx/trx0purge.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1996, 2012, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1996, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -913,7 +913,7 @@ Fetches the next undo log record from the history list to purge. It must be
 released with the corresponding release function.
 @return copy of an undo log record or pointer to trx_purge_dummy_rec,
 if the whole undo log can skipped in purge; NULL if none left */
-static __attribute__((warn_unused_result, nonnull))
+static MY_ATTRIBUTE((warn_unused_result, nonnull))
 trx_undo_rec_t*
 trx_purge_fetch_next_rec(
 /*=====================*/
--- a/storage/innobase/trx/trx0rec.cc
+++ b/storage/innobase/trx/trx0rec.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1996, 2012, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1996, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -1132,7 +1132,7 @@ trx_undo_rec_get_partial_row(
 /***********************************************************************//**
 Erases the unused undo log page end.
 @return TRUE if the page contained something, FALSE if it was empty */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 ibool
 trx_undo_erase_page_end(
 /*====================*/
@@ -1158,7 +1158,7 @@ byte*
 trx_undo_parse_erase_page_end(
 /*==========================*/
 	byte*	ptr,	/*!< in: buffer */
-	byte*	end_ptr __attribute__((unused)), /*!< in: buffer end */
+	byte*	end_ptr MY_ATTRIBUTE((unused)), /*!< in: buffer end */
 	page_t*	page,	/*!< in: page or NULL */
 	mtr_t*	mtr)	/*!< in: mtr or NULL */
 {
@@ -1441,7 +1441,7 @@ NOTE: the caller must have latches on the clustered index page.
 @retval true if the undo log has been
 truncated and we cannot fetch the old version
 @retval false if the undo log record is available  */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 bool
 trx_undo_get_undo_rec(
 /*==================*/
@@ -1469,7 +1469,7 @@ trx_undo_get_undo_rec(
 #ifdef UNIV_DEBUG
 #define ATTRIB_USED_ONLY_IN_DEBUG
 #else /* UNIV_DEBUG */
-#define ATTRIB_USED_ONLY_IN_DEBUG	__attribute__((unused))
+#define ATTRIB_USED_ONLY_IN_DEBUG	MY_ATTRIBUTE((unused))
 #endif /* UNIV_DEBUG */
 
 /*******************************************************************//**
--- a/storage/innobase/trx/trx0roll.cc
+++ b/storage/innobase/trx/trx0roll.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1996, 2014, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1996, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -336,7 +336,7 @@ the row, these locks are naturally released in the rollback. Savepoints which
 were set after this savepoint are deleted.
 @return if no savepoint of the name found then DB_NO_SAVEPOINT,
 otherwise DB_SUCCESS */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 trx_rollback_to_savepoint_for_mysql_low(
 /*====================================*/
@@ -796,7 +796,7 @@ extern "C" UNIV_INTERN
 os_thread_ret_t
 DECLARE_THREAD(trx_rollback_or_clean_all_recovered)(
 /*================================================*/
-	void*	arg __attribute__((unused)))
+	void*	arg MY_ATTRIBUTE((unused)))
 			/*!< in: a dummy parameter required by
 			os_thread_create */
 {
--- a/storage/innobase/trx/trx0trx.cc
+++ b/storage/innobase/trx/trx0trx.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1996, 2015, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1996, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -959,7 +959,7 @@ trx_serialisation_number_get(
 /****************************************************************//**
 Assign the transaction its history serialisation number and write the
 update UNDO log record to the assigned rollback segment. */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 void
 trx_write_serialisation_history(
 /*============================*/
@@ -1030,7 +1030,7 @@ trx_write_serialisation_history(
 
 /********************************************************************
 Finalize a transaction containing updates for a FTS table. */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 void
 trx_finalize_for_fts_table(
 /*=======================*/
@@ -1063,7 +1063,7 @@ trx_finalize_for_fts_table(
 
 /******************************************************************//**
 Finalize a transaction containing updates to FTS tables. */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 void
 trx_finalize_for_fts(
 /*=================*/
@@ -1130,7 +1130,7 @@ trx_flush_log_if_needed_low(
 /**********************************************************************//**
 If required, flushes the log to disk based on the value of
 innodb_flush_log_at_trx_commit. */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 void
 trx_flush_log_if_needed(
 /*====================*/
@@ -1145,7 +1145,7 @@ trx_flush_log_if_needed(
 
 /****************************************************************//**
 Commits a transaction in memory. */
-static __attribute__((nonnull))
+static MY_ATTRIBUTE((nonnull))
 void
 trx_commit_in_memory(
 /*=================*/
@@ -2136,7 +2136,7 @@ which is in the prepared state
 @return	trx on match, the trx->xid will be invalidated;
 note that the trx may have been committed, unless the caller is
 holding lock_sys->mutex */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 trx_t*
 trx_get_trx_by_xid_low(
 /*===================*/
--- a/storage/innobase/trx/trx0undo.cc
+++ b/storage/innobase/trx/trx0undo.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1996, 2013, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1996, 2016, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -419,11 +419,11 @@ trx_undo_page_init(
 Creates a new undo log segment in file.
 @return DB_SUCCESS if page creation OK possible error codes are:
 DB_TOO_MANY_CONCURRENT_TRXS DB_OUT_OF_FILE_SPACE */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 trx_undo_seg_create(
 /*================*/
-	trx_rseg_t*	rseg __attribute__((unused)),/*!< in: rollback segment */
+	trx_rseg_t*	rseg MY_ATTRIBUTE((unused)),/*!< in: rollback segment */
 	trx_rsegf_t*	rseg_hdr,/*!< in: rollback segment header, page
 				x-latched */
 	ulint		type,	/*!< in: type of the segment: TRX_UNDO_INSERT or
@@ -827,7 +827,7 @@ byte*
 trx_undo_parse_discard_latest(
 /*==========================*/
 	byte*	ptr,	/*!< in: buffer */
-	byte*	end_ptr __attribute__((unused)), /*!< in: buffer end */
+	byte*	end_ptr MY_ATTRIBUTE((unused)), /*!< in: buffer end */
 	page_t*	page,	/*!< in: page or NULL */
 	mtr_t*	mtr)	/*!< in: mtr or NULL */
 {
@@ -1557,7 +1557,7 @@ Creates a new undo log.
 @return DB_SUCCESS if successful in creating the new undo lob object,
 possible error codes are: DB_TOO_MANY_CONCURRENT_TRXS
 DB_OUT_OF_FILE_SPACE DB_OUT_OF_MEMORY */
-static __attribute__((nonnull, warn_unused_result))
+static MY_ATTRIBUTE((nonnull, warn_unused_result))
 dberr_t
 trx_undo_create(
 /*============*/
--- a/storage/myisam/ft_boolean_search.c
+++ b/storage/myisam/ft_boolean_search.c
@@ -332,7 +332,7 @@ static int _ftb_parse_query(FTB *ftb, uchar *query, uint len,
 }
 
 
-static int _ftb_no_dupes_cmp(const void* not_used __attribute__((unused)),
+static int _ftb_no_dupes_cmp(const void* not_used MY_ATTRIBUTE((unused)),
                              const void *a,const void *b)
 {
   return CMP_NUM((*((my_off_t*)a)), (*((my_off_t*)b)));
@@ -643,7 +643,7 @@ typedef struct st_my_ftb_phrase_param
 
 static int ftb_phrase_add_word(MYSQL_FTPARSER_PARAM *param,
                                char *word, int word_len,
-    MYSQL_FTPARSER_BOOLEAN_INFO *boolean_info __attribute__((unused)))
+    MYSQL_FTPARSER_BOOLEAN_INFO *boolean_info MY_ATTRIBUTE((unused)))
 {
   MY_FTB_PHRASE_PARAM *phrase_param= param->mysql_ftparam;
   FT_WORD *w= (FT_WORD *)phrase_param->document->data;
@@ -901,7 +901,7 @@ typedef struct st_my_ftb_find_param
 
 static int ftb_find_relevance_add_word(MYSQL_FTPARSER_PARAM *param,
                                        char *word, int len,
-             MYSQL_FTPARSER_BOOLEAN_INFO *boolean_info __attribute__((unused)))
+             MYSQL_FTPARSER_BOOLEAN_INFO *boolean_info MY_ATTRIBUTE((unused)))
 {
   MY_FTB_FIND_PARAM *ftb_param= param->mysql_ftparam;
   FT_INFO *ftb= ftb_param->ftb;
--- a/storage/myisam/ft_nlq_search.c
+++ b/storage/myisam/ft_nlq_search.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2001, 2011, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2001, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -51,7 +51,7 @@ typedef struct st_ft_superdoc
     double   tmp_weight;
 } FT_SUPERDOC;
 
-static int FT_SUPERDOC_cmp(void* cmp_arg __attribute__((unused)),
+static int FT_SUPERDOC_cmp(void* cmp_arg MY_ATTRIBUTE((unused)),
 			   FT_SUPERDOC *p1, FT_SUPERDOC *p2)
 {
   if (p1->doc.dpos < p2->doc.dpos)
@@ -189,7 +189,7 @@ do_skip:
 
 
 static int walk_and_copy(FT_SUPERDOC *from,
-			 uint32 count __attribute__((unused)), FT_DOC **to)
+			 uint32 count MY_ATTRIBUTE((unused)), FT_DOC **to)
 {
   DBUG_ENTER("walk_and_copy");
   from->doc.weight+=from->tmp_weight*from->word_ptr->weight;
@@ -200,7 +200,7 @@ static int walk_and_copy(FT_SUPERDOC *from,
 }
 
 static int walk_and_push(FT_SUPERDOC *from,
-			 uint32 count __attribute__((unused)), QUEUE *best)
+			 uint32 count MY_ATTRIBUTE((unused)), QUEUE *best)
 {
   DBUG_ENTER("walk_and_copy");
   from->doc.weight+=from->tmp_weight*from->word_ptr->weight;
@@ -210,7 +210,7 @@ static int walk_and_push(FT_SUPERDOC *from,
 }
 
 
-static int FT_DOC_cmp(void *unused __attribute__((unused)),
+static int FT_DOC_cmp(void *unused MY_ATTRIBUTE((unused)),
                       FT_DOC *a, FT_DOC *b)
 {
   double c= b->weight - a->weight;
@@ -345,8 +345,8 @@ int ft_nlq_read_next(FT_INFO *handler, char *record)
 
 
 float ft_nlq_find_relevance(FT_INFO *handler,
-			    uchar *record __attribute__((unused)),
-			    uint length __attribute__((unused)))
+			    uchar *record MY_ATTRIBUTE((unused)),
+			    uint length MY_ATTRIBUTE((unused)))
 {
   int a,b,c;
   FT_DOC  *docs=handler->doc;
--- a/storage/myisam/ft_parser.c
+++ b/storage/myisam/ft_parser.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights
    reserved.
 
    This program is free software; you can redistribute it and/or modify
@@ -259,7 +259,7 @@ void ft_parse_init(TREE *wtree, const CHARSET_INFO *cs)
 
 static int ft_add_word(MYSQL_FTPARSER_PARAM *param,
                        char *word, int word_len,
-             MYSQL_FTPARSER_BOOLEAN_INFO *boolean_info __attribute__((unused)))
+             MYSQL_FTPARSER_BOOLEAN_INFO *boolean_info MY_ATTRIBUTE((unused)))
 {
   TREE *wtree;
   FT_WORD w;
--- a/storage/myisam/ft_stopwords.c
+++ b/storage/myisam/ft_stopwords.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2010, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -30,7 +30,7 @@ typedef struct st_ft_stopwords
 
 static TREE *stopwords3=NULL;
 
-static int FT_STOPWORD_cmp(void* cmp_arg __attribute__((unused)),
+static int FT_STOPWORD_cmp(void* cmp_arg MY_ATTRIBUTE((unused)),
 			   FT_STOPWORD *w1, FT_STOPWORD *w2)
 {
   return ha_compare_text(ft_stopword_cs,
@@ -39,7 +39,7 @@ static int FT_STOPWORD_cmp(void* cmp_arg __attribute__((unused)),
 }
 
 static void FT_STOPWORD_free(FT_STOPWORD *w, TREE_FREE action,
-                             void *arg __attribute__((unused)))
+                             void *arg MY_ATTRIBUTE((unused)))
 {
   if (action == free_free)
     my_free((void*)w->pos);
--- a/storage/myisam/ha_myisam.cc
+++ b/storage/myisam/ha_myisam.cc
@@ -1,5 +1,5 @@
 /*
-   Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -1725,8 +1725,8 @@ int ha_myisam::index_last(uchar *buf)
 }
 
 int ha_myisam::index_next_same(uchar *buf,
-			       const uchar *key __attribute__((unused)),
-			       uint length __attribute__((unused)))
+			       const uchar *key MY_ATTRIBUTE((unused)),
+			       uint length MY_ATTRIBUTE((unused)))
 {
   int error;
   DBUG_ASSERT(inited==INDEX);
--- a/storage/myisam/mi_check.c
+++ b/storage/myisam/mi_check.c
@@ -1,5 +1,5 @@
 /*
-   Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -1902,7 +1902,7 @@ int movepoint(register MI_INFO *info, uchar *record, my_off_t oldpos,
 
 	/* Tell system that we want all memory for our cache */
 
-void lock_memory(MI_CHECK *param __attribute__((unused)))
+void lock_memory(MI_CHECK *param MY_ATTRIBUTE((unused)))
 {
 #ifdef SUN_OS				/* Key-cacheing thrases on sun 4.1 */
   if (param->opt_lock_memory)
--- a/storage/myisam/mi_extrafunc.h
+++ b/storage/myisam/mi_extrafunc.h
@@ -1,5 +1,4 @@
-/* Copyright (c) 2000-2006 MySQL AB, 2009 Sun Microsystems, Inc.
-   Use is subject to license terms.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -14,9 +13,9 @@
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */
 
-void _mi_report_crashed(MI_INFO *file __attribute__((unused)),
-                        const char *message __attribute__((unused)),
-                        const char *sfile __attribute__((unused)),
-                        uint sline __attribute__((unused)))
+void _mi_report_crashed(MI_INFO *file MY_ATTRIBUTE((unused)),
+                        const char *message MY_ATTRIBUTE((unused)),
+                        const char *sfile MY_ATTRIBUTE((unused)),
+                        uint sline MY_ATTRIBUTE((unused)))
 {
 }
--- a/storage/myisam/mi_keycache.c
+++ b/storage/myisam/mi_keycache.c
@@ -1,5 +1,4 @@
-/* Copyright (c) 2003-2008 MySQL AB, 2009 Sun Microsystems, Inc.
-   Use is subject to license terms.
+/* Copyright (c) 2003, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -48,7 +47,7 @@
 */
 
 int mi_assign_to_key_cache(MI_INFO *info,
-			   ulonglong key_map __attribute__((unused)),
+			   ulonglong key_map MY_ATTRIBUTE((unused)),
 			   KEY_CACHE *key_cache)
 {
   int error= 0;
--- a/storage/myisam/mi_open.c
+++ b/storage/myisam/mi_open.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -1229,7 +1229,7 @@ exist a dup()-like call that would give us two different file descriptors.
 *************************************************************************/
 
 int mi_open_datafile(MI_INFO *info, MYISAM_SHARE *share, const char *org_name,
-                     File file_to_dup __attribute__((unused)))
+                     File file_to_dup MY_ATTRIBUTE((unused)))
 {
   char *data_name= share->data_file_name;
   char real_data_name[FN_REFLEN];
--- a/storage/myisam/mi_packrec.c
+++ b/storage/myisam/mi_packrec.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -1009,7 +1009,7 @@ static void uf_zerofill_normal(MI_COLUMNDEF *rec, MI_BIT_BUFF *bit_buff, uchar *
 }
 
 static void uf_constant(MI_COLUMNDEF *rec,
-			MI_BIT_BUFF *bit_buff __attribute__((unused)),
+			MI_BIT_BUFF *bit_buff MY_ATTRIBUTE((unused)),
 			uchar *to,
 			uchar *end)
 {
@@ -1027,8 +1027,8 @@ static void uf_intervall(MI_COLUMNDEF *rec, MI_BIT_BUFF *bit_buff, uchar *to,
 
 
 /*ARGSUSED*/
-static void uf_zero(MI_COLUMNDEF *rec __attribute__((unused)),
-		    MI_BIT_BUFF *bit_buff __attribute__((unused)),
+static void uf_zero(MI_COLUMNDEF *rec MY_ATTRIBUTE((unused)),
+		    MI_BIT_BUFF *bit_buff MY_ATTRIBUTE((unused)),
 		    uchar *to, uchar *end)
 {
   memset(to, 0, (end-to));
@@ -1058,7 +1058,7 @@ static void uf_blob(MI_COLUMNDEF *rec, MI_BIT_BUFF *bit_buff,
 
 
 static void uf_varchar1(MI_COLUMNDEF *rec, MI_BIT_BUFF *bit_buff,
-		       uchar *to, uchar *end __attribute__((unused)))
+		       uchar *to, uchar *end MY_ATTRIBUTE((unused)))
 {
   if (get_bit(bit_buff))
     to[0]= 0;				/* Zero lengths */
@@ -1072,7 +1072,7 @@ static void uf_varchar1(MI_COLUMNDEF *rec, MI_BIT_BUFF *bit_buff,
 
 
 static void uf_varchar2(MI_COLUMNDEF *rec, MI_BIT_BUFF *bit_buff,
-		       uchar *to, uchar *end __attribute__((unused)))
+		       uchar *to, uchar *end MY_ATTRIBUTE((unused)))
 {
   if (get_bit(bit_buff))
     to[0]=to[1]=0;				/* Zero lengths */
@@ -1607,7 +1607,7 @@ static int _mi_read_mempack_record(MI_INFO *info, my_off_t filepos, uchar *buf)
 static int _mi_read_rnd_mempack_record(MI_INFO *info, uchar *buf,
 				       register my_off_t filepos,
 				       my_bool skip_deleted_blocks
-				       __attribute__((unused)))
+				       MY_ATTRIBUTE((unused)))
 {
   MI_BLOCK_INFO block_info;
   MYISAM_SHARE *share=info->s;
--- a/storage/myisam/mi_search.c
+++ b/storage/myisam/mi_search.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -180,7 +180,7 @@ err:
 
 int _mi_bin_search(MI_INFO *info, register MI_KEYDEF *keyinfo, uchar *page,
                    uchar *key, uint key_len, uint comp_flag, uchar **ret_pos,
-                   uchar *buff __attribute__((unused)), my_bool *last_key)
+                   uchar *buff MY_ATTRIBUTE((unused)), my_bool *last_key)
 {
   reg4 int start,mid,end,save_end;
   int flag;
@@ -1420,9 +1420,9 @@ int _mi_search_last(register MI_INFO *info, register MI_KEYDEF *keyinfo,
 
 int
 _mi_calc_static_key_length(MI_KEYDEF *keyinfo,uint nod_flag,
-                           uchar *next_pos  __attribute__((unused)),
-                           uchar *org_key  __attribute__((unused)),
-                           uchar *prev_key __attribute__((unused)),
+                           uchar *next_pos  MY_ATTRIBUTE((unused)),
+                           uchar *org_key  MY_ATTRIBUTE((unused)),
+                           uchar *prev_key MY_ATTRIBUTE((unused)),
                            uchar *key, MI_KEY_PARAM *s_temp)
 {
   s_temp->key=key;
@@ -1433,9 +1433,9 @@ _mi_calc_static_key_length(MI_KEYDEF *keyinfo,uint nod_flag,
 
 int
 _mi_calc_var_key_length(MI_KEYDEF *keyinfo,uint nod_flag,
-                        uchar *next_pos  __attribute__((unused)),
-                        uchar *org_key  __attribute__((unused)),
-                        uchar *prev_key __attribute__((unused)),
+                        uchar *next_pos  MY_ATTRIBUTE((unused)),
+                        uchar *org_key  MY_ATTRIBUTE((unused)),
+                        uchar *prev_key MY_ATTRIBUTE((unused)),
                         uchar *key, MI_KEY_PARAM *s_temp)
 {
   s_temp->key=key;
@@ -1825,7 +1825,7 @@ _mi_calc_bin_pack_key_length(MI_KEYDEF *keyinfo,uint nod_flag,uchar *next_key,
 
 /* store key without compression */
 
-void _mi_store_static_key(MI_KEYDEF *keyinfo __attribute__((unused)),
+void _mi_store_static_key(MI_KEYDEF *keyinfo MY_ATTRIBUTE((unused)),
                           register uchar *key_pos,
                           register MI_KEY_PARAM *s_temp)
 {
@@ -1840,7 +1840,7 @@ void _mi_store_static_key(MI_KEYDEF *keyinfo __attribute__((unused)),
   { *((pos)++) = (uchar) ((length) >> 8); *((pos)++) = (uchar) (length);  } }
 
 
-void _mi_store_var_pack_key(MI_KEYDEF *keyinfo  __attribute__((unused)),
+void _mi_store_var_pack_key(MI_KEYDEF *keyinfo  MY_ATTRIBUTE((unused)),
                             register uchar *key_pos,
                             register MI_KEY_PARAM *s_temp)
 {
@@ -1903,7 +1903,7 @@ void _mi_store_var_pack_key(MI_KEYDEF *keyinfo  __attribute__((unused)),
 
 /* variable length key with prefix compression */
 
-void _mi_store_bin_pack_key(MI_KEYDEF *keyinfo  __attribute__((unused)),
+void _mi_store_bin_pack_key(MI_KEYDEF *keyinfo  MY_ATTRIBUTE((unused)),
                             register uchar *key_pos,
                             register MI_KEY_PARAM *s_temp)
 {
--- a/storage/myisam/mi_static.c
+++ b/storage/myisam/mi_static.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -41,7 +41,7 @@ ulonglong myisam_max_temp_length= MAX_FILE_SIZE;
 ulong    myisam_data_pointer_size=4;
 ulonglong    myisam_mmap_size= SIZE_T_MAX, myisam_mmap_used= 0;
 
-static int always_valid(const char *filename __attribute__((unused)))
+static int always_valid(const char *filename MY_ATTRIBUTE((unused)))
 {
   return 0;
 }
--- a/storage/myisam/mi_test1.c
+++ b/storage/myisam/mi_test1.c
@@ -1,5 +1,5 @@
 /*
-   Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -586,8 +586,8 @@ static struct my_option my_long_options[] =
 
 
 static my_bool
-get_one_option(int optid, const struct my_option *opt __attribute__((unused)),
-	       char *argument __attribute__((unused)))
+get_one_option(int optid, const struct my_option *opt MY_ATTRIBUTE((unused)),
+	       char *argument MY_ATTRIBUTE((unused)))
 {
   switch(optid) {
   case 'a':
--- a/storage/myisam/myisam_ftdump.c
+++ b/storage/myisam/myisam_ftdump.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2001, 2010, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2001, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -226,8 +226,8 @@ err:
 
 
 static my_bool
-get_one_option(int optid, const struct my_option *opt __attribute__((unused)),
-	       char *argument __attribute__((unused)))
+get_one_option(int optid, const struct my_option *opt MY_ATTRIBUTE((unused)),
+	       char *argument MY_ATTRIBUTE((unused)))
 {
   switch(optid) {
   case 'd':
--- a/storage/myisam/myisamchk.c
+++ b/storage/myisam/myisamchk.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -466,7 +466,7 @@ TYPELIB myisam_stats_method_typelib= {
 
 static my_bool
 get_one_option(int optid,
-	       const struct my_option *opt __attribute__((unused)),
+	       const struct my_option *opt MY_ATTRIBUTE((unused)),
 	       char *argument)
 {
   switch (optid) {
@@ -1711,7 +1711,7 @@ err:
 
 static int not_killed= 0;
 
-volatile int *killed_ptr(MI_CHECK *param __attribute__((unused)))
+volatile int *killed_ptr(MI_CHECK *param MY_ATTRIBUTE((unused)))
 {
   return &not_killed;			/* always NULL */
 }
@@ -1719,7 +1719,7 @@ volatile int *killed_ptr(MI_CHECK *param __attribute__((unused)))
 	/* print warnings and errors */
 	/* VARARGS */
 
-void mi_check_print_info(MI_CHECK *param __attribute__((unused)),
+void mi_check_print_info(MI_CHECK *param MY_ATTRIBUTE((unused)),
 			 const char *fmt,...)
 {
   va_list args;
--- a/storage/myisam/myisamlog.c
+++ b/storage/myisam/myisamlog.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -695,7 +695,7 @@ static int read_string(IO_CACHE *file, register uchar* *to, register uint length
 }				/* read_string */
 
 
-static int file_info_compare(void* cmp_arg __attribute__((unused)),
+static int file_info_compare(void* cmp_arg MY_ATTRIBUTE((unused)),
 			     void *a, void *b)
 {
   long lint;
@@ -709,7 +709,7 @@ static int file_info_compare(void* cmp_arg __attribute__((unused)),
 	/* ARGSUSED */
 
 static int test_if_open (struct file_info *key,
-			 element_count count __attribute__((unused)),
+			 element_count count MY_ATTRIBUTE((unused)),
 			 struct test_if_open_param *param)
 {
   if (!strcmp(key->name,param->name) && key->id > param->max_id)
@@ -737,7 +737,7 @@ static void fix_blob_pointers(MI_INFO *info, uchar *record)
 	/* ARGSUSED */
 
 static int test_when_accessed (struct file_info *key,
-			       element_count count __attribute__((unused)),
+			       element_count count MY_ATTRIBUTE((unused)),
 			       struct st_access_param *access_param)
 {
   if (key->accessed < access_param->min_accessed && ! key->closed)
--- a/storage/myisam/myisampack.c
+++ b/storage/myisam/myisampack.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -29,6 +29,7 @@
 #endif
 #include <my_getopt.h>
 #include <assert.h>
+#include <welcome_copyright_notice.h> // ORACLE_WELCOME_COPYRIGHT_NOTICE
 
 #if SIZEOF_LONG_LONG > 4
 #define BITS_SAVED 64
@@ -130,7 +131,7 @@ static void free_counts_and_tree_and_queue(HUFF_TREE *huff_trees,
 					   uint trees,
 					   HUFF_COUNTS *huff_counts,
 					   uint fields);
-static int compare_tree(void* cmp_arg __attribute__((unused)),
+static int compare_tree(void* cmp_arg MY_ATTRIBUTE((unused)),
 			const uchar *s,const uchar *t);
 static int get_statistic(PACK_MRG_INFO *mrg,HUFF_COUNTS *huff_counts);
 static void check_counts(HUFF_COUNTS *huff_counts,uint trees,
@@ -300,9 +301,7 @@ static void print_version(void)
 static void usage(void)
 {
   print_version();
-  puts("Copyright 2002-2008 MySQL AB, 2008 Sun Microsystems, Inc.");
-  puts("This software comes with ABSOLUTELY NO WARRANTY. This is free software,");
-  puts("and you are welcome to modify and redistribute it under the GPL license\n");
+  puts(ORACLE_WELCOME_COPYRIGHT_NOTICE("2002"));
 
   puts("Pack a MyISAM-table to take much less space.");
   puts("Keys are not updated, you must run myisamchk -rq on the datafile");
@@ -317,7 +316,7 @@ static void usage(void)
 
 
 static my_bool
-get_one_option(int optid, const struct my_option *opt __attribute__((unused)),
+get_one_option(int optid, const struct my_option *opt MY_ATTRIBUTE((unused)),
 	       char *argument)
 {
   uint length;
@@ -1176,7 +1175,7 @@ static int get_statistic(PACK_MRG_INFO *mrg,HUFF_COUNTS *huff_counts)
   DBUG_RETURN(error != HA_ERR_END_OF_FILE);
 }
 
-static int compare_huff_elements(void *not_used __attribute__((unused)),
+static int compare_huff_elements(void *not_used MY_ATTRIBUTE((unused)),
 				 uchar *a, uchar *b)
 {
   return *((my_off_t*) a) < *((my_off_t*) b) ? -1 :
@@ -1693,7 +1692,7 @@ static int make_huff_tree(HUFF_TREE *huff_tree, HUFF_COUNTS *huff_counts)
   return 0;
 }
 
-static int compare_tree(void* cmp_arg __attribute__((unused)),
+static int compare_tree(void* cmp_arg MY_ATTRIBUTE((unused)),
 			register const uchar *s, register const uchar *t)
 {
   uint length;
--- a/storage/myisam/rt_test.c
+++ b/storage/myisam/rt_test.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2002, 2011, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2002, 2016, Oracle and/or its affiliates. All rights reserved.
    
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -79,7 +79,7 @@ static double rt_data[]=
   -1
 };
 
-int main(int argc __attribute__((unused)),char *argv[] __attribute__((unused)))
+int main(int argc MY_ATTRIBUTE((unused)),char *argv[] MY_ATTRIBUTE((unused)))
 {
   MY_INIT(argv[0]);
   exit(run_test("rt_test"));
@@ -367,7 +367,7 @@ static int read_with_pos (MI_INFO * file,int silent)
 
 
 static void print_record(uchar * record,
-			 my_off_t offs __attribute__((unused)),
+			 my_off_t offs MY_ATTRIBUTE((unused)),
 			 const char * tail)
 {
   int i;
@@ -420,7 +420,7 @@ static void create_record(uchar *record,uint rownr)
 }
 
 #else
-int main(int argc __attribute__((unused)),char *argv[] __attribute__((unused)))
+int main(int argc MY_ATTRIBUTE((unused)),char *argv[] MY_ATTRIBUTE((unused)))
 {
   exit(0);
 }
--- a/storage/myisam/sort.c
+++ b/storage/myisam/sort.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -886,7 +886,7 @@ static int write_merge_key_varlen(MI_SORT_PARAM *info,
 }
 
 
-static int write_merge_key(MI_SORT_PARAM *info __attribute__((unused)),
+static int write_merge_key(MI_SORT_PARAM *info MY_ATTRIBUTE((unused)),
                            IO_CACHE *to_file, uchar *key,
                            uint sort_length, uint count)
 {
--- a/storage/myisam/sp_key.c
+++ b/storage/myisam/sp_key.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
    
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -118,7 +118,7 @@ static int sp_mbr_from_wkb(uchar *wkb, uint size, uint n_dims, double *mbr)
 */
 
 static int sp_add_point_to_mbr(uchar *(*wkb), uchar *end, uint n_dims, 
-			       uchar byte_order __attribute__((unused)),
+			       uchar byte_order MY_ATTRIBUTE((unused)),
 			       double *mbr)
 {
   double ord;
--- a/storage/myisam/sp_test.c
+++ b/storage/myisam/sp_test.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2002, 2011, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2002, 2016, Oracle and/or its affiliates. All rights reserved.
    
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -40,7 +40,7 @@ static  void rtree_PrintWKB(uchar *wkb, uint n_dims);
 static char blob_key[MAX_REC_LENGTH];
 
 
-int main(int argc  __attribute__((unused)),char *argv[])
+int main(int argc  MY_ATTRIBUTE((unused)),char *argv[])
 {
   MY_INIT(argv[0]);
   exit(run_test("sp_test"));
@@ -487,7 +487,7 @@ static void rtree_PrintWKB(uchar *wkb, uint n_dims)
 }
 
 #else
-int main(int argc __attribute__((unused)),char *argv[] __attribute__((unused)))
+int main(int argc MY_ATTRIBUTE((unused)),char *argv[] MY_ATTRIBUTE((unused)))
 {
   exit(0);
 }
--- a/storage/myisammrg/ha_myisammrg.cc
+++ b/storage/myisammrg/ha_myisammrg.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -347,7 +347,7 @@ CPP_UNNAMED_NS_END
   and adds a child list of TABLE_LIST to the parent handler.
 */
 
-int ha_myisammrg::open(const char *name, int mode __attribute__((unused)),
+int ha_myisammrg::open(const char *name, int mode MY_ATTRIBUTE((unused)),
                        uint test_if_locked_arg)
 {
   DBUG_ENTER("ha_myisammrg::open");
@@ -1183,8 +1183,8 @@ int ha_myisammrg::index_last(uchar * buf)
 }
 
 int ha_myisammrg::index_next_same(uchar * buf,
-                                  const uchar *key __attribute__((unused)),
-                                  uint length __attribute__((unused)))
+                                  const uchar *key MY_ATTRIBUTE((unused)),
+                                  uint length MY_ATTRIBUTE((unused)))
 {
   int error;
   DBUG_ASSERT(this->file->children_attached);
--- a/storage/ndb/include/ndb_global.h
+++ b/storage/ndb/include/ndb_global.h
@@ -1,5 +1,5 @@
 /*
-   Copyright (c) 2004, 2010, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2004, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -251,19 +251,19 @@ extern "C" {
 #endif
 
 /**
- *  __attribute__((noreturn)) was introduce in gcc 2.5
+ *  MY_ATTRIBUTE((noreturn)) was introduce in gcc 2.5
  */
 #if (GCC_VERSION >= 2005)
-#define ATTRIBUTE_NORETURN __attribute__((noreturn))
+#define ATTRIBUTE_NORETURN MY_ATTRIBUTE((noreturn))
 #else
 #define ATTRIBUTE_NORETURN
 #endif
 
 /**
- *  __attribute__((noinline)) was introduce in gcc 3.1
+ *  MY_ATTRIBUTE((noinline)) was introduce in gcc 3.1
  */
 #if (GCC_VERSION >= 3001)
-#define ATTRIBUTE_NOINLINE __attribute__((noinline))
+#define ATTRIBUTE_NOINLINE MY_ATTRIBUTE((noinline))
 #else
 #define ATTRIBUTE_NOINLINE
 #endif
--- a/storage/ndb/include/util/ndb_opts.h
+++ b/storage/ndb/include/util/ndb_opts.h
@@ -1,5 +1,5 @@
 /*
-   Copyright (c) 2004, 2010, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2004, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -123,7 +123,7 @@ void ndb_opt_set_usage_funcs(void (*short_usage)(void),
                              void (*usage)(void));
 my_bool
 ndb_std_get_one_option(int optid,
-		       const struct my_option *opt __attribute__((unused)),
+		       const struct my_option *opt MY_ATTRIBUTE((unused)),
                        char *argument);
 
 void ndb_usage(void (*usagefunc)(void), const char *load_default_groups[],
--- a/storage/ndb/src/common/util/ndb_opts.c
+++ b/storage/ndb/src/common/util/ndb_opts.c
@@ -1,5 +1,5 @@
 /*
-   Copyright (c) 2008, 2010, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -82,8 +82,8 @@ void ndb_usage(void (*usagefunc)(void), const char *load_default_groups[],
 
 my_bool
 ndb_std_get_one_option(int optid,
-                       const struct my_option *opt __attribute__((unused)),
-                       char *argument __attribute__((unused)))
+                       const struct my_option *opt MY_ATTRIBUTE((unused)),
+                       char *argument MY_ATTRIBUTE((unused)))
 {
   switch (optid) {
 #ifndef DBUG_OFF
--- a/storage/ndb/src/cw/cpcd/main.cpp
+++ b/storage/ndb/src/cw/cpcd/main.cpp
@@ -1,5 +1,5 @@
 /*
-   Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2003, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -63,7 +63,7 @@ static struct my_option my_long_options[] =
 };
 
 static my_bool
-get_one_option(int optid, const struct my_option *opt __attribute__((unused)),
+get_one_option(int optid, const struct my_option *opt MY_ATTRIBUTE((unused)),
 	       char *argument)
 {
   return 0;
--- a/storage/ndb/tools/restore/restore_main.cpp
+++ b/storage/ndb/tools/restore/restore_main.cpp
@@ -1,5 +1,5 @@
 /*
-   Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2003, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -415,7 +415,7 @@ static void usage()
 }
 
 static my_bool
-get_one_option(int optid, const struct my_option *opt __attribute__((unused)),
+get_one_option(int optid, const struct my_option *opt MY_ATTRIBUTE((unused)),
 	       char *argument)
 {
 #ifndef DBUG_OFF
--- a/strings/conf_to_src.c
+++ b/strings/conf_to_src.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -145,8 +145,8 @@ static int add_collation(CHARSET_INFO *cs)
 
 
 static void
-default_reporter(enum loglevel level  __attribute__ ((unused)),
-                 const char *format  __attribute__ ((unused)),
+default_reporter(enum loglevel level  MY_ATTRIBUTE ((unused)),
+                 const char *format  MY_ATTRIBUTE ((unused)),
                  ...)
 {
 }
@@ -271,7 +271,7 @@ static void
 fprint_copyright(FILE *file)
 {
   fprintf(file,
-"/* Copyright (c) 2003, 2011, Oracle and/or its affiliates. All rights reserved.\n"
+"/* Copyright (c) 2003, 2016, Oracle and/or its affiliates. All rights reserved.\n"
 "\n"
 "   This program is free software; you can redistribute it and/or modify\n"
 "   it under the terms of the GNU General Public License as published by\n"
@@ -290,7 +290,7 @@ fprint_copyright(FILE *file)
 
 
 int
-main(int argc, char **argv  __attribute__((unused)))
+main(int argc, char **argv  MY_ATTRIBUTE((unused)))
 {
   CHARSET_INFO  ncs;
   CHARSET_INFO  *cs;
--- a/strings/ctype-big5.c
+++ b/strings/ctype-big5.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -872,7 +872,7 @@ static int my_strnncoll_big5_internal(const uchar **a_res,
 
 /* Compare strings */
 
-static int my_strnncoll_big5(const CHARSET_INFO *cs __attribute__((unused)), 
+static int my_strnncoll_big5(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)), 
 			     const uchar *a, size_t a_length,
                              const uchar *b, size_t b_length,
                              my_bool b_is_prefix)
@@ -885,7 +885,7 @@ static int my_strnncoll_big5(const CHARSET_INFO *cs __attribute__((unused)),
 
 /* compare strings, ignore end space */
 
-static int my_strnncollsp_big5(const CHARSET_INFO* cs __attribute__((unused)),
+static int my_strnncollsp_big5(const CHARSET_INFO* cs MY_ATTRIBUTE((unused)),
 			       const uchar *a, size_t a_length, 
 			       const uchar *b, size_t b_length,
                                my_bool diff_if_only_endspace_difference)
@@ -957,14 +957,14 @@ my_strnxfrm_big5(const CHARSET_INFO *cs,
 }
 
 
-static uint ismbchar_big5(const CHARSET_INFO *cs __attribute__((unused)),
+static uint ismbchar_big5(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                          const char* p, const char *e)
 {
   return (isbig5head(*(p)) && (e)-(p)>1 && isbig5tail(*((p)+1))? 2: 0);
 }
 
 
-static uint mbcharlen_big5(const CHARSET_INFO *cs __attribute__((unused)),
+static uint mbcharlen_big5(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                            uint c)
 {
   return (isbig5head(c)? 2 : 1);
@@ -6742,7 +6742,7 @@ static int func_uni_big5_onechar(int code){
 
 
 static int
-my_wc_mb_big5(const CHARSET_INFO *cs __attribute__((unused)),
+my_wc_mb_big5(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
 	      my_wc_t wc, uchar *s, uchar *e)
 {
 
@@ -6771,7 +6771,7 @@ my_wc_mb_big5(const CHARSET_INFO *cs __attribute__((unused)),
 
 
 static int 
-my_mb_wc_big5(const CHARSET_INFO *cs __attribute__((unused)),
+my_mb_wc_big5(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
 	      my_wc_t *pwc,const uchar *s,const uchar *e)
 {
 
@@ -6801,7 +6801,7 @@ my_mb_wc_big5(const CHARSET_INFO *cs __attribute__((unused)),
   CP950 and HKSCS additional characters are also accepted.
 */
 static
-size_t my_well_formed_len_big5(const CHARSET_INFO *cs __attribute__((unused)),
+size_t my_well_formed_len_big5(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                                const char *b, const char *e,
                                size_t pos, int *error)
 {
--- a/strings/ctype-bin.c
+++ b/strings/ctype-bin.c
@@ -1,5 +1,5 @@
 /* Copyright (c) 2002 MySQL AB & tommy@valley.ne.jp
-   Copyright (c) 2002, 2014, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2002, 2016, Oracle and/or its affiliates. All rights reserved.
    
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
@@ -69,13 +69,13 @@ static uchar bin_char_array[] =
 
 static my_bool 
 my_coll_init_8bit_bin(CHARSET_INFO *cs,
-                      MY_CHARSET_LOADER *loader __attribute__((unused)))
+                      MY_CHARSET_LOADER *loader MY_ATTRIBUTE((unused)))
 {
   cs->max_sort_char=255; 
   return FALSE;
 }
 
-static int my_strnncoll_binary(const CHARSET_INFO *cs __attribute__((unused)),
+static int my_strnncoll_binary(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                                const uchar *s, size_t slen,
                                const uchar *t, size_t tlen,
                                my_bool t_is_prefix)
@@ -86,8 +86,8 @@ static int my_strnncoll_binary(const CHARSET_INFO *cs __attribute__((unused)),
 }
 
 
-size_t my_lengthsp_binary(const CHARSET_INFO *cs __attribute__((unused)),
-                          const char *ptr __attribute__((unused)),
+size_t my_lengthsp_binary(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
+                          const char *ptr MY_ATTRIBUTE((unused)),
                           size_t length)
 {
   return length;
@@ -117,18 +117,18 @@ size_t my_lengthsp_binary(const CHARSET_INFO *cs __attribute__((unused)),
 */
 
 static int my_strnncollsp_binary(const CHARSET_INFO *cs
-                                 __attribute__((unused)),
+                                 MY_ATTRIBUTE((unused)),
                                  const uchar *s, size_t slen,
                                  const uchar *t, size_t tlen,
                                  my_bool diff_if_only_endspace_difference
-                                 __attribute__((unused)))
+                                 MY_ATTRIBUTE((unused)))
 {
   return my_strnncoll_binary(cs,s,slen,t,tlen,0);
 }
 
 
 static int my_strnncoll_8bit_bin(const CHARSET_INFO *cs
-                                 __attribute__((unused)),
+                                 MY_ATTRIBUTE((unused)),
                                  const uchar *s, size_t slen,
                                  const uchar *t, size_t tlen,
                                  my_bool t_is_prefix)
@@ -165,7 +165,7 @@ static int my_strnncoll_8bit_bin(const CHARSET_INFO *cs
 */
 
 static int my_strnncollsp_8bit_bin(const CHARSET_INFO *cs
-                                   __attribute__((unused)),
+                                   MY_ATTRIBUTE((unused)),
                                    const uchar *a, size_t a_length, 
                                    const uchar *b, size_t b_length,
                                    my_bool diff_if_only_endspace_difference)
@@ -214,41 +214,41 @@ static int my_strnncollsp_8bit_bin(const CHARSET_INFO *cs
 
 /* This function is used for all conversion functions */
 
-static size_t my_case_str_bin(const CHARSET_INFO *cs __attribute__((unused)),
-                              char *str __attribute__((unused)))
+static size_t my_case_str_bin(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
+                              char *str MY_ATTRIBUTE((unused)))
 {
   return 0;
 }
 
 
-static size_t my_case_bin(const CHARSET_INFO *cs __attribute__((unused)),
-                          char *src __attribute__((unused)),
+static size_t my_case_bin(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
+                          char *src MY_ATTRIBUTE((unused)),
                           size_t srclen,
-                          char *dst __attribute__((unused)),
-                          size_t dstlen __attribute__((unused)))
+                          char *dst MY_ATTRIBUTE((unused)),
+                          size_t dstlen MY_ATTRIBUTE((unused)))
 {
   return srclen;
 }
 
 
-static int my_strcasecmp_bin(const CHARSET_INFO *cs __attribute__((unused)),
+static int my_strcasecmp_bin(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
 			     const char *s, const char *t)
 {
   return strcmp(s,t);
 }
 
 
-uint my_mbcharlen_8bit(const CHARSET_INFO *cs __attribute__((unused)),
-                      uint c __attribute__((unused)))
+uint my_mbcharlen_8bit(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
+                      uint c MY_ATTRIBUTE((unused)))
 {
   return 1;
 }
 
 
-static int my_mb_wc_bin(const CHARSET_INFO *cs __attribute__((unused)),
+static int my_mb_wc_bin(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
 			my_wc_t *wc,
 			const uchar *str,
-			const uchar *end __attribute__((unused)))
+			const uchar *end MY_ATTRIBUTE((unused)))
 {
   if (str >= end)
     return MY_CS_TOOSMALL;
@@ -258,10 +258,10 @@ static int my_mb_wc_bin(const CHARSET_INFO *cs __attribute__((unused)),
 }
 
 
-static int my_wc_mb_bin(const CHARSET_INFO *cs __attribute__((unused)),
+static int my_wc_mb_bin(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
 			my_wc_t wc,
 			uchar *s,
-			uchar *e __attribute__((unused)))
+			uchar *e MY_ATTRIBUTE((unused)))
 {
   if (s >= e)
     return MY_CS_TOOSMALL;
@@ -275,7 +275,7 @@ static int my_wc_mb_bin(const CHARSET_INFO *cs __attribute__((unused)),
 }
 
 
-void my_hash_sort_8bit_bin(const CHARSET_INFO *cs __attribute__((unused)),
+void my_hash_sort_8bit_bin(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                            const uchar *key, size_t len,
                            ulong *nr1, ulong *nr2)
 {
@@ -296,7 +296,7 @@ void my_hash_sort_8bit_bin(const CHARSET_INFO *cs __attribute__((unused)),
 }
 
 
-void my_hash_sort_bin(const CHARSET_INFO *cs __attribute__((unused)),
+void my_hash_sort_bin(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
 		      const uchar *key, size_t len,ulong *nr1, ulong *nr2)
 {
   const uchar *pos = key;
@@ -428,7 +428,7 @@ my_strnxfrm_8bit_bin(const CHARSET_INFO *cs,
 
 
 static
-uint my_instr_bin(const CHARSET_INFO *cs __attribute__((unused)),
+uint my_instr_bin(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
 		  const char *b, size_t b_length,
 		  const char *s, size_t s_length,
 		  my_match_t *match, uint nmatch)
--- a/strings/ctype-cp932.c
+++ b/strings/ctype-cp932.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2005, 2011, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2005, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -182,13 +182,13 @@ static uchar sort_order_cp932[]=
                        (0x80<=(c) && (c)<=0xfc))
 
 
-static uint ismbchar_cp932(const CHARSET_INFO *cs __attribute__((unused)),
+static uint ismbchar_cp932(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
 			 const char* p, const char *e)
 {
   return (iscp932head((uchar) *p) && (e-p)>1 && iscp932tail((uchar)p[1]) ? 2: 0);
 }
 
-static uint mbcharlen_cp932(const CHARSET_INFO *cs __attribute__((unused)),
+static uint mbcharlen_cp932(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                             uint c)
 {
   return (iscp932head((uchar) c) ? 2 : 1);
@@ -1742,7 +1742,7 @@ static int my_strnncoll_cp932_internal(const CHARSET_INFO *cs,
 }
 
 
-static int my_strnncoll_cp932(const CHARSET_INFO *cs __attribute__((unused)),
+static int my_strnncoll_cp932(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
 			      const uchar *a, size_t a_length, 
 			      const uchar *b, size_t b_length,
                               my_bool b_is_prefix)
@@ -1755,11 +1755,11 @@ static int my_strnncoll_cp932(const CHARSET_INFO *cs __attribute__((unused)),
 
 
 static int my_strnncollsp_cp932(const CHARSET_INFO *cs
-                                __attribute__((unused)),
+                                MY_ATTRIBUTE((unused)),
                                 const uchar *a, size_t a_length, 
                                 const uchar *b, size_t b_length,
                                 my_bool diff_if_only_endspace_difference
-                                __attribute__((unused)))
+                                MY_ATTRIBUTE((unused)))
 {
   const uchar *a_end= a + a_length;
   const uchar *b_end= b + b_length;
@@ -34601,7 +34601,7 @@ static uint16 unicode_to_cp932[65536]=
 */
 
 static int
-my_mb_wc_cp932(const CHARSET_INFO *cs  __attribute__((unused)),
+my_mb_wc_cp932(const CHARSET_INFO *cs  MY_ATTRIBUTE((unused)),
 	       my_wc_t *pwc, const uchar *s, const uchar *e){
   int hi;
 
@@ -34645,7 +34645,7 @@ my_mb_wc_cp932(const CHARSET_INFO *cs  __attribute__((unused)),
   @retval   MY_CS_ILUNI    If the Unicode character does not exist in CP932
 */
 static int
-my_wc_mb_cp932(const CHARSET_INFO *cs __attribute__((unused)),
+my_wc_mb_cp932(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
 	       my_wc_t wc, uchar *s, uchar *e)
 {
   int code;
@@ -34685,7 +34685,7 @@ my_wc_mb_cp932(const CHARSET_INFO *cs __attribute__((unused)),
 
 
 static
-size_t my_numcells_cp932(const CHARSET_INFO *cs __attribute__((unused)),
+size_t my_numcells_cp932(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                       const char *str, const char *str_end)
 {
   size_t clen= 0;
@@ -34720,7 +34720,7 @@ size_t my_numcells_cp932(const CHARSET_INFO *cs __attribute__((unused)),
 
 static
 size_t my_well_formed_len_cp932(const CHARSET_INFO *cs
-                                __attribute__((unused)),
+                                MY_ATTRIBUTE((unused)),
                                 const char *b, const char *e,
                                 size_t pos, int *error)
 {
--- a/strings/ctype-czech.c
+++ b/strings/ctype-czech.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -228,7 +228,7 @@ while (1)						\
   the length of the strings being specified
 */
 
-static int my_strnncoll_czech(const CHARSET_INFO *cs __attribute__((unused)),
+static int my_strnncoll_czech(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
 			      const uchar *s1, size_t len1, 
 			      const uchar *s2, size_t len2,
                               my_bool s2_is_prefix)
@@ -266,7 +266,7 @@ int my_strnncollsp_czech(const CHARSET_INFO *cs,
                          const uchar *s, size_t slen, 
                          const uchar *t, size_t tlen,
                          my_bool diff_if_only_endspace_difference
-                         __attribute__((unused)))
+                         MY_ATTRIBUTE((unused)))
 {
   for ( ; slen && s[slen-1] == ' ' ; slen--);
   for ( ; tlen && t[tlen-1] == ' ' ; tlen--);
@@ -279,7 +279,7 @@ int my_strnncollsp_czech(const CHARSET_INFO *cs,
 */
 static size_t
 my_strnxfrmlen_czech(const CHARSET_INFO *cs
-                     __attribute__((unused)), size_t len)
+                     MY_ATTRIBUTE((unused)), size_t len)
 {
   return len * 4 + 4;
 }
@@ -291,9 +291,9 @@ my_strnxfrmlen_czech(const CHARSET_INFO *cs
 */
 
 static size_t
-my_strnxfrm_czech(const CHARSET_INFO *cs __attribute__((unused)), 
+my_strnxfrm_czech(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)), 
                   uchar *dest, size_t len,
-                  uint nweights_arg __attribute__((unused)),
+                  uint nweights_arg MY_ATTRIBUTE((unused)),
                   const uchar *src, size_t srclen, uint flags)
 {
   int value;
@@ -369,7 +369,7 @@ my_strnxfrm_czech(const CHARSET_INFO *cs __attribute__((unused)),
 
 
 static my_bool my_like_range_czech(const CHARSET_INFO *cs
-                                   __attribute__((unused)),
+                                   MY_ATTRIBUTE((unused)),
 				   const char *ptr,size_t ptr_length,
 				   pbool escape, pbool w_one, pbool w_many,
 				   size_t res_length, char *min_str,
--- a/strings/ctype-euc_kr.c
+++ b/strings/ctype-euc_kr.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -202,7 +202,7 @@ static uchar sort_order_euc_kr[]=
                               iseuc_kr_tail3(c))
 
 
-static uint ismbchar_euc_kr(const CHARSET_INFO *cs __attribute__((unused)),
+static uint ismbchar_euc_kr(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                             const char* p, const char *e)
 {
   return ((*(uchar*)(p)<0x80)? 0:\
@@ -210,7 +210,7 @@ static uint ismbchar_euc_kr(const CHARSET_INFO *cs __attribute__((unused)),
           0);
 }
 
-static uint mbcharlen_euc_kr(const CHARSET_INFO *cs __attribute__((unused)),
+static uint mbcharlen_euc_kr(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                              uint c)
 {
   return (iseuc_kr_head(c) ? 2 : 1);
@@ -9877,7 +9877,7 @@ static int func_uni_ksc5601_onechar(int code){
 
 
 static int
-my_wc_mb_euc_kr(const CHARSET_INFO *cs __attribute__((unused)),
+my_wc_mb_euc_kr(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
 		 my_wc_t wc, uchar *s, uchar *e)
 {
   int code;
@@ -9905,7 +9905,7 @@ my_wc_mb_euc_kr(const CHARSET_INFO *cs __attribute__((unused)),
 
 
 static int 
-my_mb_wc_euc_kr(const CHARSET_INFO *cs __attribute__((unused)),
+my_mb_wc_euc_kr(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
 		 my_wc_t *pwc, const uchar *s, const uchar *e)
 {
   
@@ -9934,7 +9934,7 @@ my_mb_wc_euc_kr(const CHARSET_INFO *cs __attribute__((unused)),
   Returns well formed length of a EUC-KR string.
 */
 static size_t
-my_well_formed_len_euckr(const CHARSET_INFO *cs __attribute__((unused)),
+my_well_formed_len_euckr(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                          const char *b, const char *e,
                          size_t pos, int *error)
 {
--- a/strings/ctype-eucjpms.c
+++ b/strings/ctype-eucjpms.c
@@ -1,5 +1,5 @@
 /* Copyright (c) 2002 MySQL AB & tommy@valley.ne.jp
-   Copyright (c) 2005, 2014, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2005, 2016, Oracle and/or its affiliates. All rights reserved.
    
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
@@ -185,7 +185,7 @@ static uchar sort_order_eucjpms[]=
 #define iseucjpms_ss3(c) (((c)&0xff) == 0x8f)
 
 
-static uint ismbchar_eucjpms(const CHARSET_INFO *cs __attribute__((unused)),
+static uint ismbchar_eucjpms(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
 		  const char* p, const char *e)
 {
   return ((*(uchar*)(p)<0x80)? 0:\
@@ -195,7 +195,7 @@ static uint ismbchar_eucjpms(const CHARSET_INFO *cs __attribute__((unused)),
     0);
 }
 
-static uint mbcharlen_eucjpms(const CHARSET_INFO *cs __attribute__((unused)),
+static uint mbcharlen_eucjpms(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                               uint c)
 {
   return (iseucjpms(c)? 2: iseucjpms_ss2(c)? 2: iseucjpms_ss3(c)? 3: 1);
@@ -67311,7 +67311,7 @@ static uint16 unicode_to_jisx0212_eucjpms[65536]=
   @retval   MY_CS_ILSEQ    If a wrong byte sequence was found
 */
 static int
-my_mb_wc_eucjpms(const CHARSET_INFO *cs __attribute__((unused)),
+my_mb_wc_eucjpms(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                  my_wc_t *pwc, const uchar *s, const uchar *e)
 {
   int hi;
@@ -67371,7 +67371,7 @@ my_mb_wc_eucjpms(const CHARSET_INFO *cs __attribute__((unused)),
   @retval   MY_CS_ILUNI    If the Unicode character does not exist in EUCJPMS
 */
 static int
-my_wc_mb_eucjpms(const CHARSET_INFO *cs __attribute__((unused)),
+my_wc_mb_eucjpms(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                  my_wc_t wc, uchar *s, uchar *e)
 {
   int jp;
@@ -67427,7 +67427,7 @@ my_wc_mb_eucjpms(const CHARSET_INFO *cs __attribute__((unused)),
 
 static
 size_t my_well_formed_len_eucjpms(const CHARSET_INFO *cs
-                                  __attribute__((unused)),
+                                  MY_ATTRIBUTE((unused)),
                                   const char *beg, const char *end, size_t pos,
                                   int *error)
 {
@@ -67475,7 +67475,7 @@ size_t my_well_formed_len_eucjpms(const CHARSET_INFO *cs
 
 
 static
-size_t my_numcells_eucjpms(const CHARSET_INFO *cs __attribute__((unused)),
+size_t my_numcells_eucjpms(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                            const char *str, const char *str_end)
 {
   size_t clen;
--- a/strings/ctype-gb2312.c
+++ b/strings/ctype-gb2312.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -165,13 +165,13 @@ static uchar sort_order_gb2312[]=
 #define isgb2312tail(c) (0xa1<=(uchar)(c) && (uchar)(c)<=0xfe)
 
 
-static uint ismbchar_gb2312(const CHARSET_INFO *cs __attribute__((unused)),
+static uint ismbchar_gb2312(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
 		    const char* p, const char *e)
 {
   return (isgb2312head(*(p)) && (e)-(p)>1 && isgb2312tail(*((p)+1))? 2: 0);
 }
 
-static uint mbcharlen_gb2312(const CHARSET_INFO *cs __attribute__((unused)),
+static uint mbcharlen_gb2312(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                              uint c)
 {
   return (isgb2312head(c)? 2 : 1);
@@ -6282,7 +6282,7 @@ static int func_uni_gb2312_onechar(int code){
 
 
 static int
-my_wc_mb_gb2312(const CHARSET_INFO *cs  __attribute__((unused)),
+my_wc_mb_gb2312(const CHARSET_INFO *cs  MY_ATTRIBUTE((unused)),
 		my_wc_t wc, uchar *s, uchar *e)
 {
   int code;
@@ -6310,7 +6310,7 @@ my_wc_mb_gb2312(const CHARSET_INFO *cs  __attribute__((unused)),
 
 
 static int 
-my_mb_wc_gb2312(const CHARSET_INFO *cs  __attribute__((unused)),
+my_mb_wc_gb2312(const CHARSET_INFO *cs  MY_ATTRIBUTE((unused)),
 		my_wc_t *pwc, const uchar *s, const uchar *e){
   int hi;
   
@@ -6337,7 +6337,7 @@ my_mb_wc_gb2312(const CHARSET_INFO *cs  __attribute__((unused)),
   Returns well formed length of a EUC-KR string.
 */
 static size_t
-my_well_formed_len_gb2312(const CHARSET_INFO *cs __attribute__((unused)),
+my_well_formed_len_gb2312(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                           const char *b, const char *e,
                           size_t pos, int *error)
 {
--- a/strings/ctype-gbk.c
+++ b/strings/ctype-gbk.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -3475,7 +3475,7 @@ int my_strnncoll_gbk_internal(const uchar **a_res, const uchar **b_res,
 
 
 
-int my_strnncoll_gbk(const CHARSET_INFO *cs __attribute__((unused)),
+int my_strnncoll_gbk(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
 		     const uchar *a, size_t a_length,
                      const uchar *b, size_t b_length,
                      my_bool b_is_prefix)
@@ -3486,7 +3486,7 @@ int my_strnncoll_gbk(const CHARSET_INFO *cs __attribute__((unused)),
 }
 
 
-static int my_strnncollsp_gbk(const CHARSET_INFO * cs __attribute__((unused)),
+static int my_strnncollsp_gbk(const CHARSET_INFO * cs MY_ATTRIBUTE((unused)),
 			      const uchar *a, size_t a_length, 
 			      const uchar *b, size_t b_length,
                               my_bool diff_if_only_endspace_difference)
@@ -3558,13 +3558,13 @@ my_strnxfrm_gbk(const CHARSET_INFO *cs,
 }
 
 
-static uint ismbchar_gbk(const CHARSET_INFO *cs __attribute__((unused)),
+static uint ismbchar_gbk(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
 		 const char* p, const char *e)
 {
   return (isgbkhead(*(p)) && (e)-(p)>1 && isgbktail(*((p)+1))? 2: 0);
 }
 
-static uint mbcharlen_gbk(const CHARSET_INFO *cs __attribute__((unused)),
+static uint mbcharlen_gbk(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                           uint c)
 {
   return (isgbkhead(c)? 2 : 1);
@@ -10675,7 +10675,7 @@ static int func_uni_gbk_onechar(int code){
 }
 
 static int
-my_wc_mb_gbk(const CHARSET_INFO *cs  __attribute__((unused)),
+my_wc_mb_gbk(const CHARSET_INFO *cs  MY_ATTRIBUTE((unused)),
 	      my_wc_t wc, uchar *s, uchar *e)
 {
   int code;
@@ -10701,7 +10701,7 @@ my_wc_mb_gbk(const CHARSET_INFO *cs  __attribute__((unused)),
 }
 
 static int
-my_mb_wc_gbk(const CHARSET_INFO *cs __attribute__((unused)),
+my_mb_wc_gbk(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
 	      my_wc_t *pwc, const uchar *s, const uchar *e)
 {
   int hi;
@@ -10732,7 +10732,7 @@ my_mb_wc_gbk(const CHARSET_INFO *cs __attribute__((unused)),
   Returns well formed length of a GBK string.
 */
 static
-size_t my_well_formed_len_gbk(const CHARSET_INFO *cs __attribute__((unused)),
+size_t my_well_formed_len_gbk(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                               const char *b, const char *e,
                               size_t pos, int *error)
 {
--- a/strings/ctype-latin1.c
+++ b/strings/ctype-latin1.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -356,10 +356,10 @@ NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL
 };
 
 static
-int my_mb_wc_latin1(const CHARSET_INFO *cs  __attribute__((unused)),
+int my_mb_wc_latin1(const CHARSET_INFO *cs  MY_ATTRIBUTE((unused)),
 		    my_wc_t *wc,
 		    const uchar *str,
-		    const uchar *end __attribute__((unused)))
+		    const uchar *end MY_ATTRIBUTE((unused)))
 {
   if (str >= end)
     return MY_CS_TOOSMALL;
@@ -369,10 +369,10 @@ int my_mb_wc_latin1(const CHARSET_INFO *cs  __attribute__((unused)),
 }
 
 static
-int my_wc_mb_latin1(const CHARSET_INFO *cs  __attribute__((unused)),
+int my_wc_mb_latin1(const CHARSET_INFO *cs  MY_ATTRIBUTE((unused)),
 		    my_wc_t wc,
 		    uchar *str,
-		    uchar *end __attribute__((unused)))
+		    uchar *end MY_ATTRIBUTE((unused)))
 {
   uchar *pl;
   
@@ -547,7 +547,7 @@ uchar combo2map[]={
 
 
 static int my_strnncoll_latin1_de(const CHARSET_INFO *cs
-                                  __attribute__((unused)),
+                                  MY_ATTRIBUTE((unused)),
 				  const uchar *a, size_t a_length,
 				  const uchar *b, size_t b_length,
                                   my_bool b_is_prefix)
@@ -589,7 +589,7 @@ static int my_strnncoll_latin1_de(const CHARSET_INFO *cs
 
 
 static int my_strnncollsp_latin1_de(const CHARSET_INFO *cs
-                                    __attribute__((unused)),
+                                    MY_ATTRIBUTE((unused)),
 				    const uchar *a, size_t a_length,
 				    const uchar *b, size_t b_length,
                                     my_bool diff_if_only_endspace_difference)
@@ -683,7 +683,7 @@ my_strnxfrm_latin1_de(const CHARSET_INFO *cs,
 }
 
 
-void my_hash_sort_latin1_de(const CHARSET_INFO *cs __attribute__((unused)),
+void my_hash_sort_latin1_de(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
 			    const uchar *key, size_t len,
 			    ulong *nr1, ulong *nr2)
 {
--- a/strings/ctype-mb.c
+++ b/strings/ctype-mb.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2002, 2014, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2002, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -74,8 +74,8 @@ get_case_info_for_ch(const CHARSET_INFO *cs, uint page, uint offs)
   For character sets which don't change octet length in case conversion.
 */
 size_t my_caseup_mb(const CHARSET_INFO *cs, char *src, size_t srclen,
-                    char *dst __attribute__((unused)),
-                    size_t dstlen __attribute__((unused)))
+                    char *dst MY_ATTRIBUTE((unused)),
+                    size_t dstlen MY_ATTRIBUTE((unused)))
 {
   register uint32 l;
   register char *srcend= src + srclen;
@@ -109,8 +109,8 @@ size_t my_caseup_mb(const CHARSET_INFO *cs, char *src, size_t srclen,
 
 
 size_t my_casedn_mb(const CHARSET_INFO *cs, char *src, size_t srclen,
-                    char *dst __attribute__((unused)),
-                    size_t dstlen __attribute__((unused)))
+                    char *dst MY_ATTRIBUTE((unused)),
+                    size_t dstlen MY_ATTRIBUTE((unused)))
 {
   register uint32 l;
   register char *srcend= src + srclen;
@@ -155,7 +155,7 @@ size_t my_casedn_mb(const CHARSET_INFO *cs, char *src, size_t srclen,
 static size_t
 my_casefold_mb_varlen(const CHARSET_INFO *cs,
                       char *src, size_t srclen,
-                      char *dst, size_t dstlen __attribute__((unused)),
+                      char *dst, size_t dstlen MY_ATTRIBUTE((unused)),
                       uchar *map,
                       size_t is_upper)
 {
@@ -373,7 +373,7 @@ int my_wildcmp_mb(const CHARSET_INFO *cs,
 }
 
 
-size_t my_numchars_mb(const CHARSET_INFO *cs __attribute__((unused)),
+size_t my_numchars_mb(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
 		      const char *pos, const char *end)
 {
   register size_t count= 0;
@@ -387,7 +387,7 @@ size_t my_numchars_mb(const CHARSET_INFO *cs __attribute__((unused)),
 }
 
 
-size_t my_charpos_mb(const CHARSET_INFO *cs __attribute__((unused)),
+size_t my_charpos_mb(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
 		     const char *pos, const char *end, size_t length)
 {
   const char *start= pos;
@@ -482,7 +482,7 @@ uint my_instr_mb(const CHARSET_INFO *cs,
 /* BINARY collations handlers for MB charsets */
 
 int
-my_strnncoll_mb_bin(const CHARSET_INFO *cs __attribute__((unused)),
+my_strnncoll_mb_bin(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                     const uchar *s, size_t slen,
                     const uchar *t, size_t tlen,
                     my_bool t_is_prefix)
@@ -519,7 +519,7 @@ my_strnncoll_mb_bin(const CHARSET_INFO *cs __attribute__((unused)),
 */
 
 int
-my_strnncollsp_mb_bin(const CHARSET_INFO *cs __attribute__((unused)),
+my_strnncollsp_mb_bin(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                       const uchar *a, size_t a_length, 
                       const uchar *b, size_t b_length,
                       my_bool diff_if_only_endspace_difference)
@@ -670,7 +670,7 @@ pad:
 
 
 int
-my_strcasecmp_mb_bin(const CHARSET_INFO *cs __attribute__((unused)),
+my_strcasecmp_mb_bin(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                      const char *s, const char *t)
 {
   return strcmp(s,t);
@@ -678,7 +678,7 @@ my_strcasecmp_mb_bin(const CHARSET_INFO *cs __attribute__((unused)),
 
 
 void
-my_hash_sort_mb_bin(const CHARSET_INFO *cs __attribute__((unused)),
+my_hash_sort_mb_bin(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                     const uchar *key, size_t len,ulong *nr1, ulong *nr2)
 {
   const uchar *pos = key;
--- a/strings/ctype-simple.c
+++ b/strings/ctype-simple.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2002, 2011, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2002, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -216,8 +216,8 @@ size_t my_casedn_str_8bit(const CHARSET_INFO *cs,char *str)
 
 
 size_t my_caseup_8bit(const CHARSET_INFO *cs, char *src, size_t srclen,
-                      char *dst __attribute__((unused)),
-                      size_t dstlen __attribute__((unused)))
+                      char *dst MY_ATTRIBUTE((unused)),
+                      size_t dstlen MY_ATTRIBUTE((unused)))
 {
   char *end= src + srclen;
   register uchar *map= cs->to_upper;
@@ -229,8 +229,8 @@ size_t my_caseup_8bit(const CHARSET_INFO *cs, char *src, size_t srclen,
 
 
 size_t my_casedn_8bit(const CHARSET_INFO *cs, char *src, size_t srclen,
-                      char *dst __attribute__((unused)),
-                      size_t dstlen __attribute__((unused)))
+                      char *dst MY_ATTRIBUTE((unused)),
+                      size_t dstlen MY_ATTRIBUTE((unused)))
 {
   char *end= src + srclen;
   register uchar *map=cs->to_lower;
@@ -251,7 +251,7 @@ int my_strcasecmp_8bit(const CHARSET_INFO *cs,const char *s, const char *t)
 
 int my_mb_wc_8bit(const CHARSET_INFO *cs,my_wc_t *wc,
 		  const uchar *str,
-		  const uchar *end __attribute__((unused)))
+		  const uchar *end MY_ATTRIBUTE((unused)))
 {
   if (str >= end)
     return MY_CS_TOOSMALL;
@@ -288,8 +288,8 @@ int my_wc_mb_8bit(const CHARSET_INFO *cs,my_wc_t wc,
    end buffer must be checked.
 */
 
-size_t my_snprintf_8bit(const CHARSET_INFO *cs  __attribute__((unused)),
-                        char* to, size_t n  __attribute__((unused)),
+size_t my_snprintf_8bit(const CHARSET_INFO *cs  MY_ATTRIBUTE((unused)),
+                        char* to, size_t n  MY_ATTRIBUTE((unused)),
 		     const char* fmt, ...)
 {
   va_list args;
@@ -506,7 +506,7 @@ noconv:
 }
 
 
-longlong my_strntoll_8bit(const CHARSET_INFO *cs __attribute__((unused)),
+longlong my_strntoll_8bit(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
 			  const char *nptr, size_t l, int base,
 			  char **endptr,int *err)
 {
@@ -714,7 +714,7 @@ noconv:
 */
 
 
-double my_strntod_8bit(const CHARSET_INFO *cs __attribute__((unused)),
+double my_strntod_8bit(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
 		       char *str, size_t length,
 		       char **end, int *err)
 {
@@ -731,7 +731,7 @@ double my_strntod_8bit(const CHARSET_INFO *cs __attribute__((unused)),
   Assume len >= 1
 */
 
-size_t my_long10_to_str_8bit(const CHARSET_INFO *cs __attribute__((unused)),
+size_t my_long10_to_str_8bit(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                              char *dst, size_t len, int radix, long int val)
 {
   char buffer[66];
@@ -773,7 +773,7 @@ size_t my_long10_to_str_8bit(const CHARSET_INFO *cs __attribute__((unused)),
 
 
 size_t my_longlong10_to_str_8bit(const CHARSET_INFO *cs
-                                 __attribute__((unused)),
+                                 MY_ATTRIBUTE((unused)),
                                  char *dst, size_t len, int radix,
                                  longlong val)
 {
@@ -1030,37 +1030,37 @@ size_t my_scan_8bit(const CHARSET_INFO *cs, const char *str, const char *end,
 }
 
 
-void my_fill_8bit(const CHARSET_INFO *cs __attribute__((unused)),
+void my_fill_8bit(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
 		   char *s, size_t l, int fill)
 {
   memset(s, fill, l);
 }
 
 
-size_t my_numchars_8bit(const CHARSET_INFO *cs __attribute__((unused)),
+size_t my_numchars_8bit(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
 		      const char *b, const char *e)
 {
   return (size_t) (e - b);
 }
 
 
-size_t my_numcells_8bit(const CHARSET_INFO *cs __attribute__((unused)),
+size_t my_numcells_8bit(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                         const char *b, const char *e)
 {
   return (size_t) (e - b);
 }
 
 
-size_t my_charpos_8bit(const CHARSET_INFO *cs __attribute__((unused)),
-                       const char *b  __attribute__((unused)),
-                       const char *e  __attribute__((unused)),
+size_t my_charpos_8bit(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
+                       const char *b  MY_ATTRIBUTE((unused)),
+                       const char *e  MY_ATTRIBUTE((unused)),
                        size_t pos)
 {
   return pos;
 }
 
 
-size_t my_well_formed_len_8bit(const CHARSET_INFO *cs __attribute__((unused)),
+size_t my_well_formed_len_8bit(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                                const char *start, const char *end,
                                size_t nchars, int *error)
 {
@@ -1070,7 +1070,7 @@ size_t my_well_formed_len_8bit(const CHARSET_INFO *cs __attribute__((unused)),
 }
 
 
-size_t my_lengthsp_8bit(const CHARSET_INFO *cs __attribute__((unused)),
+size_t my_lengthsp_8bit(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                         const char *ptr, size_t length)
 {
   const char *end;
@@ -1274,14 +1274,14 @@ static void set_max_sort_char(CHARSET_INFO *cs)
 
 static my_bool
 my_coll_init_simple(CHARSET_INFO *cs,
-                    MY_CHARSET_LOADER *loader __attribute__((unused)))
+                    MY_CHARSET_LOADER *loader MY_ATTRIBUTE((unused)))
 {
   set_max_sort_char(cs);
   return FALSE;
 }
 
 
-longlong my_strtoll10_8bit(const CHARSET_INFO *cs __attribute__((unused)),
+longlong my_strtoll10_8bit(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                            const char *nptr, char **endptr, int *error)
 {
   return my_strtoll10(nptr, endptr, error);
@@ -1387,7 +1387,7 @@ static ulonglong d10[DIGITS_IN_ULONGLONG]=
 */
 
 ulonglong
-my_strntoull10rnd_8bit(const CHARSET_INFO *cs __attribute__((unused)),
+my_strntoull10rnd_8bit(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                        const char *str, size_t length, int unsigned_flag,
                        char **endptr, int *error)
 {
@@ -1665,17 +1665,17 @@ ret_too_big:
 
 
 
-my_bool my_propagate_simple(const CHARSET_INFO *cs __attribute__((unused)),
-                            const uchar *str __attribute__((unused)),
-                            size_t length __attribute__((unused)))
+my_bool my_propagate_simple(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
+                            const uchar *str MY_ATTRIBUTE((unused)),
+                            size_t length MY_ATTRIBUTE((unused)))
 {
   return 1;
 }
 
 
-my_bool my_propagate_complex(const CHARSET_INFO *cs __attribute__((unused)),
-                             const uchar *str __attribute__((unused)),
-                             size_t length __attribute__((unused)))
+my_bool my_propagate_complex(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
+                             const uchar *str MY_ATTRIBUTE((unused)),
+                             size_t length MY_ATTRIBUTE((unused)))
 {
   return 0;
 }
--- a/strings/ctype-sjis.c
+++ b/strings/ctype-sjis.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -182,13 +182,13 @@ static uchar sort_order_sjis[]=
                        (0x80<=(c) && (c)<=0xfc))
 
 
-static uint ismbchar_sjis(const CHARSET_INFO *cs __attribute__((unused)),
+static uint ismbchar_sjis(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
 			 const char* p, const char *e)
 {
   return (issjishead((uchar) *p) && (e-p)>1 && issjistail((uchar)p[1]) ? 2: 0);
 }
 
-static uint mbcharlen_sjis(const CHARSET_INFO *cs __attribute__((unused)),
+static uint mbcharlen_sjis(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                            uint c)
 {
   return (issjishead((uchar) c) ? 2 : 1);
@@ -1112,7 +1112,7 @@ static int my_strnncoll_sjis_internal(const CHARSET_INFO *cs,
 }
 
 
-static int my_strnncoll_sjis(const CHARSET_INFO *cs __attribute__((unused)),
+static int my_strnncoll_sjis(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                              const uchar *a, size_t a_length, 
                              const uchar *b, size_t b_length,
                              my_bool b_is_prefix)
@@ -1124,7 +1124,7 @@ static int my_strnncoll_sjis(const CHARSET_INFO *cs __attribute__((unused)),
 }
 
 
-static int my_strnncollsp_sjis(const CHARSET_INFO *cs __attribute__((unused)),
+static int my_strnncollsp_sjis(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
 			       const uchar *a, size_t a_length, 
 			       const uchar *b, size_t b_length,
                                my_bool diff_if_only_endspace_difference)
@@ -33968,7 +33968,7 @@ static uint16 unicode_to_sjis[65536]=
   @retval   MY_CS_ILSEQ    If a wrong byte sequence was found
 */
 static int
-my_mb_wc_sjis(const CHARSET_INFO *cs  __attribute__((unused)),
+my_mb_wc_sjis(const CHARSET_INFO *cs  MY_ATTRIBUTE((unused)),
 	      my_wc_t *pwc, const uchar *s, const uchar *e){
   int hi;
 
@@ -34012,7 +34012,7 @@ my_mb_wc_sjis(const CHARSET_INFO *cs  __attribute__((unused)),
   @retval   MY_CS_ILUNI    If the Unicode character does not exist in SJIS
 */
 static int
-my_wc_mb_sjis(const CHARSET_INFO *cs __attribute__((unused)),
+my_wc_mb_sjis(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
 	      my_wc_t wc, uchar *s, uchar *e)
 {
   int code;
@@ -34061,7 +34061,7 @@ mb:
 
 
 static
-size_t my_numcells_sjis(const CHARSET_INFO *cs __attribute__((unused)),
+size_t my_numcells_sjis(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                       const char *str, const char *str_end)
 {
   size_t clen;
@@ -34094,7 +34094,7 @@ size_t my_numcells_sjis(const CHARSET_INFO *cs __attribute__((unused)),
   CP932 additional characters are also accepted.
 */
 static
-size_t my_well_formed_len_sjis(const CHARSET_INFO *cs __attribute__((unused)),
+size_t my_well_formed_len_sjis(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                                const char *b, const char *e,
                                size_t pos, int *error)
 {
--- a/strings/ctype-tis620.c
+++ b/strings/ctype-tis620.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -526,7 +526,7 @@ static size_t thai2sortable(uchar *tstr, size_t len)
 */
 
 static
-int my_strnncoll_tis620(const CHARSET_INFO *cs __attribute__((unused)),
+int my_strnncoll_tis620(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                         const uchar *s1, size_t len1, 
                         const uchar *s2, size_t len2,
                         my_bool s2_is_prefix)
@@ -556,7 +556,7 @@ int my_strnncoll_tis620(const CHARSET_INFO *cs __attribute__((unused)),
 
 
 static
-int my_strnncollsp_tis620(const CHARSET_INFO * cs __attribute__((unused)),
+int my_strnncollsp_tis620(const CHARSET_INFO * cs MY_ATTRIBUTE((unused)),
 			  const uchar *a0, size_t a_length, 
 			  const uchar *b0, size_t b_length,
                           my_bool diff_if_only_endspace_difference)
@@ -841,10 +841,10 @@ NULL,NULL,NULL,NULL,NULL,NULL,NULL,plFF
 
 
 static
-int my_mb_wc_tis620(const CHARSET_INFO *cs  __attribute__((unused)),
+int my_mb_wc_tis620(const CHARSET_INFO *cs  MY_ATTRIBUTE((unused)),
 		  my_wc_t *wc,
 		  const uchar *str,
-		  const uchar *end __attribute__((unused)))
+		  const uchar *end MY_ATTRIBUTE((unused)))
 {
   if (str >= end)
     return MY_CS_TOOSMALL;
@@ -854,10 +854,10 @@ int my_mb_wc_tis620(const CHARSET_INFO *cs  __attribute__((unused)),
 }
 
 static
-int my_wc_mb_tis620(const CHARSET_INFO *cs  __attribute__((unused)),
+int my_wc_mb_tis620(const CHARSET_INFO *cs  MY_ATTRIBUTE((unused)),
 		  my_wc_t wc,
 		  uchar *str,
-		  uchar *end __attribute__((unused)))
+		  uchar *end MY_ATTRIBUTE((unused)))
 {
   uchar *pl;
   
--- a/strings/ctype-ucs2.c
+++ b/strings/ctype-ucs2.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2003, 2015, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2003, 2016, Oracle and/or its affiliates. All rights reserved.
    
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
@@ -64,8 +64,8 @@ my_bincmp(const uchar *s, const uchar *se,
 
 
 static size_t
-my_caseup_str_mb2_or_mb4(const CHARSET_INFO * cs  __attribute__((unused)), 
-                         char * s __attribute__((unused)))
+my_caseup_str_mb2_or_mb4(const CHARSET_INFO * cs  MY_ATTRIBUTE((unused)), 
+                         char * s MY_ATTRIBUTE((unused)))
 {
   DBUG_ASSERT(0);
   return 0;
@@ -73,8 +73,8 @@ my_caseup_str_mb2_or_mb4(const CHARSET_INFO * cs  __attribute__((unused)),
 
 
 static size_t
-my_casedn_str_mb2_or_mb4(const CHARSET_INFO *cs __attribute__((unused)), 
-                         char * s __attribute__((unused)))
+my_casedn_str_mb2_or_mb4(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)), 
+                         char * s MY_ATTRIBUTE((unused)))
 {
   DBUG_ASSERT(0);
   return 0;
@@ -82,9 +82,9 @@ my_casedn_str_mb2_or_mb4(const CHARSET_INFO *cs __attribute__((unused)),
 
 
 static int
-my_strcasecmp_mb2_or_mb4(const CHARSET_INFO *cs __attribute__((unused)),
-                         const char *s __attribute__((unused)),
-                         const char *t __attribute__((unused)))
+my_strcasecmp_mb2_or_mb4(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
+                         const char *s MY_ATTRIBUTE((unused)),
+                         const char *t MY_ATTRIBUTE((unused)))
 {
   DBUG_ASSERT(0);
   return 0;
@@ -1047,7 +1047,7 @@ my_vsnprintf_mb2(char *dst, size_t n, const char* fmt, va_list ap)
 
 
 static size_t
-my_snprintf_mb2(const CHARSET_INFO *cs __attribute__((unused)),
+my_snprintf_mb2(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                 char* to, size_t n, const char* fmt, ...)
 {
   size_t retval;
@@ -1060,7 +1060,7 @@ my_snprintf_mb2(const CHARSET_INFO *cs __attribute__((unused)),
 
 
 static size_t
-my_lengthsp_mb2(const CHARSET_INFO *cs __attribute__((unused)),
+my_lengthsp_mb2(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                 const char *ptr, size_t length)
 {
   const char *end= ptr + length;
@@ -1102,7 +1102,7 @@ my_lengthsp_mb2(const CHARSET_INFO *cs __attribute__((unused)),
                                   ((c & 3) << 8) + d + 0x10000)
 
 static int
-my_utf16_uni(const CHARSET_INFO *cs __attribute__((unused)),
+my_utf16_uni(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
              my_wc_t *pwc, const uchar *s, const uchar *e)
 {
   if (s + 2 > e)
@@ -1135,7 +1135,7 @@ my_utf16_uni(const CHARSET_INFO *cs __attribute__((unused)),
 
 
 static int
-my_uni_utf16(const CHARSET_INFO *cs __attribute__((unused)),
+my_uni_utf16(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
              my_wc_t wc, uchar *s, uchar *e)
 {
   if (wc <= 0xFFFF)
@@ -1201,8 +1201,8 @@ my_tosort_utf16(MY_UNICASE_INFO *uni_plane, my_wc_t *wc)
 
 static size_t
 my_caseup_utf16(const CHARSET_INFO *cs, char *src, size_t srclen,
-                char *dst __attribute__((unused)),
-                size_t dstlen __attribute__((unused)))
+                char *dst MY_ATTRIBUTE((unused)),
+                size_t dstlen MY_ATTRIBUTE((unused)))
 {
   my_wc_t wc;
   int res;
@@ -1246,8 +1246,8 @@ my_hash_sort_utf16(const CHARSET_INFO *cs, const uchar *s, size_t slen,
 
 static size_t
 my_casedn_utf16(const CHARSET_INFO *cs, char *src, size_t srclen,
-                char *dst __attribute__((unused)),
-                size_t dstlen __attribute__((unused)))
+                char *dst MY_ATTRIBUTE((unused)),
+                size_t dstlen MY_ATTRIBUTE((unused)))
 {
   my_wc_t wc;
   int res;
@@ -1415,8 +1415,8 @@ my_ismbchar_utf16(const CHARSET_INFO *cs, const char *b, const char *e)
 
 
 static uint
-my_mbcharlen_utf16(const CHARSET_INFO *cs  __attribute__((unused)),
-                   uint c __attribute__((unused)))
+my_mbcharlen_utf16(const CHARSET_INFO *cs  MY_ATTRIBUTE((unused)),
+                   uint c MY_ATTRIBUTE((unused)))
 {
   DBUG_ASSERT(0);
   return MY_UTF16_HIGH_HEAD(c) ? 4 : 2;
@@ -1749,7 +1749,7 @@ CHARSET_INFO my_charset_utf16_bin=
 
 
 static int
-my_utf16le_uni(const CHARSET_INFO *cs __attribute__((unused)),
+my_utf16le_uni(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                my_wc_t *pwc, const uchar *s, const uchar *e)
 {
   my_wc_t lo;
@@ -1779,7 +1779,7 @@ my_utf16le_uni(const CHARSET_INFO *cs __attribute__((unused)),
 
 
 static int
-my_uni_utf16le(const CHARSET_INFO *cs __attribute__((unused)),
+my_uni_utf16le(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                my_wc_t wc, uchar *s, uchar *e)
 {
   if (wc < MY_UTF16_SURROGATE_HIGH_FIRST ||
@@ -1806,7 +1806,7 @@ my_uni_utf16le(const CHARSET_INFO *cs __attribute__((unused)),
 
 
 static size_t
-my_lengthsp_utf16le(const CHARSET_INFO *cs __attribute__((unused)),
+my_lengthsp_utf16le(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                     const char *ptr, size_t length)
 {
   const char *end= ptr + length;
@@ -1922,7 +1922,7 @@ CHARSET_INFO my_charset_utf16le_bin=
 #ifdef HAVE_CHARSET_utf32
 
 static int
-my_utf32_uni(const CHARSET_INFO *cs __attribute__((unused)),
+my_utf32_uni(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
              my_wc_t *pwc, const uchar *s, const uchar *e)
 {
   if (s + 4 > e)
@@ -1933,7 +1933,7 @@ my_utf32_uni(const CHARSET_INFO *cs __attribute__((unused)),
 
 
 static int
-my_uni_utf32(const CHARSET_INFO *cs __attribute__((unused)),
+my_uni_utf32(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
              my_wc_t wc, uchar *s, uchar *e)
 {
   if (s + 4 > e) 
@@ -1983,8 +1983,8 @@ my_tosort_utf32(MY_UNICASE_INFO *uni_plane, my_wc_t *wc)
 
 static size_t
 my_caseup_utf32(const CHARSET_INFO *cs, char *src, size_t srclen,
-                char *dst __attribute__((unused)),
-                size_t dstlen __attribute__((unused)))
+                char *dst MY_ATTRIBUTE((unused)),
+                size_t dstlen MY_ATTRIBUTE((unused)))
 {
   my_wc_t wc;
   int res;
@@ -2039,8 +2039,8 @@ my_hash_sort_utf32(const CHARSET_INFO *cs, const uchar *s, size_t slen,
 
 static size_t
 my_casedn_utf32(const CHARSET_INFO *cs, char *src, size_t srclen,
-                char *dst __attribute__((unused)),
-                size_t dstlen __attribute__((unused)))
+                char *dst MY_ATTRIBUTE((unused)),
+                size_t dstlen MY_ATTRIBUTE((unused)))
 {
   my_wc_t wc;
   int res;
@@ -2198,7 +2198,7 @@ my_strnncollsp_utf32(const CHARSET_INFO *cs,
 
 
 static size_t
-my_strnxfrmlen_utf32(const CHARSET_INFO *cs __attribute__((unused)),
+my_strnxfrmlen_utf32(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                      size_t len)
 {
   return len / 2;
@@ -2206,17 +2206,17 @@ my_strnxfrmlen_utf32(const CHARSET_INFO *cs __attribute__((unused)),
 
 
 static uint
-my_ismbchar_utf32(const CHARSET_INFO *cs __attribute__((unused)),
-                  const char *b __attribute__((unused)),
-                  const char *e __attribute__((unused)))
+my_ismbchar_utf32(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
+                  const char *b MY_ATTRIBUTE((unused)),
+                  const char *e MY_ATTRIBUTE((unused)))
 {
   return 4;
 }
 
 
 static uint
-my_mbcharlen_utf32(const CHARSET_INFO *cs  __attribute__((unused)) , 
-                   uint c __attribute__((unused)))
+my_mbcharlen_utf32(const CHARSET_INFO *cs  MY_ATTRIBUTE((unused)) , 
+                   uint c MY_ATTRIBUTE((unused)))
 {
   return 4;
 }
@@ -2312,7 +2312,7 @@ my_vsnprintf_utf32(char *dst, size_t n, const char* fmt, va_list ap)
 
 
 static size_t
-my_snprintf_utf32(const CHARSET_INFO *cs __attribute__((unused)),
+my_snprintf_utf32(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                   char* to, size_t n, const char* fmt, ...)
 {
   size_t retval;
@@ -2325,7 +2325,7 @@ my_snprintf_utf32(const CHARSET_INFO *cs __attribute__((unused)),
 
 
 static longlong
-my_strtoll10_utf32(const CHARSET_INFO *cs __attribute__((unused)),
+my_strtoll10_utf32(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                    const char *nptr, char **endptr, int *error)
 {
   const char *s, *end, *start, *n_end, *true_end;
@@ -2495,7 +2495,7 @@ no_conv:
 
 
 static size_t
-my_numchars_utf32(const CHARSET_INFO *cs __attribute__((unused)),
+my_numchars_utf32(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                   const char *b, const char *e)
 {
   return (size_t) (e - b) / 4;
@@ -2503,7 +2503,7 @@ my_numchars_utf32(const CHARSET_INFO *cs __attribute__((unused)),
 
 
 static size_t
-my_charpos_utf32(const CHARSET_INFO *cs __attribute__((unused)),
+my_charpos_utf32(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                  const char *b, const char *e, size_t pos)
 {
   size_t string_length= (size_t) (e - b);
@@ -2512,7 +2512,7 @@ my_charpos_utf32(const CHARSET_INFO *cs __attribute__((unused)),
 
 
 static size_t
-my_well_formed_len_utf32(const CHARSET_INFO *cs __attribute__((unused)),
+my_well_formed_len_utf32(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                          const char *b, const char *e,
                          size_t nchars, int *error)
 {
@@ -2565,7 +2565,7 @@ void my_fill_utf32(const CHARSET_INFO *cs,
 
 
 static size_t
-my_lengthsp_utf32(const CHARSET_INFO *cs __attribute__((unused)),
+my_lengthsp_utf32(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                   const char *ptr, size_t length)
 {
   const char *end= ptr + length;
@@ -2643,11 +2643,11 @@ my_utf32_get(const uchar *s)
 
 
 static int
-my_strnncollsp_utf32_bin(const CHARSET_INFO *cs __attribute__((unused)), 
+my_strnncollsp_utf32_bin(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)), 
                          const uchar *s, size_t slen, 
                          const uchar *t, size_t tlen,
                          my_bool diff_if_only_endspace_difference
-                         __attribute__((unused)))
+                         MY_ATTRIBUTE((unused)))
 {
   const uchar *se, *te;
   size_t minlen;
@@ -2910,7 +2910,7 @@ static uchar to_upper_ucs2[] = {
 };
 
 
-static int my_ucs2_uni(const CHARSET_INFO *cs __attribute__((unused)),
+static int my_ucs2_uni(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
 		       my_wc_t * pwc, const uchar *s, const uchar *e)
 {
   if (s+2 > e) /* Need 2 characters */
@@ -2920,7 +2920,7 @@ static int my_ucs2_uni(const CHARSET_INFO *cs __attribute__((unused)),
   return 2;
 }
 
-static int my_uni_ucs2(const CHARSET_INFO *cs __attribute__((unused)) ,
+static int my_uni_ucs2(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)) ,
 		       my_wc_t wc, uchar *r, uchar *e)
 {
   if ( r+2 > e ) 
@@ -2963,8 +2963,8 @@ my_tosort_ucs2(MY_UNICASE_INFO *uni_plane, my_wc_t *wc)
 
 
 static size_t my_caseup_ucs2(const CHARSET_INFO *cs, char *src, size_t srclen,
-                           char *dst __attribute__((unused)),
-                           size_t dstlen __attribute__((unused)))
+                           char *dst MY_ATTRIBUTE((unused)),
+                           size_t dstlen MY_ATTRIBUTE((unused)))
 {
   my_wc_t wc;
   int res;
@@ -3008,8 +3008,8 @@ static void my_hash_sort_ucs2(const CHARSET_INFO *cs, const uchar *s,
 
 
 static size_t my_casedn_ucs2(const CHARSET_INFO *cs, char *src, size_t srclen,
-                           char *dst __attribute__((unused)),
-                           size_t dstlen __attribute__((unused)))
+                           char *dst MY_ATTRIBUTE((unused)),
+                           size_t dstlen MY_ATTRIBUTE((unused)))
 {
   my_wc_t wc;
   int res;
@@ -3030,7 +3030,7 @@ static size_t my_casedn_ucs2(const CHARSET_INFO *cs, char *src, size_t srclen,
 
 
 static void
-my_fill_ucs2(const CHARSET_INFO *cs __attribute__((unused)), 
+my_fill_ucs2(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)), 
              char *s, size_t l, int fill)
 {
   DBUG_ASSERT(fill <= 0xFFFF);
@@ -3101,11 +3101,11 @@ static int my_strnncoll_ucs2(const CHARSET_INFO *cs,
     > 0  a > b
 */
 
-static int my_strnncollsp_ucs2(const CHARSET_INFO *cs __attribute__((unused)),
+static int my_strnncollsp_ucs2(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                                const uchar *s, size_t slen,
                                const uchar *t, size_t tlen,
                                my_bool diff_if_only_endspace_difference
-			       __attribute__((unused)))
+			       MY_ATTRIBUTE((unused)))
 {
   const uchar *se, *te;
   size_t minlen;
@@ -3152,23 +3152,23 @@ static int my_strnncollsp_ucs2(const CHARSET_INFO *cs __attribute__((unused)),
 }
 
 
-static uint my_ismbchar_ucs2(const CHARSET_INFO *cs __attribute__((unused)),
-                             const char *b __attribute__((unused)),
-                             const char *e __attribute__((unused)))
+static uint my_ismbchar_ucs2(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
+                             const char *b MY_ATTRIBUTE((unused)),
+                             const char *e MY_ATTRIBUTE((unused)))
 {
   return 2;
 }
 
 
-static uint my_mbcharlen_ucs2(const CHARSET_INFO *cs __attribute__((unused)) ,
-                              uint c __attribute__((unused)))
+static uint my_mbcharlen_ucs2(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)) ,
+                              uint c MY_ATTRIBUTE((unused)))
 {
   return 2;
 }
 
 
 static
-size_t my_numchars_ucs2(const CHARSET_INFO *cs __attribute__((unused)),
+size_t my_numchars_ucs2(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                         const char *b, const char *e)
 {
   return (size_t) (e-b)/2;
@@ -3176,9 +3176,9 @@ size_t my_numchars_ucs2(const CHARSET_INFO *cs __attribute__((unused)),
 
 
 static
-size_t my_charpos_ucs2(const CHARSET_INFO *cs __attribute__((unused)),
-                       const char *b  __attribute__((unused)),
-                       const char *e  __attribute__((unused)),
+size_t my_charpos_ucs2(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
+                       const char *b  MY_ATTRIBUTE((unused)),
+                       const char *e  MY_ATTRIBUTE((unused)),
                        size_t pos)
 {
   size_t string_length= (size_t) (e - b);
@@ -3187,7 +3187,7 @@ size_t my_charpos_ucs2(const CHARSET_INFO *cs __attribute__((unused)),
 
 
 static
-size_t my_well_formed_len_ucs2(const CHARSET_INFO *cs __attribute__((unused)),
+size_t my_well_formed_len_ucs2(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                                const char *b, const char *e,
                                size_t nchars, int *error)
 {
@@ -3255,11 +3255,11 @@ int my_strnncoll_ucs2_bin(const CHARSET_INFO *cs,
 }
 
 static int my_strnncollsp_ucs2_bin(const CHARSET_INFO *cs
-                                   __attribute__((unused)),
+                                   MY_ATTRIBUTE((unused)),
                                    const uchar *s, size_t slen, 
                                    const uchar *t, size_t tlen,
                                    my_bool diff_if_only_endspace_difference
-                                   __attribute__((unused)))
+                                   MY_ATTRIBUTE((unused)))
 {
   const uchar *se, *te;
   size_t minlen;
@@ -3303,7 +3303,7 @@ static int my_strnncollsp_ucs2_bin(const CHARSET_INFO *cs
 
 
 static
-void my_hash_sort_ucs2_bin(const CHARSET_INFO *cs __attribute__((unused)),
+void my_hash_sort_ucs2_bin(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
 			   const uchar *key, size_t len,ulong *nr1, ulong *nr2)
 {
   const uchar *pos = key;
--- a/strings/ctype-ujis.c
+++ b/strings/ctype-ujis.c
@@ -1,5 +1,5 @@
 /* Copyright (c) 2002 MySQL AB & tommy@valley.ne.jp
-   Copyright (c) 2002, 2014, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2002, 2016, Oracle and/or its affiliates. All rights reserved.
    
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
@@ -184,7 +184,7 @@ static uchar sort_order_ujis[]=
 #define isujis_ss3(c) (((c)&0xff) == 0x8f)
 
 
-static uint ismbchar_ujis(const CHARSET_INFO *cs __attribute__((unused)),
+static uint ismbchar_ujis(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
 		  const char* p, const char *e)
 {
   return ((*(uchar*)(p)<0x80)? 0:\
@@ -194,7 +194,7 @@ static uint ismbchar_ujis(const CHARSET_INFO *cs __attribute__((unused)),
     0);
 }
 
-static uint mbcharlen_ujis(const CHARSET_INFO *cs __attribute__((unused)),
+static uint mbcharlen_ujis(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                            uint c)
 {
   return (isujis(c)? 2: isujis_ss2(c)? 2: isujis_ss3(c)? 3: 1);
@@ -210,7 +210,7 @@ static uint mbcharlen_ujis(const CHARSET_INFO *cs __attribute__((unused)),
 */
 
 static
-size_t my_well_formed_len_ujis(const CHARSET_INFO *cs __attribute__((unused)),
+size_t my_well_formed_len_ujis(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                                const char *beg, const char *end,
                                size_t pos, int *error)
 {
@@ -260,7 +260,7 @@ size_t my_well_formed_len_ujis(const CHARSET_INFO *cs __attribute__((unused)),
 
 
 static
-size_t my_numcells_eucjp(const CHARSET_INFO *cs __attribute__((unused)),
+size_t my_numcells_eucjp(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                        const char *str, const char *str_end)
 {
   size_t clen;
@@ -65880,7 +65880,7 @@ static uint16 unicode_to_jisx0212_eucjp[65536]=
   @retval   MY_CS_ILSEQ    If a wrong byte sequence was found
 */
 static int
-my_mb_wc_euc_jp(const CHARSET_INFO *cs __attribute__((unused)),
+my_mb_wc_euc_jp(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                 my_wc_t *pwc, const uchar *s, const uchar *e)
 {
   int hi;
@@ -65940,7 +65940,7 @@ my_mb_wc_euc_jp(const CHARSET_INFO *cs __attribute__((unused)),
   @retval   MY_CS_ILUNI    If the Unicode character does not exist in UJIS
 */
 static int
-my_wc_mb_euc_jp(const CHARSET_INFO *cs __attribute__((unused)),
+my_wc_mb_euc_jp(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                 my_wc_t wc, uchar *s, uchar *e)
 {
   int jp;
@@ -67181,7 +67181,7 @@ get_case_info_for_ch(const CHARSET_INFO *cs, uint plane, uint page, uint offs)
 static size_t
 my_casefold_ujis(const CHARSET_INFO *cs,
                  char *src, size_t srclen,
-                 char *dst, size_t dstlen __attribute__((unused)),
+                 char *dst, size_t dstlen MY_ATTRIBUTE((unused)),
                  uchar *map,
                  size_t is_upper)
 {
--- a/strings/ctype-utf8.c
+++ b/strings/ctype-utf8.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
@@ -5327,7 +5327,7 @@ static inline int bincmp(const uchar *s, const uchar *se,
 }
 
 
-static int my_utf8_uni(const CHARSET_INFO *cs __attribute__((unused)),
+static int my_utf8_uni(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                        my_wc_t * pwc, const uchar *s, const uchar *e)
 {
   uchar c;
@@ -5438,7 +5438,7 @@ static int my_utf8_uni(const CHARSET_INFO *cs __attribute__((unused)),
   for example, for a null-terminated string
 */
 static int my_utf8_uni_no_range(const CHARSET_INFO *cs
-                                __attribute__((unused)),
+                                MY_ATTRIBUTE((unused)),
                                 my_wc_t * pwc, const uchar *s)
 {
   uchar c;
@@ -5479,7 +5479,7 @@ static int my_utf8_uni_no_range(const CHARSET_INFO *cs
 }
 
 
-static int my_uni_utf8 (const CHARSET_INFO *cs __attribute__((unused)),
+static int my_uni_utf8 (const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                         my_wc_t wc, uchar *r, uchar *e)
 {
   int count;
@@ -5529,7 +5529,7 @@ static int my_uni_utf8 (const CHARSET_INFO *cs __attribute__((unused)),
   The same as above, but without range check.
 */
 static int my_uni_utf8_no_range(const CHARSET_INFO *cs
-                                __attribute__((unused)),
+                                MY_ATTRIBUTE((unused)),
                                 my_wc_t wc, uchar *r)
 {
   int count;
@@ -5955,7 +5955,7 @@ int my_wildcmp_utf8(const CHARSET_INFO *cs,
 
 
 static
-size_t my_strnxfrmlen_utf8(const CHARSET_INFO *cs __attribute__((unused)),
+size_t my_strnxfrmlen_utf8(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                            size_t len)
 {
   return (len * 2 + 2) / 3;
@@ -5963,7 +5963,7 @@ size_t my_strnxfrmlen_utf8(const CHARSET_INFO *cs __attribute__((unused)),
 
 
 static
-int my_valid_mbcharlen_utf8(const CHARSET_INFO *cs __attribute__((unused)),
+int my_valid_mbcharlen_utf8(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                             const uchar *s, const uchar *e)
 {
   uchar c;
@@ -6050,7 +6050,7 @@ static uint my_ismbchar_utf8(const CHARSET_INFO *cs,const char *b,
   return (res>1) ? res : 0;
 }
 
-static uint my_mbcharlen_utf8(const CHARSET_INFO *cs  __attribute__((unused)),
+static uint my_mbcharlen_utf8(const CHARSET_INFO *cs  MY_ATTRIBUTE((unused)),
                               uint c)
 {
   if (c < 0x80)
@@ -7575,7 +7575,7 @@ static char filename_safe_char[128]=
 #define MY_FILENAME_ESCAPE '@'
 
 static int
-my_mb_wc_filename(const CHARSET_INFO *cs __attribute__((unused)),
+my_mb_wc_filename(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                   my_wc_t *pwc, const uchar *s, const uchar *e)
 {
   int byte1, byte2;
@@ -7635,7 +7635,7 @@ my_mb_wc_filename(const CHARSET_INFO *cs __attribute__((unused)),
 
 
 static int
-my_wc_mb_filename(const CHARSET_INFO *cs __attribute__((unused)),
+my_wc_mb_filename(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                   my_wc_t wc, uchar *s, uchar *e)
 {
   int code;
@@ -7898,7 +7898,7 @@ bincmp_utf8mb4(const uchar *s, const uchar *se,
 
 
 static int
-my_mb_wc_utf8mb4(const CHARSET_INFO *cs __attribute__((unused)),
+my_mb_wc_utf8mb4(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                  my_wc_t * pwc, const uchar *s, const uchar *e)
 {
   uchar c;
@@ -7984,7 +7984,7 @@ my_mb_wc_utf8mb4(const CHARSET_INFO *cs __attribute__((unused)),
   for example, for a null-terminated string
 */
 static int
-my_mb_wc_utf8mb4_no_range(const CHARSET_INFO *cs __attribute__((unused)),
+my_mb_wc_utf8mb4_no_range(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                           my_wc_t *pwc, const uchar *s)
 {
   uchar c;
@@ -8039,7 +8039,7 @@ my_mb_wc_utf8mb4_no_range(const CHARSET_INFO *cs __attribute__((unused)),
 
 
 static int
-my_wc_mb_utf8mb4(const CHARSET_INFO *cs __attribute__((unused)),
+my_wc_mb_utf8mb4(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                  my_wc_t wc, uchar *r, uchar *e)
 {
   int count;
@@ -8075,7 +8075,7 @@ my_wc_mb_utf8mb4(const CHARSET_INFO *cs __attribute__((unused)),
   The same as above, but without range check.
 */
 static int
-my_wc_mb_utf8mb4_no_range(const CHARSET_INFO *cs __attribute__((unused)),
+my_wc_mb_utf8mb4_no_range(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                           my_wc_t wc, uchar *r)
 {
   int count;
@@ -8514,7 +8514,7 @@ my_wildcmp_utf8mb4(const CHARSET_INFO *cs,
 
 
 static size_t
-my_strnxfrmlen_utf8mb4(const CHARSET_INFO *cs __attribute__((unused)),
+my_strnxfrmlen_utf8mb4(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                        size_t len)
 {
   /* TODO: fix when working on WL "Unicode new version" */
@@ -8523,7 +8523,7 @@ my_strnxfrmlen_utf8mb4(const CHARSET_INFO *cs __attribute__((unused)),
 
 
 static int
-my_valid_mbcharlen_utf8mb4(const CHARSET_INFO *cs __attribute__((unused)),
+my_valid_mbcharlen_utf8mb4(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
                            const uchar *s, const uchar *e)
 {
   uchar c;
@@ -8605,7 +8605,7 @@ my_ismbchar_utf8mb4(const CHARSET_INFO *cs, const char *b, const char *e)
 
 
 static uint
-my_mbcharlen_utf8mb4(const CHARSET_INFO *cs __attribute__((unused)), uint c)
+my_mbcharlen_utf8mb4(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)), uint c)
 {
   if (c < 0x80)
     return 1;
--- a/strings/ctype-win1250ch.c
+++ b/strings/ctype-win1250ch.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2002, 2013, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2002, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -436,7 +436,7 @@ static struct wordvalue doubles[] = {
 #define IS_END(p, src, len)	(((char *)p - (char *)src) >= (len))
 
 static int my_strnncoll_win1250ch(const CHARSET_INFO *cs
-                                  __attribute__((unused)),
+                                  MY_ATTRIBUTE((unused)),
 				  const uchar *s1, size_t len1,
                                   const uchar *s2, size_t len2,
                                   my_bool s2_is_prefix)
@@ -471,7 +471,7 @@ int my_strnncollsp_win1250ch(const CHARSET_INFO *cs,
 			     const uchar *s, size_t slen, 
 			     const uchar *t, size_t tlen,
                              my_bool diff_if_only_endspace_difference
-                             __attribute__((unused)))
+                             MY_ATTRIBUTE((unused)))
 {
   for ( ; slen && s[slen-1] == ' ' ; slen--);
   for ( ; tlen && t[tlen-1] == ' ' ; tlen--);
@@ -480,9 +480,9 @@ int my_strnncollsp_win1250ch(const CHARSET_INFO *cs,
 
 
 static size_t
-my_strnxfrm_win1250ch(const CHARSET_INFO *cs  __attribute__((unused)),
+my_strnxfrm_win1250ch(const CHARSET_INFO *cs  MY_ATTRIBUTE((unused)),
                       uchar *dest, size_t len,
-                      uint nweights_arg __attribute__((unused)),
+                      uint nweights_arg MY_ATTRIBUTE((unused)),
                       const uchar *src, size_t srclen, uint flags)
 {
   int value;
@@ -614,7 +614,7 @@ static uchar like_range_prefix_max_win1250ch[]=
 */
 
 static my_bool
-my_like_range_win1250ch(const CHARSET_INFO *cs __attribute__((unused)),
+my_like_range_win1250ch(const CHARSET_INFO *cs MY_ATTRIBUTE((unused)),
 			const char *ptr, size_t ptr_length,
 			pbool escape, pbool w_one, pbool w_many,
 			size_t res_length,
--- a/tests/mysql_client_fw.c
+++ b/tests/mysql_client_fw.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2002, 2014, Oracle and/or its affiliates. All rights
+/* Copyright (c) 2002, 2016, Oracle and/or its affiliates. All rights
  * reserved.
 
    This program is free software; you can redistribute it and/or modify
@@ -1265,7 +1265,7 @@ static struct my_tests_st *get_my_tests();  /* To be defined in main .c file */
 static struct my_tests_st *my_testlist= 0;
 
 static my_bool
-get_one_option(int optid, const struct my_option *opt __attribute__((unused)),
+get_one_option(int optid, const struct my_option *opt MY_ATTRIBUTE((unused)),
 char *argument)
 {
  switch (optid) {
--- a/tests/thread_test.c
+++ b/tests/thread_test.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -29,9 +29,9 @@ static char *database,*host,*user,*password,*unix_socket,*query;
 uint tcp_port;
 
 #ifndef __WIN__
-void *test_thread(void *arg __attribute__((unused)))
+void *test_thread(void *arg MY_ATTRIBUTE((unused)))
 #else
-unsigned __stdcall test_thread(void *arg __attribute__((unused)))
+unsigned __stdcall test_thread(void *arg MY_ATTRIBUTE((unused)))
 #endif
 {
   MYSQL *mysql;
@@ -134,7 +134,7 @@ static void usage()
 
 
 static my_bool
-get_one_option(int optid, const struct my_option *opt __attribute__((unused)),
+get_one_option(int optid, const struct my_option *opt MY_ATTRIBUTE((unused)),
 	       char *argument)
 {
   switch (optid) {
--- a/unittest/gunit/rpl_group_set-t.cc
+++ b/unittest/gunit/rpl_group_set-t.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -472,9 +472,9 @@ TEST_F(GroupTest, Group_containers)
   push_errtext();                                                       \
   for (int method_i= 0, combination_i= 0; method_i < MAX_METHOD; method_i++) { \
     for (int sid_map_i= 0; sid_map_i < MAX_SID_MAP; sid_map_i++, combination_i++) { \
-      Gtid_set &gtid_set __attribute__((unused))=                       \
+      Gtid_set &gtid_set MY_ATTRIBUTE((unused))=                       \
         containers[combination_i]->gtid_set;                            \
-      Sid_map *&sid_map __attribute__((unused))=                        \
+      Sid_map *&sid_map MY_ATTRIBUTE((unused))=                        \
         sid_maps[sid_map_i];                                            \
       append_errtext(__LINE__,                                          \
                      "sid_map_i=%d method_i=%d combination_i=%d",       \
@@ -489,13 +489,13 @@ TEST_F(GroupTest, Group_containers)
     for (int end_i= 0; end_i < MAX_END; end_i++) {                      \
       for (int empty_i= 0; empty_i < MAX_EMPTY; empty_i++) {            \
         for (int anon_i= 0; anon_i < MAX_ANON; anon_i++, combination_i++) { \
-          Gtid_set &gtid_set __attribute__((unused))=                   \
+          Gtid_set &gtid_set MY_ATTRIBUTE((unused))=                   \
             containers[combination_i]->gtid_set;                        \
-          Group_cache &stmt_cache __attribute__((unused))=              \
+          Group_cache &stmt_cache MY_ATTRIBUTE((unused))=              \
             containers[combination_i]->stmt_cache;                      \
-          Group_cache &trx_cache __attribute__((unused))=               \
+          Group_cache &trx_cache MY_ATTRIBUTE((unused))=               \
             containers[combination_i]->trx_cache;                       \
-          Group_log_state &group_log_state __attribute__((unused))=     \
+          Group_log_state &group_log_state MY_ATTRIBUTE((unused))=     \
             containers[combination_i]->group_log_state;                 \
           append_errtext(__LINE__,                                      \
                          "type_i=%d end_i=%d empty_i=%d "               \
--- a/unittest/mytap/tap.h
+++ b/unittest/mytap/tap.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2006, 2010, Oracle and/or its affiliates. All rights reserved. 
+/* Copyright (c) 2006, 2016, Oracle and/or its affiliates. All rights reserved. 
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -126,7 +126,7 @@ void plan(int const count);
 */
 
 void ok(int const pass, char const *fmt, ...)
-  __attribute__((format(printf,2,3)));
+  MY_ATTRIBUTE((format(printf,2,3)));
 
 
 /**
@@ -169,7 +169,7 @@ void ok1(int const pass);
  */
 
 void skip(int how_many, char const *reason, ...)
-    __attribute__((format(printf,2,3)));
+    MY_ATTRIBUTE((format(printf,2,3)));
 
 
 /**
@@ -218,7 +218,7 @@ void skip(int how_many, char const *reason, ...)
  */
 
 void diag(char const *fmt, ...)
-  __attribute__((format(printf,1,2)));
+  MY_ATTRIBUTE((format(printf,1,2)));
 
 
 /**
@@ -240,7 +240,7 @@ void diag(char const *fmt, ...)
 */
 
 void BAIL_OUT(char const *fmt, ...)
-  __attribute__((noreturn, format(printf,1,2)));
+  MY_ATTRIBUTE((noreturn, format(printf,1,2)));
 
 
 /**
@@ -271,7 +271,7 @@ int exit_status(void);
  */
 
 void skip_all(char const *reason, ...)
-  __attribute__((noreturn, format(printf, 1, 2)));
+  MY_ATTRIBUTE((noreturn, format(printf, 1, 2)));
 
 
 /**
@@ -296,7 +296,7 @@ void skip_all(char const *reason, ...)
 */
 
 void todo_start(char const *message, ...)
-  __attribute__((format(printf, 1, 2)));
+  MY_ATTRIBUTE((format(printf, 1, 2)));
 
 
 /**
--- a/vio/test-sslclient.c
+++ b/vio/test-sslclient.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -40,7 +40,7 @@ fatal_error(	const char*	r)
 }
 
 int
-main(	int	argc __attribute__((unused)),
+main(	int	argc MY_ATTRIBUTE((unused)),
 	char**	argv)
 {
 	char	client_key[] = "../SSL/client-key.pem",	client_cert[] = "../SSL/client-cert.pem";
--- a/vio/test-sslserver.c
+++ b/vio/test-sslserver.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -75,7 +75,7 @@ client_thread(	void*	arg)
 }
 
 int
-main(int argc __attribute__((unused)), char** argv)
+main(int argc MY_ATTRIBUTE((unused)), char** argv)
 {
 	char	server_key[] = "../SSL/server-key.pem",
 		server_cert[] = "../SSL/server-cert.pem";
--- a/vio/vio.c
+++ b/vio/vio.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -37,16 +37,16 @@
   @retval 1       The requested I/O event has occurred.
 */
 
-static int no_io_wait(Vio *vio __attribute__((unused)),
-                      enum enum_vio_io_event event __attribute__((unused)),
-                      int timeout __attribute__((unused)))
+static int no_io_wait(Vio *vio MY_ATTRIBUTE((unused)),
+                      enum enum_vio_io_event event MY_ATTRIBUTE((unused)),
+                      int timeout MY_ATTRIBUTE((unused)))
 {
   return 1;
 }
 
 #endif
 
-static my_bool has_no_data(Vio *vio __attribute__((unused)))
+static my_bool has_no_data(Vio *vio MY_ATTRIBUTE((unused)))
 {
   return FALSE;
 }
@@ -177,7 +177,7 @@ static void vio_init(Vio *vio, enum enum_vio_type type,
 */
 
 my_bool vio_reset(Vio* vio, enum enum_vio_type type,
-                  my_socket sd, void *ssl __attribute__((unused)), uint flags)
+                  my_socket sd, void *ssl MY_ATTRIBUTE((unused)), uint flags)
 {
   int ret= FALSE;
   Vio new_vio;
--- a/vio/viosocket.c
+++ b/vio/viosocket.c
@@ -1,5 +1,5 @@
 /*
-   Copyright (c) 2001, 2015, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2001, 2016, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
@@ -29,7 +29,7 @@
 # include <sys/filio.h>
 #endif
 
-int vio_errno(Vio *vio __attribute__((unused)))
+int vio_errno(Vio *vio MY_ATTRIBUTE((unused)))
 {
   /* These transport types are not Winsock based. */
 #ifdef _WIN32
@@ -247,8 +247,8 @@ static int vio_set_blocking(Vio *vio, my_bool status)
 
 
 int vio_socket_timeout(Vio *vio,
-                       uint which __attribute__((unused)),
-                       my_bool old_mode __attribute__((unused)))
+                       uint which MY_ATTRIBUTE((unused)),
+                       my_bool old_mode MY_ATTRIBUTE((unused)))
 {
   int ret= 0;
   DBUG_ENTER("vio_socket_timeout");
@@ -314,7 +314,7 @@ int vio_socket_timeout(Vio *vio,
 }
 
 
-int vio_fastsend(Vio * vio __attribute__((unused)))
+int vio_fastsend(Vio * vio MY_ATTRIBUTE((unused)))
 {
   int r=0;
   DBUG_ENTER("vio_fastsend");
@@ -735,7 +735,7 @@ static my_bool socket_peek_read(Vio *vio, uint *bytes)
 int vio_io_wait(Vio *vio, enum enum_vio_io_event event, int timeout)
 {
   int ret;
-  short revents __attribute__((unused)) = 0;
+  short revents MY_ATTRIBUTE((unused)) = 0;
   struct pollfd pfd;
   my_socket sd= mysql_socket_getfd(vio->mysql_socket);
   MYSQL_SOCKET_WAIT_VARIABLES(locker, state) /* no ';' */


