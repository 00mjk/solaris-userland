Patch developed in-house.  Solaris-specific; not suitable for upstream.

--- openssl-1.0.1f/crypto/evp/evp_enc.c.orig	Mon Feb 11 07:26:04 2013
+++ openssl-1.0.1f/crypto/evp/evp_enc.c	Mon Feb  3 16:40:48 2014
@@ -394,10 +394,14 @@
 		{
 		ret = M_do_cipher(ctx, out, NULL, 0);
 		if (ret < 0)
-			return 0;
+			{
+			ret = 0;
+			goto cleanup;
+			}
 		else 
 			*outl = ret;
-		return 1;
+		ret = 1;
+		goto cleanup;
 		}
 
 	b=ctx->cipher->block_size;
@@ -405,7 +409,8 @@
 	if (b == 1)
 		{
 		*outl=0;
-		return 1;
+		ret = 1;
+		goto cleanup;
 		}
 	bl=ctx->buf_len;
 	if (ctx->flags & EVP_CIPH_NO_PADDING)
@@ -413,10 +418,12 @@
 		if(bl)
 			{
 			EVPerr(EVP_F_EVP_ENCRYPTFINAL_EX,EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH);
-			return 0;
+			ret = 0;
+			goto cleanup;
 			}
 		*outl = 0;
-		return 1;
+		ret = 1;
+		goto cleanup;
 		}
 
 	n=b-bl;
@@ -428,6 +435,12 @@
 	if(ret)
 		*outl=b;
 
+cleanup:
+	if (ctx->cipher->cleanup)
+		{
+		ctx->cipher->cleanup(ctx);
+		}
+
 	return ret;
 	}
 
@@ -502,6 +515,7 @@
 int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)
 	{
 	unsigned int i, b;
+	int err = 1;
         unsigned char pad, padding_good;
 	*outl=0;
 
@@ -509,10 +522,14 @@
 		{
 		int ret = M_do_cipher(ctx, out, NULL, 0);
 		if (ret < 0)
-			return 0;
+			{
+			err = 0;
+			goto cleanup;
+			}
 		else
 			*outl = ret;
-		return 1;
+		err = 1;
+		goto cleanup;
 		}
 
 	b=(unsigned int)(ctx->cipher->block_size);
@@ -521,10 +538,12 @@
 		if(ctx->buf_len)
 			{
 			EVPerr(EVP_F_EVP_DECRYPTFINAL_EX,EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH);
-			return 0;
+			err = 0;
+			goto cleanup;
 			}
 		*outl = 0;
-		return 1;
+		err = 1;
+		goto cleanup;
 		}
 	if (b > 1)
 		{
@@ -531,7 +550,8 @@
 		if (ctx->buf_len || !ctx->final_used)
 			{
 			EVPerr(EVP_F_EVP_DECRYPTFINAL_EX,EVP_R_WRONG_FINAL_BLOCK_LENGTH);
-			return(0);
+			err = 0;
+			goto cleanup;
 			}
 		OPENSSL_assert(b <= sizeof ctx->final);
 		pad=ctx->final[b-1];
@@ -555,13 +577,22 @@
 			out[i] = ctx->final[i] & padding_good;
 		/* Safe cast: for a good padding, EVP_MAX_IV_LENGTH >= b >= pad */
 		*outl = padding_good & ((unsigned char)(b - pad));
-		return padding_good & 1;
+		err = padding_good & 1;
+		goto cleanup;
 		}
 	else
 		{
 		*outl = 0;
-		return 1;
+		err = 1;
 		}
+
+cleanup:
+	if (ctx->cipher->cleanup)
+		{
+		ctx->cipher->cleanup(ctx);
+		}
+
+	return err;
 	}
 
 void EVP_CIPHER_CTX_free(EVP_CIPHER_CTX *ctx)
