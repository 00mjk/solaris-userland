# http://reviews.llvm.org/D10271
# Backported to 3.6.2.
--- include/llvm/IR/DerivedTypes.h	2014-11-21 14:03:35.000000000 -0500
+++ include/llvm/IR/DerivedTypes.h	2015-08-23 17:27:29.355504909 -0400
@@ -140,7 +140,8 @@
     return T->getTypeID() == FunctionTyID;
   }
 };
-
+static_assert(AlignOf<FunctionType>::Alignment >= AlignOf<Type *>::Alignment,
+              "Insufficient alignment for objects appended to FunctionType");
 
 /// CompositeType - Common super class of ArrayType, StructType, PointerType
 /// and VectorType.
--- include/llvm/IR/User.h	2014-10-15 16:39:05.000000000 -0400
+++ include/llvm/IR/User.h	2015-08-23 17:27:29.365505148 -0400
@@ -22,6 +22,7 @@
 #include "llvm/ADT/iterator.h"
 #include "llvm/ADT/iterator_range.h"
 #include "llvm/IR/Value.h"
+#include "llvm/Support/AlignOf.h"
 #include "llvm/Support/ErrorHandling.h"
 
 namespace llvm {
@@ -172,6 +173,11 @@
     return isa<Instruction>(V) || isa<Constant>(V);
   }
 };
+// Either Use objects, or a Use pointer can be prepended to User.
+static_assert(AlignOf<Use>::Alignment >= AlignOf<User>::Alignment,
+              "Insufficient alignment after objects prepended to User");
+static_assert(AlignOf<Use *>::Alignment >= AlignOf<User>::Alignment,
+              "Insufficient alignment after objects prepended to User");
 
 template<> struct simplify_type<User::op_iterator> {
   typedef Value* SimpleType;
--- include/llvm/Support/AlignOf.h	2014-01-08 22:28:55.000000000 -0500
+++ include/llvm/Support/AlignOf.h	2015-08-23 17:27:29.365505148 -0400
@@ -36,9 +36,18 @@
 ///  compile-time constant (e.g., for template instantiation).
 template <typename T>
 struct AlignOf {
+#ifndef _MSC_VER
+  // Avoid warnings from GCC like:
+  //   comparison between 'enum llvm::AlignOf<X>::<anonymous>' and 'enum
+  //   llvm::AlignOf<Y>::<anonymous>' [-Wenum-compare]
+  // by using constexpr instead of enum.
+  // (except on MSVC, since it doesn't support constexpr yet).
+  static constexpr unsigned Alignment =
+      static_cast<unsigned int>(sizeof(AlignmentCalcImpl<T>) - sizeof(T));
+#else
   enum { Alignment =
          static_cast<unsigned int>(sizeof(AlignmentCalcImpl<T>) - sizeof(T)) };
-
+#endif
   enum { Alignment_GreaterEqual_2Bytes = Alignment >= 2 ? 1 : 0 };
   enum { Alignment_GreaterEqual_4Bytes = Alignment >= 4 ? 1 : 0 };
   enum { Alignment_GreaterEqual_8Bytes = Alignment >= 8 ? 1 : 0 };
@@ -50,6 +59,10 @@
   enum { Alignment_LessEqual_16Bytes = Alignment <= 16 ? 1 : 0 };
 };
 
+#ifndef _MSC_VER
+template <typename T> constexpr unsigned AlignOf<T>::Alignment;
+#endif
+
 /// alignOf - A templated function that returns the minimum alignment of
 ///  of a type.  This provides no extra functionality beyond the AlignOf
 ///  class besides some cosmetic cleanliness.  Example usage:
--- lib/IR/AttributeImpl.h	2014-08-13 12:26:38.000000000 -0400
+++ lib/IR/AttributeImpl.h	2015-08-23 17:27:29.366505172 -0400
@@ -180,6 +180,9 @@
       AttrList[I].Profile(ID);
   }
 };
+static_assert(AlignOf<AttributeSetNode>::Alignment >=
+                  AlignOf<Attribute>::Alignment,
+              "Insufficient alignment for objects appended to AttributeSetNode");
 
 //===----------------------------------------------------------------------===//
 /// \class
@@ -188,9 +191,11 @@
 class AttributeSetImpl : public FoldingSetNode {
   friend class AttributeSet;
 
-  LLVMContext &Context;
-
+public:
   typedef std::pair<unsigned, AttributeSetNode*> IndexAttrPair;
+
+private:
+  LLVMContext &Context;
   unsigned NumAttrs; ///< Number of entries in this set.
 
   /// \brief Return a pointer to the IndexAttrPair for the specified slot.
@@ -205,6 +210,7 @@
   AttributeSetImpl(LLVMContext &C,
                    ArrayRef<std::pair<unsigned, AttributeSetNode *> > Attrs)
       : Context(C), NumAttrs(Attrs.size()) {
+
 #ifndef NDEBUG
     if (Attrs.size() >= 2) {
       for (const std::pair<unsigned, AttributeSetNode *> *i = Attrs.begin() + 1,
@@ -266,6 +272,9 @@
 
   void dump() const;
 };
+static_assert(AlignOf<AttributeSetImpl>::Alignment >=
+                  AlignOf<AttributeSetImpl::IndexAttrPair>::Alignment,
+              "Insufficient alignment for objects appended to AttributeSetImpl");
 
 } // end llvm namespace
 
--- lib/IR/User.cpp	2015-08-23 17:27:29.366505172 -0400
+++ lib/IR/User.cpp	2015-08-23 17:34:56.427494589 -0400
@@ -40,6 +40,11 @@
 //===----------------------------------------------------------------------===//
 
 Use *User::allocHungoffUses(unsigned N) const {
+  static_assert(AlignOf<Use>::Alignment >= AlignOf<Use::UserRef>::Alignment,
+                "Insufficient alignment for hung-off-uses objects");
+  static_assert(AlignOf<Use::UserRef>::Alignment >=
+                AlignOf<BasicBlock*>::Alignment,
+                "Insufficient alignment for hung-off-uses objects");
   // Allocate the array of Uses, followed by a pointer (with bottom bit set) to
   // the User.
   size_t size = N * sizeof(Use) + sizeof(Use::UserRef);
