# 21870099 - 128 bytes for a filesystem path is definitely not enough
# 21870283 - llvm::sys::Process::GetArgumentVector should overload for
# std::vector
# For upstream - maybe.
--- tools/clang/tools/driver/driver.cpp	2015-09-20 11:19:37.402058833 -0700
+++ tools/clang/tools/driver/driver.cpp	2015-09-20 17:00:21.850124658 -0700
@@ -89,21 +89,21 @@
 ///  and the following argument.
 ///
 ///  'Ox': Removes all flags matching 'O' or 'O[sz0-9]' and adds 'Ox'
 ///  at the end of the command line.
 ///
 /// \param OS - The stream to write edit information to.
 /// \param Args - The vector of command line arguments.
 /// \param Edit - The override command to perform.
 /// \param SavedStrings - Set to use for storing string representations.
 static void ApplyOneQAOverride(raw_ostream &OS,
-                               SmallVectorImpl<const char*> &Args,
+                               std::vector<const char*> &Args,
                                StringRef Edit,
                                std::set<std::string> &SavedStrings) {
   // This does not need to be efficient.
 
   if (Edit[0] == '^') {
     const char *Str =
       GetStableCStr(SavedStrings, Edit.substr(1));
     OS << "### Adding argument " << Str << " at beginning\n";
     Args.insert(Args.begin() + 1, Str);
   } else if (Edit[0] == '+') {
@@ -161,21 +161,21 @@
     }
     OS << "### Adding argument " << Edit << " at end\n";
     Args.push_back(GetStableCStr(SavedStrings, '-' + Edit.str()));
   } else {
     OS << "### Unrecognized edit: " << Edit << "\n";
   }
 }
 
 /// ApplyQAOverride - Apply a comma separate list of edits to the
 /// input argument lists. See ApplyOneQAOverride.
-static void ApplyQAOverride(SmallVectorImpl<const char*> &Args,
+static void ApplyQAOverride(std::vector<const char*> &Args,
                             const char *OverrideStr,
                             std::set<std::string> &SavedStrings) {
   raw_ostream *OS = &llvm::errs();
 
   if (OverrideStr[0] == '#') {
     ++OverrideStr;
     OS = &llvm::nulls();
   }
 
   *OS << "### CCC_OVERRIDE_OPTIONS: " << OverrideStr << "\n";
@@ -223,21 +223,21 @@
       {"cl", "--driver-mode=cl"},
       {"++", "--driver-mode=g++"},
   };
 
   for (size_t i = 0; i < llvm::array_lengthof(DriverSuffixes); ++i)
     if (ProgName.endswith(DriverSuffixes[i].Suffix))
       return &DriverSuffixes[i];
   return nullptr;
 }
 
-static void ParseProgName(SmallVectorImpl<const char *> &ArgVector,
+static void ParseProgName(std::vector<const char *> &ArgVector,
                           std::set<std::string> &SavedStrings) {
   // Try to infer frontend type and default target from the program name by
   // comparing it against DriverSuffixes in order.
 
   // If there is a match, the function tries to identify a target as prefix.
   // E.g. "x86_64-linux-clang" as interpreted as suffix "clang" with target
   // prefix "x86_64-linux". If such a target prefix is found, is gets added via
   // -target as implicit first argument.
 
   std::string ProgName =llvm::sys::path::stem(ArgVector[0]);
@@ -325,39 +325,40 @@
   // use clang-cl.exe as the prefix to avoid confusion between clang and MSVC.
   StringRef ExeBasename(llvm::sys::path::filename(Path));
   if (ExeBasename.equals_lower("cl.exe"))
     ExeBasename = "clang-cl.exe";
   DiagClient->setPrefix(ExeBasename);
 }
 
 // This lets us create the DiagnosticsEngine with a properly-filled-out
 // DiagnosticOptions instance.
 static DiagnosticOptions *
-CreateAndPopulateDiagOpts(SmallVectorImpl<const char *> &argv) {
-  auto *DiagOpts = new DiagnosticOptions;
+CreateAndPopulateDiagOpts(std::vector<const char *> &argv) {
+  auto *DiagOpts = new DiagnosticOptions();
   std::unique_ptr<OptTable> Opts(createDriverOptTable());
   unsigned MissingArgIndex, MissingArgCount;
   std::unique_ptr<InputArgList> Args(Opts->ParseArgs(
-      argv.begin() + 1, argv.end(), MissingArgIndex, MissingArgCount));
+      argv.data() + 1, argv.data() + argv.size(), MissingArgIndex,
+      MissingArgCount));
   // We ignore MissingArgCount and the return value of ParseDiagnosticArgs.
   // Any errors that would be diagnosed here will also be diagnosed later,
   // when the DiagnosticsEngine actually exists.
   (void) ParseDiagnosticArgs(*DiagOpts, *Args);
   return DiagOpts;
 }
 
-static void SetInstallDir(SmallVectorImpl<const char *> &argv,
+static void SetInstallDir(std::vector<const char *> &argv,
                           Driver &TheDriver) {
   // Attempt to find the original path used to invoke the driver, to determine
   // the installed path. We do this manually, because we want to support that
   // path being a symlink.
-  SmallString<128> InstalledPath(argv[0]);
+  SmallString<PATH_MAX> InstalledPath(argv[0]);
 
   // Do a PATH lookup, if there are no directory components.
   if (llvm::sys::path::filename(InstalledPath) == InstalledPath)
     if (llvm::ErrorOr<std::string> Tmp = llvm::sys::findProgramByName(
             llvm::sys::path::filename(InstalledPath.str())))
       InstalledPath = *Tmp;
   llvm::sys::fs::make_absolute(InstalledPath);
   InstalledPath = llvm::sys::path::parent_path(InstalledPath);
   if (llvm::sys::fs::exists(InstalledPath.c_str()))
     TheDriver.setInstalledDir(InstalledPath);
@@ -375,24 +376,26 @@
   return 1;
 }
 
 int main(int argc_, const char **argv_) {
   llvm::sys::PrintStackTraceOnErrorSignal();
   llvm::PrettyStackTraceProgram X(argc_, argv_);
 
   if (llvm::sys::Process::FixupStandardFileDescriptors())
     return 1;
 
-  SmallVector<const char *, 256> argv;
+  std::vector<const char*> argv;
   llvm::SpecificBumpPtrAllocator<char> ArgAllocator;
-  std::error_code EC = llvm::sys::Process::GetArgumentVector(
-      argv, llvm::makeArrayRef(argv_, argc_), ArgAllocator);
+  llvm::ArrayRef<const char*> AAR = llvm::makeArrayRef(argv_, argc_);
+  std::error_code EC =
+    llvm::sys::Process::GetArgumentVector(argv, AAR);
+
   if (EC) {
     llvm::errs() << "error: couldn't get arguments: " << EC.message() << '\n';
     return 1;
   }
 
   std::set<std::string> SavedStrings;
   StringSetSaver Saver(SavedStrings);
 
   // Determines whether we want nullptr markers in argv to indicate response
   // files end-of-lines. We only use this for the /LINK driver argument.
@@ -459,21 +462,21 @@
   Driver TheDriver(Path, llvm::sys::getDefaultTargetTriple(), Diags);
   SetInstallDir(argv, TheDriver);
 
   llvm::InitializeAllTargets();
   ParseProgName(argv, SavedStrings);
 
   SetBackdoorDriverOutputsFromEnvVars(TheDriver);
 
   std::unique_ptr<Compilation> C(TheDriver.BuildCompilation(argv));
   int Res = 0;
-  SmallVector<std::pair<int, const Command *>, 4> FailingCommands;
+  SmallVector<std::pair<int, const Command *>, 8> FailingCommands;
   if (C.get())
     Res = TheDriver.ExecuteCompilation(*C, FailingCommands);
 
   // Force a crash to test the diagnostics.
   if (::getenv("FORCE_CLANG_DIAGNOSTICS_CRASH")) {
     Diags.Report(diag::err_drv_force_crash) << "FORCE_CLANG_DIAGNOSTICS_CRASH";
 
     // Pretend that every command failed.
     FailingCommands.clear();
     for (const auto &J : C->getJobs())
