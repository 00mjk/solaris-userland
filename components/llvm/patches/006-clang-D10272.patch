# Giant clang 3.6.2 patch for correcting misalignments.
# Patch is from: http://reviews.llvm.org/D10272
# Adjustments were made for 3.6.2 (the original does not apply cleanly).
--- include/llvm/Support/Compiler.h	2014-11-18 17:17:30.000000000 -0500
+++ include/llvm/Support/Compiler.h	2015-07-17 23:43:07.143745400 -0400
@@ -303,6 +303,37 @@
 # define LLVM_ASSUME_ALIGNED(p, a) (p)
 #endif
 
+/// \macro LLVM_ALIGNAS
+/// \brief Used to specify a minimum alignment for a structure or variable. The
+/// alignment must be a constant integer. Use LLVM_PTR_SIZE to compute
+/// alignments in terms of the size of a pointer.
+///
+/// Note that __declspec(align) has special quirks, it's not legal to pass a
+/// structure with __declspec(align) as a formal parameter.
+#ifdef _MSC_VER
+# define LLVM_ALIGNAS(x) __declspec(align(x))
+#elif __GNUC__ && !__has_feature(cxx_alignas) && !LLVM_GNUC_PREREQ(4, 8, 0)
+# define LLVM_ALIGNAS(x) __attribute__((aligned(x)))
+#else
+# define LLVM_ALIGNAS(x) alignas(x)
+#endif
+
+/// \macro LLVM_PTR_SIZE
+/// \brief A constant integer equivalent to the value of sizeof(void*).
+/// Generally used in combination with LLVM_ALIGNAS or when doing computation in
+/// the preprocessor.
+#ifdef __SIZEOF_POINTER__
+# define LLVM_PTR_SIZE __SIZEOF_POINTER__
+#elif defined(_WIN64)
+# define LLVM_PTR_SIZE 8
+#elif defined(_WIN32)
+# define LLVM_PTR_SIZE 4
+#elif defined(_MSC_VER)
+# error "could not determine LLVM_PTR_SIZE as a constant int for MSVC"
+#else
+# define LLVM_PTR_SIZE sizeof(void *)
+#endif
+
 /// \macro LLVM_FUNCTION_NAME
 /// \brief Expands to __func__ on compilers which support it.  Otherwise,
 /// expands to a compiler-dependent replacement.
--- tools/clang/include/clang/AST/Decl.h	2015-01-13 16:31:13.000000000 -0800
+++ tools/clang/include/clang/AST/Decl.h	2015-07-17 16:43:46.474996996 -0700
@@ -3658,6 +3658,9 @@
   static bool classof(const Decl *D) { return classofKind(D->getKind()); }
   static bool classofKind(Kind K) { return K == Import; }
 };
+static_assert(llvm::AlignOf<ImportDecl>::Alignment >=
+                  llvm::AlignOf<SourceLocation>::Alignment,
+              "Alignment is insufficient for objects appended to ImportDecl");
 
 /// \brief Represents an empty-declaration.
 class EmptyDecl : public Decl {
--- tools/clang/include/clang/AST/DeclBase.h	2014-11-17 15:36:45.000000000 -0800
+++ tools/clang/include/clang/AST/DeclBase.h	2015-07-17 16:43:46.476997606 -0700
@@ -69,6 +69,9 @@
 /// Decl - This represents one declaration (or definition), e.g. a variable,
 /// typedef, function, struct, etc.
 ///
+/// Note: There are objects tacked on before the *beginning* of Decl
+/// (and its subclasses) in its Decl::operator new(). Proper alignment
+/// for all subclasses is asserted in DeclBase.cpp.
 class Decl {
 public:
   /// \brief Lists the kind of concrete classes of Decl.
--- tools/clang/include/clang/AST/DeclCXX.h	2014-12-10 12:04:48.000000000 -0800
+++ tools/clang/include/clang/AST/DeclCXX.h	2015-07-17 16:43:46.479237326 -0700
@@ -2130,6 +2130,10 @@
   /// \brief Get the initializer.
   Expr *getInit() const { return static_cast<Expr*>(Init); }
 };
+static_assert(
+    llvm::AlignOf<CXXCtorInitializer>::Alignment >=
+        llvm::AlignOf<VarDecl *>::Alignment,
+    "Alignment is insufficient for objects appended to CXXCtorInitializer");
 
 /// \brief Represents a C++ constructor within a class.
 ///
--- tools/clang/include/clang/AST/DeclFriend.h	2014-07-16 18:59:34.000000000 -0700
+++ tools/clang/include/clang/AST/DeclFriend.h	2015-07-17 16:43:46.480506828 -0700
@@ -172,6 +172,9 @@
   friend class ASTDeclReader;
   friend class ASTDeclWriter;
 };
+static_assert(llvm::AlignOf<FriendDecl>::Alignment >=
+                  llvm::AlignOf<TemplateParameterList *>::Alignment,
+              "Alignment is insufficient for objects appended to FriendDecl");
 
 /// An iterator over the friend declarations of a class.
 class CXXRecordDecl::friend_iterator {
--- tools/clang/include/clang/AST/DeclGroup.h	2014-05-05 23:48:52.000000000 -0700
+++ tools/clang/include/clang/AST/DeclGroup.h	2015-07-17 16:43:46.481808784 -0700
@@ -14,6 +14,7 @@
 #ifndef LLVM_CLANG_AST_DECLGROUP_H
 #define LLVM_CLANG_AST_DECLGROUP_H
 
+#include "llvm/Support/AlignOf.h"
 #include "llvm/Support/DataTypes.h"
 #include <cassert>
 
@@ -51,6 +52,9 @@
     return ((Decl* const*) (this+1))[i];
   }
 };
+static_assert(llvm::AlignOf<DeclGroup>::Alignment >=
+                  llvm::AlignOf<Decl *>::Alignment,
+              "Alignment is insufficient for objects appended to DeclGroup");
 
 class DeclGroupRef {
   // Note this is not a PointerIntPair because we need the address of the
--- tools/clang/include/clang/AST/DeclOpenMP.h	2014-11-10 20:05:39.000000000 -0800
+++ tools/clang/include/clang/AST/DeclOpenMP.h	2015-07-17 16:43:46.482893197 -0700
@@ -84,6 +84,10 @@
   static bool classof(const Decl *D) { return classofKind(D->getKind()); }
   static bool classofKind(Kind K) { return K == OMPThreadPrivate; }
 };
+static_assert(
+    llvm::AlignOf<OMPThreadPrivateDecl>::Alignment >=
+        llvm::AlignOf<Expr *>::Alignment,
+    "Alignment is insufficient for objects appended to OMPThreadPrivateDecl");
 
 }  // end namespace clang
 
--- tools/clang/include/clang/AST/DeclTemplate.h	2014-08-30 09:55:39.000000000 -0700
+++ tools/clang/include/clang/AST/DeclTemplate.h	2015-07-17 16:43:46.485713092 -0700
@@ -43,7 +43,7 @@
 
 /// \brief Stores a list of template parameters for a TemplateDecl and its
 /// derived classes.
-class TemplateParameterList {
+class LLVM_ALIGNAS(/*alignof(void*)*/ LLVM_PTR_SIZE) TemplateParameterList {
   /// The location of the 'template' keyword.
   SourceLocation TemplateLoc;
 
@@ -131,6 +131,10 @@
     return SourceRange(TemplateLoc, RAngleLoc);
   }
 };
+static_assert(
+    llvm::AlignOf<TemplateParameterList>::Alignment >=
+        llvm::AlignOf<NamedDecl *>::Alignment,
+    "Alignment is insufficient for objects appended to TemplateParameterList");
 
 /// \brief Stores a list of template parameters for a TemplateDecl and its
 /// derived classes. Suitable for creating on the stack.
@@ -460,27 +464,20 @@
 ///     friend void foo<>(T);
 ///   };
 /// \endcode
-class DependentFunctionTemplateSpecializationInfo {
-  struct CA {
+class LLVM_ALIGNAS(/*alignof(uint64_t)*/ 8)
+    DependentFunctionTemplateSpecializationInfo {
     /// The number of potential template candidates.
     unsigned NumTemplates;
 
     /// The number of template arguments.
     unsigned NumArgs;
-  };
-
-  union {
-    // Force sizeof to be a multiple of sizeof(void*) so that the
-    // trailing data is aligned.
-    void *Aligner;
-    struct CA d;
-  };
 
   /// The locations of the left and right angle brackets.
   SourceRange AngleLocs;
 
   FunctionTemplateDecl * const *getTemplates() const {
-    return reinterpret_cast<FunctionTemplateDecl*const*>(this+1);
+    return reinterpret_cast<FunctionTemplateDecl *const *>(
+        &getTemplateArgs()[NumArgs]);
   }
 
 public:
@@ -490,9 +487,7 @@
 
   /// \brief Returns the number of function templates that this might
   /// be a specialization of.
-  unsigned getNumTemplates() const {
-    return d.NumTemplates;
-  }
+  unsigned getNumTemplates() const { return NumTemplates; }
 
   /// \brief Returns the i'th template candidate.
   FunctionTemplateDecl *getTemplate(unsigned I) const {
@@ -502,14 +497,11 @@
 
   /// \brief Returns the explicit template arguments that were given.
   const TemplateArgumentLoc *getTemplateArgs() const {
-    return reinterpret_cast<const TemplateArgumentLoc*>(
-                                            &getTemplates()[getNumTemplates()]);
+    return reinterpret_cast<const TemplateArgumentLoc *>(this + 1);
   }
 
   /// \brief Returns the number of explicit template arguments that were given.
-  unsigned getNumTemplateArgs() const {
-    return d.NumArgs;
-  }
+  unsigned getNumTemplateArgs() const { return NumArgs; }
 
   /// \brief Returns the nth template argument.
   const TemplateArgumentLoc &getTemplateArg(unsigned I) const {
@@ -525,6 +517,15 @@
     return AngleLocs.getEnd();
   }
 };
+static_assert(
+    llvm::AlignOf<DependentFunctionTemplateSpecializationInfo>::Alignment >=
+        llvm::AlignOf<TemplateArgumentLoc>::Alignment,
+    "Alignment is insufficient for objects appended to "
+    "DependentFunctionTemplateSpecializationInfo");
+static_assert(llvm::AlignOf<TemplateArgumentLoc>::Alignment >=
+                  llvm::AlignOf<FunctionTemplateDecl *>::Alignment,
+              "Alignment is insufficient for objects appended to "
+              "DependentFunctionTemplateSpecializationInfo");
 
 /// Declaration of a redeclarable template.
 class RedeclarableTemplateDecl : public TemplateDecl, 
@@ -1203,6 +1204,10 @@
   static bool classof(const Decl *D) { return classofKind(D->getKind()); }
   static bool classofKind(Kind K) { return K == NonTypeTemplateParm; }
 };
+static_assert(llvm::AlignOf<NonTypeTemplateParmDecl>::Alignment >=
+                  llvm::AlignOf<void *>::Alignment,
+              "Alignment is insufficient for objects appended to "
+              "NonTypeTemplateParmDecl");
 
 /// TemplateTemplateParmDecl - Declares a template template parameter,
 /// e.g., "T" in
@@ -1369,6 +1374,10 @@
   friend class ASTDeclReader;
   friend class ASTDeclWriter;
 };
+static_assert(llvm::AlignOf<TemplateTemplateParmDecl>::Alignment >=
+                  llvm::AlignOf<TemplateParameterList *>::Alignment,
+              "Alignment is insufficient for objects appended to "
+              "TemplateTemplateParmDecl");
 
 /// \brief Represents a class template specialization, which refers to
 /// a class template with a given set of template arguments.
--- tools/clang/include/clang/AST/EvaluatedExprVisitor.h	2014-12-03 13:00:20.000000000 -0800
+++ tools/clang/include/clang/AST/EvaluatedExprVisitor.h	2015-07-17 16:43:46.487103645 -0700
@@ -85,7 +85,7 @@
 
   void VisitLambdaExpr(LambdaExpr *LE) {
     // Only visit the capture initializers, and not the body.
-    for (LambdaExpr::capture_init_iterator I = LE->capture_init_begin(),
+    for (LambdaExpr::const_capture_init_iterator I = LE->capture_init_begin(),
                                            E = LE->capture_init_end();
          I != E; ++I)
       if (*I)
--- tools/clang/include/clang/AST/Expr.h	2015-01-12 02:17:46.000000000 -0800
+++ tools/clang/include/clang/AST/Expr.h	2015-07-17 16:43:46.491602160 -0700
@@ -894,7 +894,7 @@
 ///   DeclRefExprBits.RefersToEnclosingVariableOrCapture
 ///       Specifies when this declaration reference expression (validly)
 ///       refers to an enclosed local or a captured variable.
-class DeclRefExpr : public Expr {
+class LLVM_ALIGNAS(/*alignof(uint64_t)*/ 8) DeclRefExpr : public Expr {
   /// \brief The declaration that we are referencing.
   ValueDecl *D;
 
@@ -1048,13 +1048,17 @@
     if (!hasTemplateKWAndArgsInfo())
       return nullptr;
 
-    if (hasFoundDecl())
+    if (hasFoundDecl()) {
       return reinterpret_cast<ASTTemplateKWAndArgsInfo *>(
-        &getInternalFoundDecl() + 1);
+          llvm::alignAddr(&getInternalFoundDecl() + 1,
+                          llvm::alignOf<ASTTemplateKWAndArgsInfo>()));
+    }
 
-    if (hasQualifier())
+    if (hasQualifier()) {
       return reinterpret_cast<ASTTemplateKWAndArgsInfo *>(
-        &getInternalQualifierLoc() + 1);
+          llvm::alignAddr(&getInternalQualifierLoc() + 1,
+                          llvm::alignOf<ASTTemplateKWAndArgsInfo>()));
+    }
 
     return reinterpret_cast<ASTTemplateKWAndArgsInfo *>(this + 1);
   }
@@ -1167,6 +1171,16 @@
   friend class ASTStmtReader;
   friend class ASTStmtWriter;
 };
+static_assert(llvm::AlignOf<DeclRefExpr>::Alignment >=
+                  llvm::AlignOf<NestedNameSpecifierLoc>::Alignment,
+              "Alignment is insufficient for objects appended to DeclRefExpr");
+static_assert(llvm::AlignOf<NestedNameSpecifierLoc>::Alignment >=
+                  llvm::AlignOf<NamedDecl *>::Alignment,
+              "Alignment is insufficient for objects appended to DeclRefExpr");
+// Code re-aligns before ASTTemplateKWAndArgsInfo
+static_assert(llvm::AlignOf<DeclRefExpr>::Alignment >=
+                  llvm::AlignOf<ASTTemplateKWAndArgsInfo>::Alignment,
+              "Alignment is insufficient for objects appended to DeclRefExpr");
 
 /// \brief [C99 6.4.2.2] - A predefined identifier such as __func__.
 class PredefinedExpr : public Expr {
@@ -1968,6 +1982,12 @@
     return child_range(begin, begin + NumExprs);
   }
 };
+static_assert(llvm::AlignOf<OffsetOfExpr>::Alignment >=
+                  llvm::AlignOf<OffsetOfExpr::OffsetOfNode *>::Alignment,
+              "Alignment is insufficient for objects appended to OffsetOfExpr");
+static_assert(llvm::AlignOf<OffsetOfExpr::OffsetOfNode>::Alignment >=
+                  llvm::AlignOf<Expr *>::Alignment,
+              "Alignment is insufficient for objects appended to OffsetOfExpr");
 
 /// UnaryExprOrTypeTraitExpr - expression with either a type or (unevaluated)
 /// expression operand.  Used for sizeof/alignof (C99 6.5.3.4) and
@@ -2309,9 +2329,10 @@
 
 /// MemberExpr - [C99 6.5.2.3] Structure and Union Members.  X->F and X.F.
 ///
-class MemberExpr : public Expr {
+class LLVM_ALIGNAS(/*alignof(uint64_t)*/ 8) MemberExpr : public Expr {
+public:
   /// Extra data stored in some member expressions.
-  struct MemberNameQualifier {
+  struct LLVM_ALIGNAS(/*alignof(uint64_t)*/ 8) MemberNameQualifier {
     /// \brief The nested-name-specifier that qualifies the name, including
     /// source-location information.
     NestedNameSpecifierLoc QualifierLoc;
@@ -2321,6 +2342,7 @@
     DeclAccessPair FoundDecl;
   };
 
+private:
   /// Base - the expression for the base pointer or structure references.  In
   /// X.F, this is "X".
   Stmt *Base;
@@ -2591,6 +2613,12 @@
   friend class ASTReader;
   friend class ASTStmtWriter;
 };
+static_assert(llvm::AlignOf<MemberExpr>::Alignment >=
+                  llvm::AlignOf<MemberExpr::MemberNameQualifier>::Alignment,
+              "Alignment is insufficient for objects appended to MemberExpr");
+static_assert(llvm::AlignOf<MemberExpr::MemberNameQualifier>::Alignment >=
+                  llvm::AlignOf<ASTTemplateKWAndArgsInfo>::Alignment,
+              "Alignment is insufficient for objects appended to MemberExpr");
 
 /// CompoundLiteralExpr - [C99 6.5.2.5]
 ///
@@ -2747,6 +2775,11 @@
   // Iterators
   child_range children() { return child_range(&Op, &Op+1); }
 };
+static_assert(llvm::AlignOf<CastExpr>::Alignment >=
+                  llvm::AlignOf<CXXBaseSpecifier *>::Alignment,
+              "Alignment is insufficient for objects appended to CastExpr");
+// (Note that the data is actually tacked onto one of its subclasses,
+// but they'll inherit alignment)
 
 /// ImplicitCastExpr - Allows us to explicitly represent implicit type
 /// conversions, which have no direct representation in the original
@@ -4272,6 +4305,10 @@
     return child_range(begin, begin + NumSubExprs);
   }
 };
+static_assert(
+    llvm::AlignOf<DesignatedInitExpr>::Alignment >=
+        llvm::AlignOf<Stmt *>::Alignment,
+    "Alignment is insufficient for objects appended to DesignatedInitExpr");
 
 /// \brief Represents an implicitly-generated value initialization of
 /// an object of a given type.
@@ -4749,6 +4786,10 @@
     return T->getStmtClass() == PseudoObjectExprClass;
   }
 };
+static_assert(
+    llvm::AlignOf<PseudoObjectExpr>::Alignment >=
+        llvm::AlignOf<Expr *>::Alignment,
+    "Alignment is insufficient for objects appended to PseudoObjectExpr");
 
 /// AtomicExpr - Variadic atomic builtins: __atomic_exchange, __atomic_fetch_*,
 /// __atomic_load, __atomic_store, and __atomic_compare_exchange_*, for the
--- tools/clang/include/clang/AST/ExprCXX.h	2015-01-14 03:29:14.000000000 -0800
+++ tools/clang/include/clang/AST/ExprCXX.h	2015-07-18 11:25:29.503136056 -0700
@@ -933,6 +933,10 @@
   friend class ASTStmtReader;
   friend class ASTStmtWriter;
 };
+static_assert(
+    llvm::AlignOf<CXXDefaultArgExpr>::Alignment >=
+        llvm::AlignOf<Expr *>::Alignment,
+    "Alignment is insufficient for objects appended to CXXDefaultArgExpr");
 
 /// \brief A use of a default initializer in a constructor or in aggregate
 /// initialization.
@@ -1395,23 +1399,38 @@
     getStoredStmts()[NumCaptures] = nullptr;
   }
   
-  Stmt **getStoredStmts() const {
+  Stmt **getStoredStmts() {
     return reinterpret_cast<Stmt **>(const_cast<LambdaExpr *>(this) + 1);
   }
   
+  Stmt *const *getStoredStmts() const {
+    return reinterpret_cast<Stmt *const *>(this + 1);
+  }
+  
   /// \brief Retrieve the mapping from captures to the first array index
   /// variable.
-  unsigned *getArrayIndexStarts() const {
+  unsigned *getArrayIndexStarts() {
     return reinterpret_cast<unsigned *>(getStoredStmts() + NumCaptures + 1);
   }
   
+  const unsigned *getArrayIndexStarts() const {
+    return reinterpret_cast<const unsigned *>(getStoredStmts() + NumCaptures + 1);
+  }
+  
   /// \brief Retrieve the complete set of array-index variables.
-  VarDecl **getArrayIndexVars() const {
+  VarDecl **getArrayIndexVars() {
     unsigned ArrayIndexSize =
         llvm::RoundUpToAlignment(sizeof(unsigned) * (NumCaptures + 1),
                                  llvm::alignOf<VarDecl*>());
     return reinterpret_cast<VarDecl **>(
-        reinterpret_cast<char*>(getArrayIndexStarts()) + ArrayIndexSize);
+        reinterpret_cast<unsigned char*>(getArrayIndexStarts()) + ArrayIndexSize);
+  }
+
+  VarDecl *const *getArrayIndexVars() const {
+    unsigned ArrayIndexSize = llvm::RoundUpToAlignment(
+        sizeof(unsigned) * (NumCaptures + 1), llvm::alignOf<VarDecl *>());
+    return reinterpret_cast<VarDecl *const *>(
+        reinterpret_cast<const unsigned char *>(getArrayIndexStarts()) + ArrayIndexSize);
   }
 
 public:
@@ -1492,21 +1511,43 @@
   /// arguments.
   typedef Expr **capture_init_iterator;
 
+  /// \brief Const iterator that walks over the capture initialization
+  /// arguments.
+  typedef Expr *const *const_capture_init_iterator;
+
   /// \brief Retrieve the initialization expressions for this lambda's captures.
-  llvm::iterator_range<capture_init_iterator> capture_inits() const {
+  llvm::iterator_range<capture_init_iterator> capture_inits() {
     return llvm::iterator_range<capture_init_iterator>(capture_init_begin(),
                                                        capture_init_end());
   }
 
+  /// \brief Retrieve the initialization expressions for this lambda's captures.
+  llvm::iterator_range<const_capture_init_iterator> capture_inits() const {
+    return llvm::iterator_range<const_capture_init_iterator>(
+        capture_init_begin(), capture_init_end());
+  }
+
   /// \brief Retrieve the first initialization argument for this
   /// lambda expression (which initializes the first capture field).
-  capture_init_iterator capture_init_begin() const {
+  capture_init_iterator capture_init_begin() {
     return reinterpret_cast<Expr **>(getStoredStmts());
   }
 
+  /// \brief Retrieve the first initialization argument for this
+  /// lambda expression (which initializes the first capture field).
+  const_capture_init_iterator capture_init_begin() const {
+    return reinterpret_cast<Expr *const *>(getStoredStmts());
+  }
+
   /// \brief Retrieve the iterator pointing one past the last
   /// initialization argument for this lambda expression.
-  capture_init_iterator capture_init_end() const {
+  capture_init_iterator capture_init_end() {
+    return capture_init_begin() + NumCaptures;
+  }
+
+  /// \brief Retrieve the iterator pointing one past the last
+  /// initialization argument for this lambda expression.
+  const_capture_init_iterator capture_init_end() const {
     return capture_init_begin() + NumCaptures;    
   }
 
@@ -1515,7 +1556,8 @@
   ///
   /// \param Iter The iterator that points at the capture initializer for 
   /// which we are extracting the corresponding index variables.
-  ArrayRef<VarDecl *> getCaptureInitIndexVars(capture_init_iterator Iter) const;
+  ArrayRef<VarDecl *>
+  getCaptureInitIndexVars(const_capture_init_iterator Iter) const;
   
   /// \brief Retrieve the source range covering the lambda introducer,
   /// which contains the explicit capture list surrounded by square
@@ -1570,6 +1612,16 @@
   friend class ASTStmtReader;
   friend class ASTStmtWriter;
 };
+static_assert(llvm::AlignOf<LambdaExpr>::Alignment >=
+                  llvm::AlignOf<Stmt *>::Alignment,
+              "Alignment is insufficient for objects appended to LambdaExpr");
+static_assert(llvm::AlignOf<Stmt *>::Alignment >=
+                  llvm::AlignOf<unsigned>::Alignment,
+              "Alignment is insufficient for objects appended to LambdaExpr");
+// Code re-aligns before VarDecl *[]
+static_assert(llvm::AlignOf<LambdaExpr>::Alignment >=
+                  llvm::AlignOf<VarDecl *>::Alignment,
+              "Alignment is insufficient for objects appended to LambdaExpr");
 
 /// An expression "T()" which creates a value-initialized rvalue of type
 /// T, which is a non-class type.  See (C++98 [5.2.3p2]).
@@ -2157,6 +2209,10 @@
   friend class ASTStmtWriter;
 
 };
+static_assert(
+    llvm::AlignOf<TypeTraitExpr>::Alignment >=
+        llvm::AlignOf<TypeSourceInfo *>::Alignment,
+    "Alignment is insufficient for objects appended to TypeTraitExpr");
 
 /// \brief An Embarcadero array type trait, as used in the implementation of
 /// __array_rank and __array_extent.
@@ -2289,7 +2345,7 @@
 
 /// \brief A reference to an overloaded function set, either an
 /// \c UnresolvedLookupExpr or an \c UnresolvedMemberExpr.
-class OverloadExpr : public Expr {
+class LLVM_ALIGNAS(/*alignof(uint64_t)*/ 8) OverloadExpr : public Expr {
   /// \brief The common name of these declarations.
   DeclarationNameInfo NameInfo;
 
@@ -2578,6 +2634,10 @@
     return T->getStmtClass() == UnresolvedLookupExprClass;
   }
 };
+static_assert(
+    llvm::AlignOf<UnresolvedLookupExpr>::Alignment >=
+        llvm::AlignOf<ASTTemplateKWAndArgsInfo>::Alignment,
+    "Alignment is insufficient for objects appended to UnresolvedLookupExpr");
 
 /// \brief A qualified reference to a name whose declaration cannot
 /// yet be resolved.
@@ -2593,7 +2653,8 @@
 /// qualifier (X<T>::) and the name of the entity being referenced
 /// ("value"). Such expressions will instantiate to a DeclRefExpr once the
 /// declaration can be found.
-class DependentScopeDeclRefExpr : public Expr {
+class LLVM_ALIGNAS(/*alignof(uint64_t)*/ 8) DependentScopeDeclRefExpr
+    : public Expr {
   /// \brief The nested-name-specifier that qualifies this unresolved
   /// declaration name.
   NestedNameSpecifierLoc QualifierLoc;
@@ -2739,6 +2800,10 @@
   friend class ASTStmtReader;
   friend class ASTStmtWriter;
 };
+static_assert(llvm::AlignOf<DependentScopeDeclRefExpr>::Alignment >=
+                  llvm::AlignOf<ASTTemplateKWAndArgsInfo>::Alignment,
+              "Alignment is insufficient for objects appended to "
+              "DependentScopeDeclRefExpr");
 
 /// Represents an expression -- generally a full-expression -- that
 /// introduces cleanups to be run at the end of the sub-expression's
@@ -2810,6 +2875,10 @@
   // Iterators
   child_range children() { return child_range(&SubExpr, &SubExpr + 1); }
 };
+static_assert(
+    llvm::AlignOf<ExprWithCleanups>::Alignment >=
+        llvm::AlignOf<ExprWithCleanups::CleanupObject>::Alignment,
+    "Alignment is insufficient for objects appended to ExprWithCleanups");
 
 /// \brief Describes an explicit type conversion that uses functional
 /// notion but could not be resolved because one or more arguments are
@@ -2930,6 +2999,10 @@
     return child_range(begin, begin + NumArgs);
   }
 };
+static_assert(llvm::AlignOf<CXXUnresolvedConstructExpr>::Alignment >=
+                  llvm::AlignOf<Expr *>::Alignment,
+              "Alignment is insufficient for objects appended to "
+              "CXXUnresolvedConstructExpr");
 
 /// \brief Represents a C++ member access expression where the actual
 /// member referenced could not be resolved because the base
@@ -2938,7 +3011,8 @@
 /// Like UnresolvedMemberExprs, these can be either implicit or
 /// explicit accesses.  It is only possible to get one of these with
 /// an implicit access if a qualifier is provided.
-class CXXDependentScopeMemberExpr : public Expr {
+class LLVM_ALIGNAS(/*alignof(uint64_t)*/ 8) CXXDependentScopeMemberExpr
+    : public Expr {
   /// \brief The expression for the base pointer or class reference,
   /// e.g., the \c x in x.f.  Can be null in implicit accesses.
   Stmt *Base;
@@ -3177,6 +3251,10 @@
   friend class ASTStmtReader;
   friend class ASTStmtWriter;
 };
+static_assert(llvm::AlignOf<CXXDependentScopeMemberExpr>::Alignment >=
+                  llvm::AlignOf<ASTTemplateKWAndArgsInfo>::Alignment,
+              "Alignment is insufficient for objects appended to "
+              "CXXDependentScopeMemberExpr");
 
 /// \brief Represents a C++ member access expression for which lookup
 /// produced a set of overloaded functions.
@@ -3193,7 +3271,8 @@
 /// In the final AST, an explicit access always becomes a MemberExpr.
 /// An implicit access may become either a MemberExpr or a
 /// DeclRefExpr, depending on whether the member is static.
-class UnresolvedMemberExpr : public OverloadExpr {
+class LLVM_ALIGNAS(/*alignof(uint64_t)*/ 8) UnresolvedMemberExpr
+    : public OverloadExpr {
   /// \brief Whether this member expression used the '->' operator or
   /// the '.' operator.
   bool IsArrow : 1;
@@ -3316,6 +3395,21 @@
     return child_range(&Base, &Base + 1);
   }
 };
+static_assert(
+    llvm::AlignOf<UnresolvedMemberExpr>::Alignment >=
+        llvm::AlignOf<ASTTemplateKWAndArgsInfo>::Alignment,
+    "Alignment is insufficient for objects appended to UnresolvedMemberExpr");
+
+inline ASTTemplateKWAndArgsInfo *OverloadExpr::getTemplateKWAndArgsInfo() {
+  if (!HasTemplateKWAndArgsInfo)
+    return nullptr;
+  if (isa<UnresolvedLookupExpr>(this))
+    return reinterpret_cast<ASTTemplateKWAndArgsInfo *>(
+        cast<UnresolvedLookupExpr>(this) + 1);
+  else
+    return reinterpret_cast<ASTTemplateKWAndArgsInfo *>(
+        cast<UnresolvedMemberExpr>(this) + 1);
+}
 
 /// \brief Represents a C++11 noexcept expression (C++ [expr.unary.noexcept]).
 ///
@@ -3438,15 +3532,6 @@
   }
 };
 
-inline ASTTemplateKWAndArgsInfo *OverloadExpr::getTemplateKWAndArgsInfo() {
-  if (!HasTemplateKWAndArgsInfo) return nullptr;
-  if (isa<UnresolvedLookupExpr>(this))
-    return reinterpret_cast<ASTTemplateKWAndArgsInfo*>
-      (cast<UnresolvedLookupExpr>(this) + 1);
-  else
-    return reinterpret_cast<ASTTemplateKWAndArgsInfo*>
-      (cast<UnresolvedMemberExpr>(this) + 1);
-}
 
 /// \brief Represents an expression that computes the length of a parameter
 /// pack.
@@ -3709,6 +3794,10 @@
 
   child_range children() { return child_range(); }
 };
+static_assert(
+    llvm::AlignOf<FunctionParmPackExpr>::Alignment >=
+        llvm::AlignOf<ParmVarDecl *>::Alignment,
+    "Alignment is insufficient for objects appended to FunctionParmPackExpr");
 
 /// \brief Represents a prvalue temporary that is written into memory so that
 /// a reference can bind to it.
--- tools/clang/include/clang/AST/ExprObjC.h	2014-12-18 09:13:56.000000000 -0800
+++ tools/clang/include/clang/AST/ExprObjC.h	2015-07-17 16:43:46.499286743 -0700
@@ -201,6 +201,10 @@
     
   friend class ASTStmtReader;
 };
+static_assert(
+    llvm::AlignOf<ObjCArrayLiteral>::Alignment >=
+        llvm::AlignOf<Expr *>::Alignment,
+    "Alignment is insufficient for objects appended to ObjCArrayLiteral");
 
 /// \brief An element in an Objective-C dictionary literal.
 ///
@@ -231,6 +235,7 @@
 /// ObjCDictionaryLiteral - AST node to represent objective-c dictionary 
 /// literals; as in:  @{@"name" : NSUserName(), @"date" : [NSDate date] };
 class ObjCDictionaryLiteral : public Expr {
+public:
   /// \brief Key/value pair used to store the key and value of a given element.
   ///
   /// Objects of this type are stored directly after the expression.
@@ -251,6 +256,7 @@
     unsigned NumExpansionsPlusOne;
   };
 
+private:
   /// \brief The number of elements in this dictionary literal.
   unsigned NumElements : 31;
   
@@ -341,6 +347,7 @@
   child_range children() { 
     // Note: we're taking advantage of the layout of the KeyValuePair struct
     // here. If that struct changes, this code will need to change as well.
+    static_assert(sizeof(KeyValuePair) == sizeof(Stmt *) * 2, "");
     return child_range(reinterpret_cast<Stmt **>(this + 1),
                        reinterpret_cast<Stmt **>(this + 1) + NumElements * 2);
   }
@@ -348,7 +355,14 @@
   friend class ASTStmtReader;
   friend class ASTStmtWriter;
 };
-
+static_assert(
+    llvm::AlignOf<ObjCDictionaryLiteral>::Alignment >=
+        llvm::AlignOf<ObjCDictionaryLiteral::KeyValuePair>::Alignment,
+    "Alignment is insufficient for objects appended to ObjCDictionaryLiteral");
+static_assert(
+    llvm::AlignOf<ObjCDictionaryLiteral::KeyValuePair>::Alignment >=
+        llvm::AlignOf<ObjCDictionaryLiteral::ExpansionData>::Alignment,
+    "Alignment is insufficient for objects appended to ObjCDictionaryLiteral");
 
 /// ObjCEncodeExpr, used for \@encode in Objective-C.  \@encode has the same
 /// type and behavior as StringLiteral except that the string initializer is
@@ -1394,6 +1408,17 @@
   friend class ASTStmtReader;
   friend class ASTStmtWriter;
 };
+static_assert(
+    llvm::AlignOf<ObjCMessageExpr>::Alignment >=
+        llvm::AlignOf<void *>::Alignment,
+    "Alignment is insufficient for objects appended to ObjCMessageExpr");
+static_assert(
+    llvm::AlignOf<void *>::Alignment >= llvm::AlignOf<Expr *>::Alignment,
+    "Alignment is insufficient for objects appended to ObjCMessageExpr");
+static_assert(
+    llvm::AlignOf<Expr *>::Alignment >=
+        llvm::AlignOf<SourceLocation>::Alignment,
+    "Alignment is insufficient for objects appended to ObjCMessageExpr");
 
 /// ObjCIsaExpr - Represent X->isa and X.isa when X is an ObjC 'id' type.
 /// (similar in spirit to MemberExpr).
--- tools/clang/include/clang/AST/Stmt.h	2015-01-12 02:17:46.000000000 -0800
+++ tools/clang/include/clang/AST/Stmt.h	2015-07-17 16:43:46.502138721 -0700
@@ -865,7 +865,10 @@
     return T->getStmtClass() == AttributedStmtClass;
   }
 };
-
+static_assert(
+    llvm::AlignOf<AttributedStmt>::Alignment >=
+        llvm::AlignOf<Attr *>::Alignment,
+    "Alignment is insufficient for objects appended to AttributedStmt");
 
 /// IfStmt - This represents an if/then/else.
 ///
@@ -2070,8 +2073,10 @@
   /// \brief Construct an empty captured statement.
   CapturedStmt(EmptyShell Empty, unsigned NumCaptures);
 
-  Stmt **getStoredStmts() const {
-    return reinterpret_cast<Stmt **>(const_cast<CapturedStmt *>(this) + 1);
+  Stmt **getStoredStmts() { return reinterpret_cast<Stmt **>(this + 1); }
+
+  Stmt *const *getStoredStmts() const {
+    return reinterpret_cast<Stmt *const *>(this + 1);
   }
 
   Capture *getStoredCaptures() const;
@@ -2090,14 +2095,12 @@
 
   /// \brief Retrieve the statement being captured.
   Stmt *getCapturedStmt() { return getStoredStmts()[NumCaptures]; }
-  const Stmt *getCapturedStmt() const {
-    return const_cast<CapturedStmt *>(this)->getCapturedStmt();
-  }
+  const Stmt *getCapturedStmt() const { return getStoredStmts()[NumCaptures]; }
 
   /// \brief Retrieve the outlined function declaration.
   CapturedDecl *getCapturedDecl() { return CapDeclAndKind.getPointer(); }
   const CapturedDecl *getCapturedDecl() const {
-    return const_cast<CapturedStmt *>(this)->getCapturedDecl();
+    return CapDeclAndKind.getPointer();
   }
 
   /// \brief Set the outlined function declaration.
@@ -2158,18 +2161,36 @@
   typedef Expr **capture_init_iterator;
   typedef llvm::iterator_range<capture_init_iterator> capture_init_range;
 
-  capture_init_range capture_inits() const {
+  /// \brief Const iterator that walks over the capture initialization
+  /// arguments.
+  typedef Expr *const *const_capture_init_iterator;
+  typedef llvm::iterator_range<const_capture_init_iterator>
+      const_capture_init_range;
+
+  capture_init_range capture_inits() {
     return capture_init_range(capture_init_begin(), capture_init_end());
   }
 
+  const_capture_init_range capture_inits() const {
+    return const_capture_init_range(capture_init_begin(), capture_init_end());
+  }
+
   /// \brief Retrieve the first initialization argument.
-  capture_init_iterator capture_init_begin() const {
+  capture_init_iterator capture_init_begin() {
     return reinterpret_cast<Expr **>(getStoredStmts());
   }
 
+  const_capture_init_iterator capture_init_begin() const {
+    return reinterpret_cast<Expr *const *>(getStoredStmts());
+  }
+
   /// \brief Retrieve the iterator pointing one past the last initialization
   /// argument.
-  capture_init_iterator capture_init_end() const {
+  capture_init_iterator capture_init_end() {
+    return capture_init_begin() + NumCaptures;
+  }
+
+  const_capture_init_iterator capture_init_end() const {
     return capture_init_begin() + NumCaptures;
   }
 
@@ -2191,6 +2212,13 @@
 
   friend class ASTStmtReader;
 };
+static_assert(llvm::AlignOf<CapturedStmt>::Alignment >=
+                  llvm::AlignOf<Stmt *>::Alignment,
+              "Alignment is insufficient for objects appended to CapturedStmt");
+// Code re-aligns before Capture[]
+static_assert(llvm::AlignOf<CapturedStmt>::Alignment >=
+                  llvm::AlignOf<CapturedStmt::Capture>::Alignment,
+              "Alignment is insufficient for objects appended to CapturedStmt");
 
 }  // end namespace clang
 
--- tools/clang/include/clang/AST/StmtCXX.h	2014-05-05 23:48:52.000000000 -0700
+++ tools/clang/include/clang/AST/StmtCXX.h	2015-07-17 16:43:46.503758907 -0700
@@ -118,6 +118,9 @@
 
   friend class ASTStmtReader;
 };
+static_assert(llvm::AlignOf<CXXTryStmt>::Alignment >=
+                  llvm::AlignOf<Stmt *>::Alignment,
+              "Alignment is insufficient for objects appended to CXXTryStmt");
 
 /// CXXForRangeStmt - This represents C++0x [stmt.ranged]'s ranged for
 /// statement, represented as 'for (range-declarator : range-expression)'.
--- tools/clang/include/clang/AST/StmtObjC.h	2014-05-05 23:48:52.000000000 -0700
+++ tools/clang/include/clang/AST/StmtObjC.h	2015-07-17 16:43:46.505254168 -0700
@@ -249,6 +249,9 @@
                        getStmts() + 1 + NumCatchStmts + HasFinally);
   }
 };
+static_assert(
+    llvm::AlignOf<ObjCAtTryStmt>::Alignment >= llvm::AlignOf<Stmt *>::Alignment,
+    "Alignment is insufficient for objects appended to ObjCAtTryStmt");
 
 /// \brief Represents Objective-C's \@synchronized statement.
 ///
--- tools/clang/include/clang/AST/TemplateBase.h	2015-01-14 03:29:14.000000000 -0800
+++ tools/clang/include/clang/AST/TemplateBase.h	2015-07-17 16:43:46.506876445 -0700
@@ -360,6 +360,20 @@
   void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context) const;
 };
 
+static_assert(llvm::AlignOf<TemplateSpecializationType>::Alignment >=
+                  llvm::AlignOf<TemplateArgument>::Alignment,
+              "Alignment is insufficient for objects appended to "
+              "TemplateSpecializationType");
+static_assert(llvm::AlignOf<TemplateArgument>::Alignment >=
+                  llvm::AlignOf<QualType>::Alignment,
+              "Alignment is insufficient for objects appended to "
+              "TemplateSpecializationType");
+
+static_assert(llvm::AlignOf<DependentTemplateSpecializationType>::Alignment >=
+                  llvm::AlignOf<TemplateArgument>::Alignment,
+              "Alignment is insufficient for objects appended to "
+              "DependentTemplateSpecializationType");
+
 /// Location information for a TemplateArgument.
 struct TemplateArgumentLocInfo {
 private:
@@ -604,6 +618,10 @@
   void copyInto(TemplateArgumentListInfo &List) const;
   static std::size_t sizeFor(unsigned NumTemplateArgs);
 };
+static_assert(llvm::AlignOf<ASTTemplateArgumentListInfo>::Alignment >=
+                  llvm::AlignOf<TemplateArgumentLoc>::Alignment,
+              "Alignment is insufficient for objects appended to "
+              "ASTTemplateArgumentListInfo");
 
 /// \brief Extends ASTTemplateArgumentListInfo with the source location
 /// information for the template keyword; this is used as part of the
@@ -640,6 +658,18 @@
 
   static std::size_t sizeFor(unsigned NumTemplateArgs);
 };
+static_assert(llvm::AlignOf<ASTTemplateKWAndArgsInfo>::Alignment >=
+                  llvm::AlignOf<TemplateArgumentLoc>::Alignment,
+              "Alignment is insufficient for objects appended to "
+              "ASTTemplateKWAndArgsInfo");
+static_assert(llvm::AlignOf<ASTTemplateKWAndArgsInfo>::Alignment >=
+                  llvm::AlignOf<SourceLocation>::Alignment,
+              "Alignment is insufficient for objects appended to "
+              "ASTTemplateKWAndArgsInfo");
+static_assert(llvm::AlignOf<TemplateArgumentLoc>::Alignment >=
+                  llvm::AlignOf<SourceLocation>::Alignment,
+              "Alignment is insufficient for objects appended to "
+              "ASTTemplateKWAndArgsInfo");
 
 const DiagnosticBuilder &operator<<(const DiagnosticBuilder &DB,
                                     const TemplateArgument &Arg);
--- tools/clang/include/clang/AST/TemplateName.h	2014-05-10 13:57:56.000000000 -0700
+++ tools/clang/include/clang/AST/TemplateName.h	2015-07-17 16:43:46.508333537 -0700
@@ -108,6 +108,10 @@
   iterator begin() const { return getStorage(); }
   iterator end() const { return getStorage() + size(); }
 };
+static_assert(llvm::AlignOf<OverloadedTemplateStorage>::Alignment >=
+                  llvm::AlignOf<NamedDecl *>::Alignment,
+              "Alignment is insufficient for objects appended to "
+              "OverloadedTemplateStorage");
 
 /// \brief A structure for storing an already-substituted template template
 /// parameter pack.
--- tools/clang/include/clang/AST/Type.h	2015-01-14 03:29:14.000000000 -0800
+++ tools/clang/include/clang/AST/Type.h	2015-07-17 16:43:46.512517865 -0700
@@ -2991,11 +2991,13 @@
     assert(hasAnyConsumedParams());
 
     // Find the end of the exceptions.
-    Expr *const *eh_end = reinterpret_cast<Expr *const *>(param_type_end());
-    if (getExceptionSpecType() != EST_ComputedNoexcept)
-      eh_end += NumExceptions;
-    else
+    Expr *const *eh_end = reinterpret_cast<Expr *const *>(exception_end());
+    if (getExceptionSpecType() == EST_ComputedNoexcept)
       eh_end += 1; // NoexceptExpr
+    // The memory layout of these types isn't handled here, so
+    // hopefully this is never called for them?
+    assert(getExceptionSpecType() != EST_Uninstantiated &&
+           getExceptionSpecType() != EST_Unevaluated);
 
     return reinterpret_cast<const bool*>(eh_end);
   }
@@ -3167,7 +3169,29 @@
                       param_type_iterator ArgTys, unsigned NumArgs,
                       const ExtProtoInfo &EPI, const ASTContext &Context);
 };
-
+static_assert(
+    llvm::AlignOf<FunctionProtoType>::Alignment >=
+        llvm::AlignOf<QualType>::Alignment,
+    "Alignment is insufficient for objects appended to FunctionProtoType");
+// After QualType[], there can be one of 4 options: more QualType, Expr*, 2x
+// FunctionDecl*, FunctionDecl*
+static_assert(
+    llvm::AlignOf<QualType>::Alignment >= llvm::AlignOf<Expr *>::Alignment,
+    "Alignment is insufficient for objects appended to FunctionProtoType");
+static_assert(
+    llvm::AlignOf<QualType>::Alignment >=
+        llvm::AlignOf<FunctionDecl *>::Alignment,
+    "Alignment is insufficient for objects appended to FunctionProtoType");
+// And then, after any of those options, comes bool[]
+static_assert(
+    llvm::AlignOf<QualType>::Alignment >= llvm::AlignOf<bool>::Alignment,
+    "Alignment is insufficient for objects appended to FunctionProtoType");
+static_assert(
+    llvm::AlignOf<Expr *>::Alignment >= llvm::AlignOf<bool>::Alignment,
+    "Alignment is insufficient for objects appended to FunctionProtoType");
+static_assert(
+    llvm::AlignOf<FunctionDecl *>::Alignment >= llvm::AlignOf<bool>::Alignment,
+    "Alignment is insufficient for objects appended to FunctionProtoType");
 
 /// \brief Represents the dependent type named by a dependently-scoped
 /// typename using declaration, e.g.
@@ -3777,8 +3801,9 @@
 /// TemplateArguments, followed by a QualType representing the
 /// non-canonical aliased type when the template is a type alias
 /// template.
-class TemplateSpecializationType
-  : public Type, public llvm::FoldingSetNode {
+class LLVM_ALIGNAS(/*alignof(uint64_t)*/ 8) TemplateSpecializationType
+    : public Type,
+      public llvm::FoldingSetNode {
   /// \brief The name of the template being specialized.  This is
   /// either a TemplateName::Template (in which case it is a
   /// ClassTemplateDecl*, a TemplateTemplateParmDecl*, or a
@@ -3900,6 +3925,13 @@
     return T->getTypeClass() == TemplateSpecialization;
   }
 };
+// static_assert(llvm::AlignOf<TemplateSpecializationType>::Alignment >=
+// llvm::AlignOf<TemplateArgument>::Alignment, "Alignment is insufficient for
+// objects appended to TemplateSpecializationType");
+// static_assert(llvm::AlignOf<TemplateArgument>::Alignment >=
+// llvm::AlignOf<QualType>::Alignment, "Alignment is insufficient for objects
+// appended to TemplateSpecializationType");
+// ^ Moved after class TemplateArgument, as it is is forward declared here.
 
 /// \brief The injected class name of a C++ class template or class
 /// template partial specialization.  Used to record that a type was
@@ -4175,8 +4207,9 @@
 /// DependentTemplateSpecializationType - Represents a template
 /// specialization type whose template cannot be resolved, e.g.
 ///   A<T>::template B<T>
-class DependentTemplateSpecializationType :
-  public TypeWithKeyword, public llvm::FoldingSetNode {
+class LLVM_ALIGNAS(/*alignof(uint64_t)*/ 8) DependentTemplateSpecializationType
+    : public TypeWithKeyword,
+      public llvm::FoldingSetNode {
 
   /// \brief The nested name specifier containing the qualifier.
   NestedNameSpecifier *NNS;
@@ -4241,6 +4274,10 @@
     return T->getTypeClass() == DependentTemplateSpecialization;
   }
 };
+// static_assert(llvm::AlignOf<DependentTemplateSpecializationType>::Alignment
+// >= llvm::AlignOf<TemplateArgument>::Alignment, "Alignment is insufficient for
+// objects appended to DependentTemplateSpecializationType");
+// ^ Moved after class TemplateArgument, as it is is forward declared here.
 
 /// \brief Represents a pack expansion of types.
 ///
@@ -4456,6 +4493,10 @@
                       ObjCProtocolDecl *const *protocols,
                       unsigned NumProtocols);
 };
+static_assert(
+    llvm::AlignOf<ObjCObjectTypeImpl>::Alignment >=
+        llvm::AlignOf<ObjCProtocolDecl *>::Alignment,
+    "Alignment is insufficient for objects appended to ObjCObjectTypeImpl");
 
 inline ObjCProtocolDecl **ObjCObjectType::getProtocolStorage() {
   return reinterpret_cast<ObjCProtocolDecl**>(
--- tools/clang/include/clang/AST/TypeLoc.h	2014-10-24 06:52:55.000000000 -0700
+++ tools/clang/include/clang/AST/TypeLoc.h	2015-07-17 16:43:46.514327822 -0700
@@ -199,6 +199,7 @@
 
 /// \brief Return the TypeLoc for a type source info.
 inline TypeLoc TypeSourceInfo::getTypeLoc() const {
+  // TODO: is this alignment already sufficient?
   return TypeLoc(Ty, const_cast<void*>(static_cast<const void*>(this + 1)));
 }
 
--- tools/clang/include/clang/CodeGen/CGFunctionInfo.h	2014-12-12 15:41:25.000000000 -0800
+++ tools/clang/include/clang/CodeGen/CGFunctionInfo.h	2015-07-17 16:43:46.515714903 -0700
@@ -333,11 +333,13 @@
 /// CGFunctionInfo - Class to encapsulate the information about a
 /// function definition.
 class CGFunctionInfo : public llvm::FoldingSetNode {
+public:
   struct ArgInfo {
     CanQualType type;
     ABIArgInfo info;
   };
 
+private:
   /// The LLVM::CallingConv to use for this function (as specified by the
   /// user).
   unsigned CallingConvention : 8;
@@ -500,6 +502,10 @@
     }
   }
 };
+static_assert(
+    llvm::AlignOf<CGFunctionInfo>::Alignment >=
+        llvm::AlignOf<CGFunctionInfo::ArgInfo>::Alignment,
+    "Alignment is insufficient for objects appended to CGFunctionInfo");
 
 }  // end namespace CodeGen
 }  // end namespace clang
--- tools/clang/include/clang/Lex/MacroArgs.h	2014-08-13 12:25:19.000000000 -0400
+++ tools/clang/include/clang/Lex/MacroArgs.h	2015-07-17 22:23:39.000000000 -0400
@@ -15,13 +15,13 @@
 #define LLVM_CLANG_LEX_MACROARGS_H
 
 #include "clang/Basic/LLVM.h"
+#include "clang/Lex/Token.h"
 #include "llvm/ADT/ArrayRef.h"
 #include <vector>
 
 namespace clang {
   class MacroInfo;
   class Preprocessor;
-  class Token;
   class SourceLocation;
 
 /// MacroArgs - An instance of this class captures information about
@@ -120,6 +120,9 @@
   /// its freelist.
   MacroArgs *deallocate();
 };
+static_assert(llvm::AlignOf<MacroArgs>::Alignment >=
+                  llvm::AlignOf<Token>::Alignment,
+              "Alignment is insufficient for objects appended to MacroArgs");
 
 }  // end namespace clang
 
--- tools/clang/include/clang/Lex/MacroInfo.h	2014-08-13 12:25:19.000000000 -0400
+++ tools/clang/include/clang/Lex/MacroInfo.h	2015-07-18 01:52:39.590867365 -0400
@@ -17,11 +17,15 @@
 
 #include "clang/Lex/Token.h"
 #include "llvm/ADT/ArrayRef.h"
+#include "llvm/ADT/FoldingSet.h"
+#include "llvm/ADT/PointerIntPair.h"
 #include "llvm/ADT/SmallVector.h"
 #include "llvm/Support/Allocator.h"
 #include <cassert>
 
 namespace clang {
+class Module;
+class ModuleMacro;
 class Preprocessor;
 
 /// \brief Encapsulates the data about a macro definition (e.g. its tokens).
@@ -294,6 +298,9 @@
 
   friend class Preprocessor;
 };
+static_assert(llvm::AlignOf<MacroInfo>::Alignment >=
+                  llvm::AlignOf<unsigned>::Alignment,
+              "Alignment is insufficient for objects appended to MacroInfo");
 
 class DefMacroDirective;
 
@@ -517,6 +524,75 @@
   static bool classof(const DefMacroDirective *) { return true; }
 };
 
+/// \brief Represents a macro directive exported by a module.
+///
+/// There's an instance of this class for every macro #define or #undef that is
+/// the final directive for a macro name within a module. These entities also
+/// represent the macro override graph.
+///
+/// These are stored in a FoldingSet in the preprocessor.
+class ModuleMacro : public llvm::FoldingSetNode {
+  /// The name defined by the macro.
+  IdentifierInfo *II;
+  /// The body of the #define, or nullptr if this is a #undef.
+  MacroInfo *Macro;
+  /// The module that exports this macro.
+  Module *OwningModule;
+  /// The number of module macros that override this one.
+  unsigned NumOverriddenBy;
+  /// The number of modules whose macros are directly overridden by this one.
+  unsigned NumOverrides;
+  // ModuleMacro *OverriddenMacros[NumOverrides];
+
+  friend class Preprocessor;
+
+  ModuleMacro(Module *OwningModule, IdentifierInfo *II, MacroInfo *Macro,
+              ArrayRef<ModuleMacro *> Overrides)
+      : II(II), Macro(Macro), OwningModule(OwningModule), NumOverriddenBy(0),
+        NumOverrides(Overrides.size()) {
+    std::copy(Overrides.begin(), Overrides.end(),
+              reinterpret_cast<ModuleMacro **>(this + 1));
+  }
+
+public:
+  static ModuleMacro *create(Preprocessor &PP, Module *OwningModule,
+                             IdentifierInfo *II, MacroInfo *Macro,
+                             ArrayRef<ModuleMacro *> Overrides);
+
+  void Profile(llvm::FoldingSetNodeID &ID) const {
+    return Profile(ID, OwningModule, II);
+  }
+  static void Profile(llvm::FoldingSetNodeID &ID, Module *OwningModule,
+                      IdentifierInfo *II) {
+    ID.AddPointer(OwningModule);
+    ID.AddPointer(II);
+  }
+
+  /// Get the ID of the module that exports this macro.
+  Module *getOwningModule() const { return OwningModule; }
+
+  /// Get definition for this exported #define, or nullptr if this
+  /// represents a #undef.
+  MacroInfo *getMacroInfo() const { return Macro; }
+
+  /// Iterators over the overridden module IDs.
+  /// \{
+  typedef ModuleMacro *const *overrides_iterator;
+  overrides_iterator overrides_begin() const {
+    return reinterpret_cast<overrides_iterator>(this + 1);
+  }
+  overrides_iterator overrides_end() const {
+    return overrides_begin() + NumOverrides;
+  }
+  ArrayRef<ModuleMacro *> overrides() const {
+    return llvm::makeArrayRef(overrides_begin(), overrides_end());
+  }
+  /// \}
+
+  /// Get the number of macros that override this one.
+  unsigned getNumOverridingMacros() const { return NumOverriddenBy; }
+};
+
 /// \brief A directive for an undefined macro.
 class UndefMacroDirective : public MacroDirective  {
 public:
@@ -550,6 +626,9 @@
   }
   static bool classof(const VisibilityMacroDirective *) { return true; }
 };
+static_assert(llvm::AlignOf<ModuleMacro>::Alignment >=
+                  llvm::AlignOf<ModuleMacro *>::Alignment,
+              "Alignment is insufficient for objects appended to ModuleMacro");
 
 inline unsigned *MacroDirective::getModuleDataStart() {
   if (auto *Def = dyn_cast<DefMacroDirective>(this))
--- tools/clang/include/clang/Sema/AttributeList.h	2015-01-20 11:27:49.000000000 -0800
+++ tools/clang/include/clang/Sema/AttributeList.h	2015-07-17 16:43:46.520539511 -0700
@@ -135,9 +135,7 @@
   AttributeList *NextInPool;
 
   /// Arguments, if any, are stored immediately following the object.
-  ArgsUnion *getArgsBuffer() {
-    return reinterpret_cast<ArgsUnion*>(this+1);
-  }
+  ArgsUnion *getArgsBuffer() { return reinterpret_cast<ArgsUnion *>(this + 1); }
   ArgsUnion const *getArgsBuffer() const {
     return reinterpret_cast<ArgsUnion const *>(this+1);
   }
@@ -468,6 +466,26 @@
   /// a Spelling enumeration, the value UINT_MAX is returned.
   unsigned getSemanticSpelling() const;
 };
+static_assert(
+    llvm::AlignOf<AttributeList>::Alignment >=
+        llvm::AlignOf<ArgsUnion>::Alignment,
+    "Alignment is insufficient for objects appended to AttributeList");
+static_assert(
+    llvm::AlignOf<ArgsUnion>::Alignment >=
+        llvm::AlignOf<AvailabilityChange>::Alignment,
+    "Alignment is insufficient for objects appended to AttributeList");
+static_assert(
+    llvm::AlignOf<ArgsUnion>::Alignment >=
+        llvm::AlignOf<AttributeList::TypeTagForDatatypeData>::Alignment,
+    "Alignment is insufficient for objects appended to AttributeList");
+static_assert(
+    llvm::AlignOf<AttributeList>::Alignment >=
+        llvm::AlignOf<ParsedType>::Alignment,
+    "Alignment is insufficient for objects appended to AttributeList");
+static_assert(
+    llvm::AlignOf<AttributeList>::Alignment >=
+        llvm::AlignOf<AttributeList::PropertyData>::Alignment,
+    "Alignment is insufficient for objects appended to AttributeList");
 
 /// A factory, from which one makes pools, from which one creates
 /// individual attributes which are deallocated with the pool.
--- tools/clang/include/clang/Sema/CodeCompleteConsumer.h	2014-05-05 23:48:52.000000000 -0700
+++ tools/clang/include/clang/Sema/CodeCompleteConsumer.h	2015-07-17 16:43:46.522097320 -0700
@@ -493,6 +493,14 @@
   /// which is mainly useful for debugging.
   std::string getAsString() const;
 };
+static_assert(
+    llvm::AlignOf<CodeCompletionString>::Alignment >=
+        llvm::AlignOf<CodeCompletionString::Chunk>::Alignment,
+    "Alignment is insufficient for objects appended to CodeCompletionString");
+static_assert(
+    llvm::AlignOf<CodeCompletionString::Chunk>::Alignment >=
+        llvm::AlignOf<const char *>::Alignment,
+    "Alignment is insufficient for objects appended to CodeCompletionString");
 
 /// \brief An allocator used specifically for the purpose of code completion.
 class CodeCompletionAllocator : public llvm::BumpPtrAllocator {
--- tools/clang/include/clang/Sema/ParsedTemplate.h	2014-05-05 23:48:52.000000000 -0700
+++ tools/clang/include/clang/Sema/ParsedTemplate.h	2015-07-17 16:43:46.523177530 -0700
@@ -205,6 +205,10 @@
       free(this); 
     }
   };
+  static_assert(
+      llvm::AlignOf<TemplateIdAnnotation>::Alignment >=
+          llvm::AlignOf<ParsedTemplateArgument>::Alignment,
+      "Alignment is insufficient for objects appended to TemplateIdAnnotation");
 
   /// Retrieves the range of the given template parameter lists.
   SourceRange getTemplateParamsRange(TemplateParameterList const *const *Params,
--- tools/clang/lib/AST/Decl.cpp	2015-05-04 11:23:59.000000000 -0700
+++ tools/clang/lib/AST/Decl.cpp	2015-07-17 16:43:46.525788978 -0700
@@ -3064,8 +3064,8 @@
                              const TemplateArgumentListInfo &TemplateArgs) {
   assert(TemplateOrSpecialization.isNull());
   size_t Size = sizeof(DependentFunctionTemplateSpecializationInfo);
-  Size += Templates.size() * sizeof(FunctionTemplateDecl*);
   Size += TemplateArgs.size() * sizeof(TemplateArgumentLoc);
+  Size += Templates.size() * sizeof(FunctionTemplateDecl *);
   void *Buffer = Context.Allocate(Size);
   DependentFunctionTemplateSpecializationInfo *Info =
     new (Buffer) DependentFunctionTemplateSpecializationInfo(Templates,
@@ -3078,8 +3078,8 @@
                                       const TemplateArgumentListInfo &TArgs)
   : AngleLocs(TArgs.getLAngleLoc(), TArgs.getRAngleLoc()) {
 
-  d.NumTemplates = Ts.size();
-  d.NumArgs = TArgs.size();
+  NumTemplates = Ts.size();
+  NumArgs = TArgs.size();
 
   FunctionTemplateDecl **TsArray =
     const_cast<FunctionTemplateDecl**>(getTemplates());
--- tools/clang/lib/AST/DeclBase.cpp	2014-11-17 15:36:45.000000000 -0800
+++ tools/clang/lib/AST/DeclBase.cpp	2015-07-17 17:03:06.999226816 -0700
@@ -45,14 +45,28 @@
   getASTContext().getExternalSource()->updateOutOfDateIdentifier(II);
 }
 
+#define DECL(DERIVED, BASE)                                                    \
+  static_assert(llvm::AlignOf<uint64_t>::Alignment >=                          \
+                    llvm::AlignOf<DERIVED##Decl>::Alignment,                   \
+                "Alignment is insufficient for objects appended to all Decl "  \
+                "subclasses");
+#define ABSTRACT_DECL(DECL)
+#include "clang/AST/DeclNodes.inc"
+
 void *Decl::operator new(std::size_t Size, const ASTContext &Context,
                          unsigned ID, std::size_t Extra) {
   // Allocate an extra 8 bytes worth of storage, which ensures that the
   // resulting pointer will still be 8-byte aligned. 
-  void *Start = Context.Allocate(Size + Extra + 8);
-  void *Result = (char*)Start + 8;
+  static_assert(sizeof(unsigned) * 2 >= llvm::AlignOf<uint64_t>::Alignment,
+      "sizeof(unsigned) * 2 < llvm::AlignOf<uint64_t>::Alignment!");
+
+  void *Start = Context.Allocate(Size + Extra + 8, 8U);
+  void *Result = reinterpret_cast<void*>(
+      reinterpret_cast<unsigned char*>(
+        reinterpret_cast<unsigned char*>(Start) + 8));
 
-  unsigned *PrefixPtr = (unsigned *)Result - 2;
+  unsigned *PrefixPtr =
+    reinterpret_cast<unsigned*>(reinterpret_cast<unsigned*>(Result) - 2);
 
   // Zero out the first 4 bytes; this is used to store the owning module ID.
   PrefixPtr[0] = 0;
--- tools/clang/lib/AST/Expr.cpp	2015-01-12 02:17:46.000000000 -0800
+++ tools/clang/lib/AST/Expr.cpp	2015-07-17 16:43:46.530620842 -0700
@@ -399,10 +399,15 @@
     Size += sizeof(NestedNameSpecifierLoc);
   if (FoundD)
     Size += sizeof(NamedDecl *);
-  if (TemplateArgs)
+  if (TemplateArgs) {
+    Size = llvm::RoundUpToAlignment(Size,
+                                    llvm::alignOf<ASTTemplateKWAndArgsInfo>());
     Size += ASTTemplateKWAndArgsInfo::sizeFor(TemplateArgs->size());
-  else if (TemplateKWLoc.isValid())
+  } else if (TemplateKWLoc.isValid()) {
+    Size = llvm::RoundUpToAlignment(Size,
+                                    llvm::alignOf<ASTTemplateKWAndArgsInfo>());
     Size += ASTTemplateKWAndArgsInfo::sizeFor(0);
+  }
 
   void *Mem = Context.Allocate(Size, llvm::alignOf<DeclRefExpr>());
   return new (Mem) DeclRefExpr(Context, QualifierLoc, TemplateKWLoc, D,
@@ -420,8 +425,11 @@
     Size += sizeof(NestedNameSpecifierLoc);
   if (HasFoundDecl)
     Size += sizeof(NamedDecl *);
-  if (HasTemplateKWAndArgsInfo)
+  if (HasTemplateKWAndArgsInfo) {
+    Size = llvm::RoundUpToAlignment(Size,
+                                    llvm::alignOf<ASTTemplateKWAndArgsInfo>());
     Size += ASTTemplateKWAndArgsInfo::sizeFor(NumTemplateArgs);
+  }
 
   void *Mem = Context.Allocate(Size, llvm::alignOf<DeclRefExpr>());
   return new (Mem) DeclRefExpr(EmptyShell());
@@ -3871,7 +3879,8 @@
                            SourceLocation ColonOrEqualLoc,
                            bool UsesColonSyntax, Expr *Init) {
   void *Mem = C.Allocate(sizeof(DesignatedInitExpr) +
-                         sizeof(Stmt *) * (IndexExprs.size() + 1), 8);
+                             sizeof(Stmt *) * (IndexExprs.size() + 1),
+                         llvm::alignOf<DesignatedInitExpr>());
   return new (Mem) DesignatedInitExpr(C, C.VoidTy, NumDesignators, Designators,
                                       ColonOrEqualLoc, UsesColonSyntax,
                                       IndexExprs, Init);
--- tools/clang/lib/AST/ExprCXX.cpp	2014-09-25 17:28:20.000000000 -0700
+++ tools/clang/lib/AST/ExprCXX.cpp	2015-07-17 16:43:46.532400798 -0700
@@ -1070,14 +1070,14 @@
 }
 
 ArrayRef<VarDecl *> 
-LambdaExpr::getCaptureInitIndexVars(capture_init_iterator Iter) const {
+LambdaExpr::getCaptureInitIndexVars(const_capture_init_iterator Iter) const {
   assert(HasArrayIndexVars && "No array index-var data?");
   
   unsigned Index = Iter - capture_init_begin();
   assert(Index < getLambdaClass()->getLambdaData().NumCaptures &&
          "Capture index out-of-range");
-  VarDecl **IndexVars = getArrayIndexVars();
-  unsigned *IndexStarts = getArrayIndexStarts();
+  VarDecl *const *IndexVars = getArrayIndexVars();
+  const unsigned *IndexStarts = getArrayIndexStarts();
   return llvm::makeArrayRef(IndexVars + IndexStarts[Index],
                             IndexVars + IndexStarts[Index + 1]);
 }
@@ -1098,8 +1098,12 @@
 }
 
 CompoundStmt *LambdaExpr::getBody() const {
+  // FIXME: this mutation in getBody is bogus. It should be
+  // initialized in ASTStmtReader::VisitLambdaExpr, but for reasons I
+  // don't understand, that doesn't work.
   if (!getStoredStmts()[NumCaptures])
-    getStoredStmts()[NumCaptures] = getCallOperator()->getBody();
+    *const_cast<clang::Stmt **>(&getStoredStmts()[NumCaptures]) =
+        getCallOperator()->getBody();
     
   return reinterpret_cast<CompoundStmt *>(getStoredStmts()[NumCaptures]);
 }
--- tools/clang/lib/AST/Stmt.cpp	2014-12-14 23:07:06.000000000 -0800
+++ tools/clang/lib/AST/Stmt.cpp	2015-07-17 16:43:46.536947418 -0700
@@ -816,7 +816,7 @@
 CXXTryStmt *CXXTryStmt::Create(const ASTContext &C, SourceLocation tryLoc,
                                Stmt *tryBlock, ArrayRef<Stmt*> handlers) {
   std::size_t Size = sizeof(CXXTryStmt);
-  Size += ((handlers.size() + 1) * sizeof(Stmt));
+  Size += ((handlers.size() + 1) * sizeof(Stmt *));
 
   void *Mem = C.Allocate(Size, llvm::alignOf<CXXTryStmt>());
   return new (Mem) CXXTryStmt(tryLoc, tryBlock, handlers);
@@ -825,7 +825,7 @@
 CXXTryStmt *CXXTryStmt::Create(const ASTContext &C, EmptyShell Empty,
                                unsigned numHandlers) {
   std::size_t Size = sizeof(CXXTryStmt);
-  Size += ((numHandlers + 1) * sizeof(Stmt));
+  Size += ((numHandlers + 1) * sizeof(Stmt *));
 
   void *Mem = C.Allocate(Size, llvm::alignOf<CXXTryStmt>());
   return new (Mem) CXXTryStmt(Empty, numHandlers);
@@ -2027,4 +2027,3 @@
       C.Allocate(Size + sizeof(OMPClause *) * NumClauses + sizeof(Stmt *));
   return new (Mem) OMPTeamsDirective(NumClauses);
 }
-
--- tools/clang/lib/Basic/IdentifierTable.cpp	2014-12-11 04:18:08.000000000 -0800
+++ tools/clang/lib/Basic/IdentifierTable.cpp	2015-07-17 16:43:46.538457921 -0700
@@ -376,6 +376,11 @@
     Profile(ID, keyword_begin(), getNumArgs());
   }
 };
+static_assert(
+    llvm::AlignOf<MultiKeywordSelector>::Alignment >=
+        llvm::AlignOf<IdentifierInfo *>::Alignment,
+    "Alignment is insufficient for objects appended to MultiKeywordSelector");
+
 } // end namespace clang.
 
 unsigned Selector::getNumArgs() const {
--- tools/clang/lib/CodeGen/CGCleanup.h	2014-11-18 23:49:47.000000000 -0800
+++ tools/clang/lib/CodeGen/CGCleanup.h	2015-07-17 16:43:46.540112662 -0700
@@ -211,9 +211,12 @@
     return Scope->getKind() == Catch;
   }
 };
+static_assert(llvm::AlignOf<EHCatchScope>::Alignment >=
+                  llvm::AlignOf<EHCatchScope::Handler *>::Alignment,
+              "Alignment is insufficient for objects appended to EHCatchScope");
 
 /// A cleanup scope which generates the cleanup blocks lazily.
-class EHCleanupScope : public EHScope {
+class LLVM_ALIGNAS(/*alignof(uint64_t)*/ 8) EHCleanupScope : public EHScope {
   /// The nearest normal cleanup scope enclosing this one.
   EHScopeStack::stable_iterator EnclosingNormal;
 
@@ -391,6 +394,13 @@
     return (Scope->getKind() == Cleanup);
   }
 };
+// Assert objects tacked on the end of EHCleanupScope won't be
+// misaligned.  NOTE: there's actually a bunch of different data
+// classes tacked on, so let's just ensure alignment good enough for
+// uint64_t bytes.
+static_assert(llvm::AlignOf<EHCleanupScope>::Alignment >=
+                  llvm::AlignOf<uint64_t>::Alignment,
+              "");
 
 /// An exceptions scope which filters exceptions thrown through it.
 /// Only exceptions matching the filter types will be permitted to be
@@ -435,6 +445,10 @@
     return scope->getKind() == Filter;
   }
 };
+static_assert(
+    llvm::AlignOf<EHFilterScope>::Alignment >=
+        llvm::AlignOf<llvm::Value *>::Alignment,
+    "Alignment is insufficient for objects appended to EHFilterScope");
 
 /// An exceptions scope which calls std::terminate if any exception
 /// reaches it.
@@ -467,27 +481,27 @@
   EHScope &operator*() const { return *get(); }
 
   iterator &operator++() {
+    size_t Size;
     switch (get()->getKind()) {
     case EHScope::Catch:
-      Ptr += EHCatchScope::getSizeForNumHandlers(
+      Size = EHCatchScope::getSizeForNumHandlers(
           static_cast<const EHCatchScope*>(get())->getNumHandlers());
       break;
 
     case EHScope::Filter:
-      Ptr += EHFilterScope::getSizeForNumFilters(
+      Size = EHFilterScope::getSizeForNumFilters(
           static_cast<const EHFilterScope*>(get())->getNumFilters());
       break;
 
     case EHScope::Cleanup:
-      Ptr += static_cast<const EHCleanupScope*>(get())
-        ->getAllocatedSize();
+      Size = static_cast<const EHCleanupScope *>(get())->getAllocatedSize();
       break;
 
     case EHScope::Terminate:
-      Ptr += EHTerminateScope::getSize();
+      Size = EHTerminateScope::getSize();
       break;
     }
-
+    Ptr += llvm::RoundUpToAlignment(Size, ScopeStackAlignment);
     return *this;
   }
 
@@ -523,7 +537,7 @@
 
   EHCatchScope &scope = cast<EHCatchScope>(*begin());
   InnermostEHScope = scope.getEnclosingEHScope();
-  StartOfData += EHCatchScope::getSizeForNumHandlers(scope.getNumHandlers());
+  unallocate(EHCatchScope::getSizeForNumHandlers(scope.getNumHandlers()));
 }
 
 inline void EHScopeStack::popTerminate() {
@@ -531,7 +545,7 @@
 
   EHTerminateScope &scope = cast<EHTerminateScope>(*begin());
   InnermostEHScope = scope.getEnclosingEHScope();
-  StartOfData += EHTerminateScope::getSize();
+  unallocate(EHTerminateScope::getSize());
 }
 
 inline EHScopeStack::iterator EHScopeStack::find(stable_iterator sp) const {
--- tools/clang/lib/CodeGen/CGCleanup.cpp	2015-01-13 23:38:27.000000000 -0800
+++ tools/clang/lib/CodeGen/CGCleanup.cpp	2015-07-17 17:08:23.853121118 -0700
@@ -94,6 +94,7 @@
 
 /// Push an entry of the given size onto this protected-scope stack.
 char *EHScopeStack::allocate(size_t Size) {
+  Size = llvm::RoundUpToAlignment(Size, ScopeStackAlignment);
   if (!StartOfBuffer) {
     unsigned Capacity = 1024;
     while (Capacity < Size) Capacity *= 2;
@@ -123,6 +124,10 @@
   return StartOfData;
 }
 
+void EHScopeStack::unallocate(size_t Size) {
+  StartOfData += llvm::RoundUpToAlignment(Size, ScopeStackAlignment);
+}
+
 EHScopeStack::stable_iterator
 EHScopeStack::getInnermostActiveNormalCleanup() const {
   for (stable_iterator si = getInnermostNormalCleanup(), se = stable_end();
@@ -153,7 +158,6 @@
 
 
 void *EHScopeStack::pushCleanup(CleanupKind Kind, size_t Size) {
-  assert(((Size % sizeof(void*)) == 0) && "cleanup type is misaligned");
   char *Buffer = allocate(EHCleanupScope::getSizeForCleanupSize(Size));
   bool IsNormalCleanup = Kind & NormalCleanup;
   bool IsEHCleanup = Kind & EHCleanup;
@@ -181,7 +185,7 @@
   EHCleanupScope &Cleanup = cast<EHCleanupScope>(*begin());
   InnermostNormalCleanup = Cleanup.getEnclosingNormalCleanup();
   InnermostEHScope = Cleanup.getEnclosingEHScope();
-  StartOfData += Cleanup.getAllocatedSize();
+  unallocate(Cleanup.getAllocatedSize());
 
   // Destroy the cleanup.
   Cleanup.Destroy();
@@ -211,7 +215,7 @@
   assert(!empty() && "popping exception stack when not empty");
 
   EHFilterScope &filter = cast<EHFilterScope>(*begin());
-  StartOfData += EHFilterScope::getSizeForNumFilters(filter.getNumFilters());
+  unallocate(EHFilterScope::getSizeForNumFilters(filter.getNumFilters()));
 
   InnermostEHScope = filter.getEnclosingEHScope();
 }
--- tools/clang/lib/CodeGen/CGExprCXX.cpp	2015-01-13 23:38:27.000000000 -0800
+++ tools/clang/lib/CodeGen/CGExprCXX.cpp	2015-07-17 16:43:46.544527492 -0700
@@ -1129,6 +1129,10 @@
       EmitNewDeleteCall(CGF, OperatorDelete, FPT, DeleteArgs);
     }
   };
+  static_assert(
+      llvm::AlignOf<CallDeleteDuringNew>::Alignment >=
+          llvm::AlignOf<RValue>::Alignment,
+      "Alignment is insufficient for objects appended to CallDeleteDuringNew");
 
   /// A cleanup to call the given 'operator delete' function upon
   /// abnormal exit from a new expression when the new expression is
@@ -1188,6 +1192,10 @@
       EmitNewDeleteCall(CGF, OperatorDelete, FPT, DeleteArgs);
     }
   };
+  static_assert(
+      llvm::AlignOf<CallDeleteDuringConditionalNew>::Alignment >=
+          llvm::AlignOf<DominatingValue<RValue>::saved_type>::Alignment,
+      "Alignment is insufficient for objects appended to CallDeleteDuringNew");
 }
 
 /// Enter a cleanup to call 'operator delete' if the initializer in a
@@ -1819,7 +1827,7 @@
       MakeAddrLValue(Slot.getAddr(), E->getType(), Slot.getAlignment());
 
   CXXRecordDecl::field_iterator CurField = E->getLambdaClass()->field_begin();
-  for (LambdaExpr::capture_init_iterator i = E->capture_init_begin(),
+  for (LambdaExpr::const_capture_init_iterator i = E->capture_init_begin(),
                                          e = E->capture_init_end();
        i != e; ++i, ++CurField) {
     // Emit initialization
--- tools/clang/lib/CodeGen/CGStmt.cpp	2015-01-13 23:38:27.000000000 -0800
+++ tools/clang/lib/CodeGen/CGStmt.cpp	2015-07-17 16:43:46.546244580 -0700
@@ -2122,7 +2122,7 @@
       CreateMemTemp(RecordTy, "agg.captured"), RecordTy);
 
   RecordDecl::field_iterator CurField = RD->field_begin();
-  for (CapturedStmt::capture_init_iterator I = S.capture_init_begin(),
+  for (CapturedStmt::const_capture_init_iterator I = S.capture_init_begin(),
                                            E = S.capture_init_end();
        I != E; ++I, ++CurField) {
     LValue LV = EmitLValueForFieldInitialization(SlotLV, *CurField);
--- tools/clang/lib/CodeGen/EHScopeStack.h	2014-10-31 19:33:56.000000000 -0400
+++ tools/clang/lib/CodeGen/EHScopeStack.h	2015-07-18 01:53:43.588447919 -0400
@@ -89,6 +89,8 @@
 /// and catch blocks.
 class EHScopeStack {
 public:
+  enum { ScopeStackAlignment = llvm::AlignOf<uint64_t>::Alignment };
+
   /// A saved depth on the scope stack.  This is necessary because
   /// pushing scopes onto the stack invalidates iterators.
   class stable_iterator {
@@ -297,6 +299,7 @@
   SmallVector<BranchFixup, 8> BranchFixups;
 
   char *allocate(size_t Size);
+  void unallocate(size_t Size);
 
   void *pushCleanup(CleanupKind K, size_t DataSize);
 
@@ -311,6 +314,8 @@
   /// Push a lazily-created cleanup on the stack.
   template <class T>
   void pushCleanup(CleanupKind Kind) {
+    static_assert(llvm::AlignOf<T>::Alignment <= ScopeStackAlignment,
+        "Insufficient Alignment!");
     void *Buffer = pushCleanup(Kind, sizeof(T));
     Cleanup *Obj = new(Buffer) T();
     (void) Obj;
@@ -319,6 +324,8 @@
   /// Push a lazily-created cleanup on the stack.
   template <class T, class A0>
   void pushCleanup(CleanupKind Kind, A0 a0) {
+    static_assert(llvm::AlignOf<T>::Alignment <= ScopeStackAlignment,
+        "Insufficient Alignment!");
     void *Buffer = pushCleanup(Kind, sizeof(T));
     Cleanup *Obj = new(Buffer) T(a0);
     (void) Obj;
@@ -327,6 +334,8 @@
   /// Push a lazily-created cleanup on the stack.
   template <class T, class A0, class A1>
   void pushCleanup(CleanupKind Kind, A0 a0, A1 a1) {
+    static_assert(llvm::AlignOf<T>::Alignment <= ScopeStackAlignment,
+        "Insufficient Alignment!");
     void *Buffer = pushCleanup(Kind, sizeof(T));
     Cleanup *Obj = new(Buffer) T(a0, a1);
     (void) Obj;
@@ -335,6 +344,8 @@
   /// Push a lazily-created cleanup on the stack.
   template <class T, class A0, class A1, class A2>
   void pushCleanup(CleanupKind Kind, A0 a0, A1 a1, A2 a2) {
+    static_assert(llvm::AlignOf<T>::Alignment <= ScopeStackAlignment,
+        "Insufficient Alignment!");
     void *Buffer = pushCleanup(Kind, sizeof(T));
     Cleanup *Obj = new(Buffer) T(a0, a1, a2);
     (void) Obj;
@@ -343,6 +354,8 @@
   /// Push a lazily-created cleanup on the stack.
   template <class T, class A0, class A1, class A2, class A3>
   void pushCleanup(CleanupKind Kind, A0 a0, A1 a1, A2 a2, A3 a3) {
+    static_assert(llvm::AlignOf<T>::Alignment <= ScopeStackAlignment,
+        "Insufficient Alignment!");
     void *Buffer = pushCleanup(Kind, sizeof(T));
     Cleanup *Obj = new(Buffer) T(a0, a1, a2, a3);
     (void) Obj;
@@ -351,11 +364,24 @@
   /// Push a lazily-created cleanup on the stack.
   template <class T, class A0, class A1, class A2, class A3, class A4>
   void pushCleanup(CleanupKind Kind, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {
+    static_assert(llvm::AlignOf<T>::Alignment <= ScopeStackAlignment,
+        "Insufficient Alignment!");
     void *Buffer = pushCleanup(Kind, sizeof(T));
     Cleanup *Obj = new(Buffer) T(a0, a1, a2, a3, a4);
     (void) Obj;
   }
 
+  /// Push a lazily-created cleanup on the stack. Tuple version.
+  template <class T, class... As>
+  void pushCleanupTuple(CleanupKind Kind, std::tuple<As...> A) {
+    static_assert(llvm::AlignOf<T>::Alignment <= ScopeStackAlignment,
+        "Insufficient Alignment!");
+    void *Buffer = pushCleanup(Kind, sizeof(T));
+    Cleanup *Obj = new (Buffer) T(std::move(A));
+    (void) Obj;
+  }
+
+
   // Feel free to add more variants of the following:
 
   /// Push a cleanup with non-constant storage requirements on the
@@ -371,6 +397,8 @@
   /// stack is modified.
   template <class T, class A0, class A1, class A2>
   T *pushCleanupWithExtra(CleanupKind Kind, size_t N, A0 a0, A1 a1, A2 a2) {
+    static_assert(llvm::AlignOf<T>::Alignment <= ScopeStackAlignment,
+        "Insufficient Alignment!");
     void *Buffer = pushCleanup(Kind, sizeof(T) + T::getExtraSize(N));
     return new (Buffer) T(N, a0, a1, a2);
   }
--- tools/clang/lib/Lex/PPDirectives.cpp	2014-12-27 23:42:49.000000000 -0800
+++ tools/clang/lib/Lex/PPDirectives.cpp	2015-07-17 16:43:46.550148988 -0700
@@ -48,8 +48,6 @@
 
 MacroInfo *Preprocessor::AllocateDeserializedMacroInfo(SourceLocation L,
                                                        unsigned SubModuleID) {
-  static_assert(llvm::AlignOf<MacroInfo>::Alignment >= sizeof(SubModuleID),
-                "alignment for MacroInfo is less than the ID");
   DeserializedMacroInfoChain *MIChain =
       BP.Allocate<DeserializedMacroInfoChain>();
   MIChain->Next = DeserialMIChainHead;
--- tools/clang/lib/Sema/SemaExceptionSpec.cpp	2014-11-21 19:09:05.000000000 -0800
+++ tools/clang/lib/Sema/SemaExceptionSpec.cpp	2015-07-17 16:43:46.552022232 -0700
@@ -971,7 +971,8 @@
   case Expr::LambdaExprClass: {
     const LambdaExpr *Lambda = cast<LambdaExpr>(E);
     CanThrowResult CT = CT_Cannot;
-    for (LambdaExpr::capture_init_iterator Cap = Lambda->capture_init_begin(),
+    for (LambdaExpr::const_capture_init_iterator
+             Cap = Lambda->capture_init_begin(),
                                         CapEnd = Lambda->capture_init_end();
          Cap != CapEnd; ++Cap)
       CT = mergeCanThrow(CT, canThrow(*Cap));
