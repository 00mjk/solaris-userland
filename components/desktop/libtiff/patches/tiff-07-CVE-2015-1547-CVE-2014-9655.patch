We should be able to remove this patch once we update to the most recent version

--- tiff-4.0.3/libtiff/tif_getimage.c.orig	2015-04-24 11:10:22.706359602 +0530
+++ tiff-4.0.3/libtiff/tif_getimage.c	2015-04-24 14:15:36.081143460 +0530
@@ -842,6 +842,12 @@ gtStripContig(TIFFRGBAImage* img, uint32
 	int32 fromskew, toskew;
 	int ret = 1, flip;
 
+	TIFFGetFieldDefaulted(tif, TIFFTAG_YCBCRSUBSAMPLING, &subsamplinghor, &subsamplingver);
+	if( subsamplingver == 0 ) {
+		TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), "Invalid vertical YCbCr subsampling");
+		return (0);
+	}
+
 	buf = (unsigned char*) _TIFFmalloc(TIFFStripSize(tif));
 	if (buf == 0) {
 		TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), "No space for strip buffer");
@@ -859,7 +865,7 @@ gtStripContig(TIFFRGBAImage* img, uint32
 	}
 
 	TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);
-	TIFFGetFieldDefaulted(tif, TIFFTAG_YCBCRSUBSAMPLING, &subsamplinghor, &subsamplingver);
+
 	scanline = TIFFScanlineSize(tif);
 	fromskew = (w < imagewidth ? imagewidth - w : 0);
 	for (row = 0; row < h; row += nrow)
@@ -1852,7 +1858,7 @@ DECLAREContigPutFunc(putcontig8bitYCbCr4
 
     (void) y;
     fromskew = (fromskew * 10) / 4;
-    if ((h & 3) == 0 && (w & 1) == 0) {
+    if ((w & 3) == 0 && (h & 1) == 0) {
         for (; h >= 2; h -= 2) {
             x = w>>2;
             do {
@@ -1929,7 +1935,7 @@ DECLAREContigPutFunc(putcontig8bitYCbCr4
     /* XXX adjust fromskew */
     do {
 	x = w>>2;
-	do {
+        while(x>0) {
 	    int32 Cb = pp[4];
 	    int32 Cr = pp[5];
 
@@ -1940,8 +1946,8 @@ DECLAREContigPutFunc(putcontig8bitYCbCr4
 
 	    cp += 4;
 	    pp += 6;
-	} while (--x);
-
+	    x--;
+	}
         if( (w&3) != 0 )
         {
 	    int32 Cb = pp[4];
@@ -2031,7 +2037,7 @@ DECLAREContigPutFunc(putcontig8bitYCbCr2
 	fromskew = (fromskew * 4) / 2;
 	do {
 		x = w>>1;
-		do {
+		while(x>0) {
 			int32 Cb = pp[2];
 			int32 Cr = pp[3];
 
@@ -2040,8 +2046,8 @@ DECLAREContigPutFunc(putcontig8bitYCbCr2
 
 			cp += 2;
 			pp += 4;
-		} while (--x);
-
+			x --;
+		}
 		if( (w&1) != 0 )
 		{
 			int32 Cb = pp[2];
--- tiff-4.0.3/libtiff/tif_next.c.orig	2015-04-24 11:17:36.709603113 +0530
+++ tiff-4.0.3/libtiff/tif_next.c	2015-04-24 11:27:38.802984065 +0530
@@ -71,7 +71,7 @@ NeXTDecode(TIFF* tif, uint8* buf, tmsize
 		TIFFErrorExt(tif->tif_clientdata, module, "Fractional scanlines cannot be read");
 		return (0);
 	}
-	for (row = buf; occ > 0; occ -= scanline, row += scanline) {
+	for (row = buf; cc > 0 && occ > 0; occ -= scanline, row += scanline) {
 		n = *bp++, cc--;
 		switch (n) {
 		case LITERALROW:
@@ -90,6 +90,8 @@ NeXTDecode(TIFF* tif, uint8* buf, tmsize
 			 * The scanline has a literal span that begins at some
 			 * offset.
 			 */
+			if( cc < 4 )
+				goto bad;
 			off = (bp[0] * 256) + bp[1];
 			n = (bp[2] * 256) + bp[3];
 			if (cc < 4+n || off+n > scanline)
