Security bug fixes being brought in from upstream that fix several security vulnerabilities
https://launchpad.net/ubuntu/+source/mozjs38/38.8.0~repack1-0ubuntu0.1

diff -Nru mozjs38-38.2.1~rc0/js/public/Class.h mozjs38-38.8.0~repack1/js/public/Class.h
--- mozjs38-38.2.1~rc0/js/public/Class.h	2015-09-17 20:12:18.000000000 +0000
+++ mozjs38-38.8.0~repack1/js/public/Class.h	2016-04-20 21:17:30.000000000 +0000
@@ -439,7 +439,7 @@
 
 // Fast access to the original value of each standard class's prototype.
 #define JSCLASS_CACHED_PROTO_SHIFT      (JSCLASS_HIGH_FLAGS_SHIFT + 10)
-#define JSCLASS_CACHED_PROTO_MASK       JS_BITMASK(JSCLASS_CACHED_PROTO_WIDTH)
+#define JSCLASS_CACHED_PROTO_MASK       JS_BITMASK(js::JSCLASS_CACHED_PROTO_WIDTH)
 #define JSCLASS_HAS_CACHED_PROTO(key)   (uint32_t(key) << JSCLASS_CACHED_PROTO_SHIFT)
 #define JSCLASS_CACHED_PROTO_KEY(clasp) ((JSProtoKey)                         \
                                          (((clasp)->flags                     \
diff -Nru mozjs38-38.2.1~rc0/js/public/HashTable.h mozjs38-38.8.0~repack1/js/public/HashTable.h
--- mozjs38-38.2.1~rc0/js/public/HashTable.h	2015-09-17 20:12:18.000000000 +0000
+++ mozjs38-38.8.0~repack1/js/public/HashTable.h	2016-04-20 21:17:30.000000000 +0000
@@ -13,6 +13,7 @@
 #include "mozilla/Casting.h"
 #include "mozilla/MemoryReporting.h"
 #include "mozilla/Move.h"
+#include "mozilla/Opaque.h"
 #include "mozilla/PodOperations.h"
 #include "mozilla/ReentrancyGuard.h"
 #include "mozilla/TemplateLib.h"
@@ -32,6 +33,8 @@
 
 /*****************************************************************************/
 
+using Generation = mozilla::Opaque<uint64_t>;
+
 // A JS-friendly, STL-like container providing a hash-based map from keys to
 // values. In particular, HashMap calls constructors and destructors of all
 // objects added so non-PODs may be used safely.
@@ -205,7 +208,9 @@
 
     // If |generation()| is the same before and after a HashMap operation,
     // pointers into the table remain valid.
-    uint32_t generation() const                       { return impl.generation(); }
+    Generation generation() const {
+        return impl.generation();
+    }
 
     /************************************************** Shorthand operations */
 
@@ -436,7 +441,9 @@
 
     // If |generation()| is the same before and after a HashSet operation,
     // pointers into the table remain valid.
-    uint32_t generation() const                       { return impl.generation(); }
+    Generation generation() const {
+        return impl.generation();
+    }
 
     /************************************************** Shorthand operations */
 
@@ -771,7 +778,7 @@
         Entry* entry_;
 #ifdef JS_DEBUG
         const HashTable* table_;
-        uint32_t generation;
+        Generation generation;
 #endif
 
       protected:
@@ -878,7 +885,7 @@
 #ifdef JS_DEBUG
         const HashTable* table_;
         uint64_t mutationCount;
-        uint32_t generation;
+        Generation generation;
         bool validEntry;
 #endif
 
@@ -1017,8 +1024,8 @@
     static const size_t CAP_BITS = 24;
 
   public:
-    Entry*      table;                 // entry storage
-    uint32_t    gen;                    // entry storage generation number
+    uint64_t    gen;                    // entry storage generation number
+    Entry*      table;                  // entry storage
     uint32_t    entryCount;             // number of entries in table
     uint32_t    removedCount:CAP_BITS;  // removed entry sentinels in table
     uint32_t    hashShift:8;            // multiplicative hash shift
@@ -1102,8 +1109,8 @@
   public:
     explicit HashTable(AllocPolicy ap)
       : AllocPolicy(ap)
-      , table(nullptr)
       , gen(0)
+      , table(nullptr)
       , entryCount(0)
       , removedCount(0)
       , hashShift(sHashBits)
@@ -1529,10 +1536,10 @@
         return JS_BIT(sHashBits - hashShift);
     }
 
-    uint32_t generation() const
+    Generation generation() const
     {
         MOZ_ASSERT(table);
-        return gen;
+        return Generation(gen);
     }
 
     size_t sizeOfExcludingThis(mozilla::MallocSizeOf mallocSizeOf) const
diff -Nru mozjs38-38.2.1~rc0/js/public/Utility.h mozjs38-38.8.0~repack1/js/public/Utility.h
--- mozjs38-38.2.1~rc0/js/public/Utility.h	2015-09-17 20:12:18.000000000 +0000
+++ mozjs38-38.8.0~repack1/js/public/Utility.h	2016-04-20 21:17:30.000000000 +0000
@@ -217,6 +217,36 @@
 
 JS_DECLARE_NEW_METHODS(js_new, js_malloc, static MOZ_ALWAYS_INLINE)
 
+namespace js {
+
+/*
+ * Calculate the number of bytes needed to allocate |numElems| contiguous
+ * instances of type |T|.  Return false if the calculation overflowed.
+ */
+template <typename T>
+MOZ_WARN_UNUSED_RESULT inline bool
+CalculateAllocSize(size_t numElems, size_t* bytesOut)
+{
+    *bytesOut = numElems * sizeof(T);
+    return (numElems & mozilla::tl::MulOverflowMask<sizeof(T)>::value) == 0;
+}
+
+/*
+ * Calculate the number of bytes needed to allocate a single instance of type
+ * |T| followed by |numExtra| contiguous instances of type |Extra|.  Return
+ * false if the calculation overflowed.
+ */
+template <typename T, typename Extra>
+MOZ_WARN_UNUSED_RESULT inline bool
+CalculateAllocSizeWithExtra(size_t numExtra, size_t* bytesOut)
+{
+    *bytesOut = sizeof(T) + numExtra * sizeof(Extra);
+    return (numExtra & mozilla::tl::MulOverflowMask<sizeof(Extra)>::value) == 0 &&
+           *bytesOut >= sizeof(T);
+}
+
+} /* namespace js */
+
 template <class T>
 static MOZ_ALWAYS_INLINE void
 js_delete(T* p)
@@ -242,32 +272,34 @@
 static MOZ_ALWAYS_INLINE T*
 js_pod_malloc()
 {
-    return (T*)js_malloc(sizeof(T));
+    return static_cast<T*>(js_malloc(sizeof(T)));
 }
 
 template <class T>
 static MOZ_ALWAYS_INLINE T*
 js_pod_calloc()
 {
-    return (T*)js_calloc(sizeof(T));
+    return static_cast<T*>(js_calloc(sizeof(T)));
 }
 
 template <class T>
 static MOZ_ALWAYS_INLINE T*
 js_pod_malloc(size_t numElems)
 {
-    if (MOZ_UNLIKELY(numElems & mozilla::tl::MulOverflowMask<sizeof(T)>::value))
+    size_t bytes;
+    if (MOZ_UNLIKELY(!js::CalculateAllocSize<T>(numElems, &bytes)))
         return nullptr;
-    return (T*)js_malloc(numElems * sizeof(T));
+    return static_cast<T*>(js_malloc(bytes));
 }
 
 template <class T>
 static MOZ_ALWAYS_INLINE T*
 js_pod_calloc(size_t numElems)
 {
-    if (MOZ_UNLIKELY(numElems & mozilla::tl::MulOverflowMask<sizeof(T)>::value))
+    size_t bytes;
+    if (MOZ_UNLIKELY(!js::CalculateAllocSize<T>(numElems, &bytes)))
         return nullptr;
-    return (T*)js_calloc(numElems * sizeof(T));
+    return static_cast<T*>(js_calloc(bytes));
 }
 
 template <class T>
@@ -275,9 +307,10 @@
 js_pod_realloc(T* prior, size_t oldSize, size_t newSize)
 {
     MOZ_ASSERT(!(oldSize & mozilla::tl::MulOverflowMask<sizeof(T)>::value));
-    if (MOZ_UNLIKELY(newSize & mozilla::tl::MulOverflowMask<sizeof(T)>::value))
+    size_t bytes;
+    if (MOZ_UNLIKELY(!js::CalculateAllocSize<T>(newSize, &bytes)))
         return nullptr;
-    return (T*)js_realloc(prior, newSize * sizeof(T));
+    return static_cast<T*>(js_realloc(prior, bytes));
 }
 
 namespace js {
diff -Nru mozjs38-38.2.1~rc0/js/src/ds/LifoAlloc.h mozjs38-38.8.0~repack1/js/src/ds/LifoAlloc.h
--- mozjs38-38.2.1~rc0/js/src/ds/LifoAlloc.h	2015-09-17 20:12:18.000000000 +0000
+++ mozjs38-38.8.0~repack1/js/src/ds/LifoAlloc.h	2016-04-20 21:17:30.000000000 +0000
@@ -310,9 +310,10 @@
     // The caller is responsible for initialization.
     template <typename T>
     T* newArrayUninitialized(size_t count) {
-        if (MOZ_UNLIKELY(count & mozilla::tl::MulOverflowMask<sizeof(T)>::value))
+        size_t bytes;
+        if (MOZ_UNLIKELY(!CalculateAllocSize<T>(count, &bytes)))
             return nullptr;
-        return static_cast<T*>(alloc(sizeof(T) * count));
+        return static_cast<T*>(alloc(bytes));
     }
 
     class Mark {
@@ -527,16 +528,16 @@
     {}
     template <typename T>
     T* pod_malloc(size_t numElems) {
-        if (MOZ_UNLIKELY(numElems & mozilla::tl::MulOverflowMask<sizeof(T)>::value))
+        size_t bytes;
+        if (MOZ_UNLIKELY(!CalculateAllocSize<T>(numElems, &bytes)))
             return nullptr;
-        size_t bytes = numElems * sizeof(T);
         void* p = fb == Fallible ? alloc_.alloc(bytes) : alloc_.allocInfallible(bytes);
         return static_cast<T*>(p);
     }
     template <typename T>
     T* pod_calloc(size_t numElems) {
         T* p = pod_malloc<T>(numElems);
-        if (fb == Fallible && !p)
+        if (MOZ_UNLIKELY(!p))
             return nullptr;
         memset(p, 0, numElems * sizeof(T));
         return p;
@@ -544,7 +545,7 @@
     template <typename T>
     T* pod_realloc(T* p, size_t oldSize, size_t newSize) {
         T* n = pod_malloc<T>(newSize);
-        if (fb == Fallible && !n)
+        if (MOZ_UNLIKELY(!n))
             return nullptr;
         MOZ_ASSERT(!(oldSize & mozilla::tl::MulOverflowMask<sizeof(T)>::value));
         memcpy(n, p, Min(oldSize * sizeof(T), newSize * sizeof(T)));
diff -Nru mozjs38-38.2.1~rc0/js/src/jit/arm/MacroAssembler-arm.cpp mozjs38-38.8.0~repack1/js/src/jit/arm/MacroAssembler-arm.cpp
--- mozjs38-38.2.1~rc0/js/src/jit/arm/MacroAssembler-arm.cpp	2015-09-17 20:12:22.000000000 +0000
+++ mozjs38-38.8.0~repack1/js/src/jit/arm/MacroAssembler-arm.cpp	2016-04-20 21:17:33.000000000 +0000
@@ -2487,8 +2487,8 @@
 void
 MacroAssemblerARMCompat::store32(Imm32 imm, const BaseIndex& dest)
 {
-    ma_mov(imm, secondScratchReg_);
-    store32(secondScratchReg_, dest);
+    ma_mov(imm, ScratchRegister);
+    store32(ScratchRegister, dest);
 }
 
 void
@@ -2498,8 +2498,8 @@
     uint32_t scale = Imm32::ShiftOf(dest.scale).value;
 
     if (dest.offset != 0) {
-        ma_add(base, Imm32(dest.offset), ScratchRegister);
-        base = ScratchRegister;
+        ma_add(base, Imm32(dest.offset), secondScratchReg_);
+        base = secondScratchReg_;
     }
     ma_str(src, DTRAddr(base, DtrRegImmShift(dest.index, LSL, scale)));
 }
diff -Nru mozjs38-38.2.1~rc0/js/src/jit/BacktrackingAllocator.cpp mozjs38-38.8.0~repack1/js/src/jit/BacktrackingAllocator.cpp
--- mozjs38-38.2.1~rc0/js/src/jit/BacktrackingAllocator.cpp	2015-09-17 20:12:22.000000000 +0000
+++ mozjs38-38.8.0~repack1/js/src/jit/BacktrackingAllocator.cpp	2016-04-20 21:17:33.000000000 +0000
@@ -206,10 +206,9 @@
 
     // Registers which might spill to the frame's argument slots can only be
     // grouped with other such registers if the frame might access those
-    // arguments through a lazy arguments object.
+    // arguments through a lazy arguments object or rest parameter.
     if (IsArgumentSlotDefinition(reg0->def()) || IsArgumentSlotDefinition(reg1->def())) {
-        JSScript* script = graph.mir().entryBlock()->info().script();
-        if (script && script->argumentsAliasesFormals()) {
+        if (graph.mir().entryBlock()->info().mayReadFrameArgsDirectly()) {
             if (*reg0->def()->output() != *reg1->def()->output())
                 return true;
         }
diff -Nru mozjs38-38.2.1~rc0/js/src/jit/CodeGenerator.cpp mozjs38-38.8.0~repack1/js/src/jit/CodeGenerator.cpp
--- mozjs38-38.2.1~rc0/js/src/jit/CodeGenerator.cpp	2015-09-17 20:12:22.000000000 +0000
+++ mozjs38-38.8.0~repack1/js/src/jit/CodeGenerator.cpp	2016-04-20 21:17:33.000000000 +0000
@@ -7907,7 +7907,9 @@
     if (ic->idempotent()) {
         size_t numLocs;
         CacheLocationList& cacheLocs = lir->mirRaw()->toGetPropertyCache()->location();
-        size_t locationBase = addCacheLocations(cacheLocs, &numLocs);
+        size_t locationBase;
+        if (!addCacheLocations(cacheLocs, &numLocs, &locationBase))
+            return;
         ic->setLocationInfo(locationBase, numLocs);
     }
 
diff -Nru mozjs38-38.2.1~rc0/js/src/jit/CompileInfo.h mozjs38-38.8.0~repack1/js/src/jit/CompileInfo.h
--- mozjs38-38.2.1~rc0/js/src/jit/CompileInfo.h	2015-09-17 20:12:22.000000000 +0000
+++ mozjs38-38.8.0~repack1/js/src/jit/CompileInfo.h	2016-04-20 21:17:33.000000000 +0000
@@ -199,6 +199,7 @@
                 InlineScriptTree* inlineScriptTree)
       : script_(script), fun_(fun), osrPc_(osrPc), constructing_(constructing),
         analysisMode_(analysisMode), scriptNeedsArgsObj_(scriptNeedsArgsObj),
+        mayReadFrameArgsDirectly_(script->mayReadFrameArgsDirectly()),
         inlineScriptTree_(inlineScriptTree)
     {
         MOZ_ASSERT_IF(osrPc, JSOp(*osrPc) == JSOP_LOOPENTRY);
@@ -227,7 +228,7 @@
     explicit CompileInfo(unsigned nlocals)
       : script_(nullptr), fun_(nullptr), osrPc_(nullptr), osrStaticScope_(nullptr),
         constructing_(false), analysisMode_(Analysis_None), scriptNeedsArgsObj_(false),
-        inlineScriptTree_(nullptr)
+        mayReadFrameArgsDirectly_(false), inlineScriptTree_(nullptr)
     {
         nimplicit_ = 0;
         nargs_ = 0;
@@ -544,6 +545,10 @@
         return true;
     }
 
+    bool mayReadFrameArgsDirectly() const {
+        return mayReadFrameArgsDirectly_;
+    }
+
   private:
     unsigned nimplicit_;
     unsigned nargs_;
@@ -564,6 +569,8 @@
     // thread, so cache a value here and use it throughout for consistency.
     bool scriptNeedsArgsObj_;
 
+    bool mayReadFrameArgsDirectly_;
+
     InlineScriptTree* inlineScriptTree_;
 };
 
diff -Nru mozjs38-38.2.1~rc0/js/src/jit/FixedList.h mozjs38-38.8.0~repack1/js/src/jit/FixedList.h
--- mozjs38-38.2.1~rc0/js/src/jit/FixedList.h	2015-09-17 20:12:22.000000000 +0000
+++ mozjs38-38.8.0~repack1/js/src/jit/FixedList.h	2016-04-20 21:17:33.000000000 +0000
@@ -37,9 +37,10 @@
         if (length == 0)
             return true;
 
-        if (MOZ_UNLIKELY(length & mozilla::tl::MulOverflowMask<sizeof(T)>::value))
+        size_t bytes;
+        if (MOZ_UNLIKELY(!CalculateAllocSize<T>(length, &bytes)))
             return false;
-        list_ = (T*)alloc.allocate(length * sizeof(T));
+        list_ = (T*)alloc.allocate(bytes);
         return list_ != nullptr;
     }
 
@@ -60,9 +61,10 @@
         size_t newlength = length_ + num;
         if (newlength < length_)
             return false;
-        if (MOZ_UNLIKELY(newlength & mozilla::tl::MulOverflowMask<sizeof(T)>::value))
+        size_t bytes;
+        if (MOZ_UNLIKELY(!CalculateAllocSize<T>(newlength, &bytes)))
             return false;
-        T* list = (T*)alloc.allocate((length_ + num) * sizeof(T));
+        T* list = (T*)alloc.allocate(bytes);
         if (MOZ_UNLIKELY(!list))
             return false;
 
diff -Nru mozjs38-38.2.1~rc0/js/src/jit/JitAllocPolicy.h mozjs38-38.8.0~repack1/js/src/jit/JitAllocPolicy.h
--- mozjs38-38.2.1~rc0/js/src/jit/JitAllocPolicy.h	2015-09-17 20:12:22.000000000 +0000
+++ mozjs38-38.8.0~repack1/js/src/jit/JitAllocPolicy.h	2016-04-20 21:17:33.000000000 +0000
@@ -48,12 +48,13 @@
         return p;
     }
 
-    template <size_t ElemSize>
-    void* allocateArray(size_t n)
+    template <typename T>
+    T* allocateArray(size_t n)
     {
-        if (MOZ_UNLIKELY(n & mozilla::tl::MulOverflowMask<ElemSize>::value))
+        size_t bytes;
+        if (MOZ_UNLIKELY(!CalculateAllocSize<T>(n, &bytes)))
             return nullptr;
-        void* p = lifoScope_.alloc().alloc(n * ElemSize);
+        T* p = static_cast<T*>(lifoScope_.alloc().alloc(bytes));
         if (MOZ_UNLIKELY(!ensureBallast()))
             return nullptr;
         return p;
@@ -79,9 +80,10 @@
     {}
     template <typename T>
     T* pod_malloc(size_t numElems) {
-        if (MOZ_UNLIKELY(numElems & mozilla::tl::MulOverflowMask<sizeof(T)>::value))
+        size_t bytes;
+        if (MOZ_UNLIKELY(!CalculateAllocSize<T>(numElems, &bytes)))
             return nullptr;
-        return static_cast<T*>(alloc_.allocate(numElems * sizeof(T)));
+        return static_cast<T*>(alloc_.allocate(bytes));
     }
     template <typename T>
     T* pod_calloc(size_t numElems) {
@@ -112,9 +114,10 @@
     {}
     template <typename T>
     T* pod_malloc(size_t numElems) {
-        if (MOZ_UNLIKELY(numElems & mozilla::tl::MulOverflowMask<sizeof(T)>::value))
+        size_t bytes;
+        if (MOZ_UNLIKELY(!CalculateAllocSize<T>(numElems, &bytes)))
             return nullptr;
-        return static_cast<T*>(GetJitContext()->temp->allocate(numElems * sizeof(T)));
+        return static_cast<T*>(GetJitContext()->temp->allocate(bytes));
     }
     void free_(void* p) {
     }
diff -Nru mozjs38-38.2.1~rc0/js/src/jit/JitFrames.cpp mozjs38-38.8.0~repack1/js/src/jit/JitFrames.cpp
--- mozjs38-38.2.1~rc0/js/src/jit/JitFrames.cpp	2015-09-17 20:12:22.000000000 +0000
+++ mozjs38-38.8.0~repack1/js/src/jit/JitFrames.cpp	2016-04-20 21:17:33.000000000 +0000
@@ -1007,7 +1007,7 @@
     size_t nformals = 0;
     if (CalleeTokenIsFunction(layout->calleeToken())) {
         JSFunction* fun = CalleeTokenToFunction(layout->calleeToken());
-        nformals = fun->nonLazyScript()->argumentsAliasesFormals() ? 0 : fun->nargs();
+        nformals = fun->nonLazyScript()->mayReadFrameArgsDirectly() ? 0 : fun->nargs();
     }
 
     Value* argv = layout->argv();
diff -Nru mozjs38-38.2.1~rc0/js/src/jit/LIR.cpp mozjs38-38.8.0~repack1/js/src/jit/LIR.cpp
--- mozjs38-38.2.1~rc0/js/src/jit/LIR.cpp	2015-09-17 20:12:22.000000000 +0000
+++ mozjs38-38.8.0~repack1/js/src/jit/LIR.cpp	2016-04-20 21:17:33.000000000 +0000
@@ -105,8 +105,7 @@
 
         int numPhis = (phi->type() == MIRType_Value) ? BOX_PIECES : 1;
         for (int i = 0; i < numPhis; i++) {
-            void* array = alloc.allocateArray<sizeof(LAllocation)>(numPreds);
-            LAllocation* inputs = static_cast<LAllocation*>(array);
+            LAllocation* inputs = alloc.allocateArray<LAllocation>(numPreds);
             if (!inputs)
                 return false;
 
diff -Nru mozjs38-38.2.1~rc0/js/src/jit/MCallOptimize.cpp mozjs38-38.8.0~repack1/js/src/jit/MCallOptimize.cpp
--- mozjs38-38.2.1~rc0/js/src/jit/MCallOptimize.cpp	2015-09-17 20:12:22.000000000 +0000
+++ mozjs38-38.8.0~repack1/js/src/jit/MCallOptimize.cpp	2016-04-20 21:17:33.000000000 +0000
@@ -2122,6 +2122,19 @@
     return InliningStatus_Inlined;
 }
 
+static bool
+IsTypedArrayObject(CompilerConstraintList* constraints, MDefinition* def)
+{
+    MOZ_ASSERT(def->type() == MIRType_Object);
+
+    TemporaryTypeSet* types = def->resultTypeSet();
+    if (!types)
+        return false;
+
+    return types->forAllClasses(constraints, IsTypedArrayClass) ==
+           TemporaryTypeSet::ForAllResult::ALL_TRUE;
+}
+
 IonBuilder::InliningStatus
 IonBuilder::inlineTypedArrayLength(CallInfo& callInfo)
 {
@@ -2132,8 +2145,10 @@
     if (getInlineReturnType() != MIRType_Int32)
         return InliningStatus_NotInlined;
 
-    // We assume that when calling this function we always
-    // have a TypedArray. The native asserts that as well.
+    // Note that the argument we see here is not necessarily a typed array.
+    // If it's not, this call should be unreachable though.
+    if (!IsTypedArrayObject(constraints(), callInfo.getArg(0)))
+        return InliningStatus_NotInlined;
 
     MInstruction* length = addTypedArrayLength(callInfo.getArg(0));
     current->push(length);
diff -Nru mozjs38-38.2.1~rc0/js/src/jit/MIRGenerator.h mozjs38-38.8.0~repack1/js/src/jit/MIRGenerator.h
--- mozjs38-38.2.1~rc0/js/src/jit/MIRGenerator.h	2015-09-17 20:12:22.000000000 +0000
+++ mozjs38-38.8.0~repack1/js/src/jit/MIRGenerator.h	2016-04-20 21:17:33.000000000 +0000
@@ -60,10 +60,11 @@
     }
 
     template <typename T>
-    T * allocate(size_t count = 1) {
-        if (count & mozilla::tl::MulOverflowMask<sizeof(T)>::value)
+    T* allocate(size_t count = 1) {
+        size_t bytes;
+        if (MOZ_UNLIKELY(!CalculateAllocSize<T>(count, &bytes)))
             return nullptr;
-        return reinterpret_cast<T*>(alloc().allocate(sizeof(T) * count));
+        return static_cast<T*>(alloc().allocate(bytes));
     }
 
     // Set an error state and prints a message. Returns false so errors can be
diff -Nru mozjs38-38.2.1~rc0/js/src/jit/MIRGraph.cpp mozjs38-38.8.0~repack1/js/src/jit/MIRGraph.cpp
--- mozjs38-38.2.1~rc0/js/src/jit/MIRGraph.cpp	2015-09-17 20:12:22.000000000 +0000
+++ mozjs38-38.8.0~repack1/js/src/jit/MIRGraph.cpp	2016-04-20 21:17:33.000000000 +0000
@@ -297,7 +297,7 @@
             size_t nphis = block->stackPosition_;
 
             TempAllocator& alloc = graph.alloc();
-            MPhi* phis = (MPhi*)alloc.allocateArray<sizeof(MPhi)>(nphis);
+            MPhi* phis = alloc.allocateArray<MPhi>(nphis);
             if (!phis)
                 return nullptr;
 
diff -Nru mozjs38-38.2.1~rc0/js/src/jit/shared/CodeGenerator-shared.cpp mozjs38-38.8.0~repack1/js/src/jit/shared/CodeGenerator-shared.cpp
--- mozjs38-38.2.1~rc0/js/src/jit/shared/CodeGenerator-shared.cpp	2015-09-17 20:12:22.000000000 +0000
+++ mozjs38-38.8.0~repack1/js/src/jit/shared/CodeGenerator-shared.cpp	2016-04-20 21:17:34.000000000 +0000
@@ -1532,21 +1532,24 @@
 }
 #endif
 
-size_t
-CodeGeneratorShared::addCacheLocations(const CacheLocationList& locs, size_t* numLocs)
+MOZ_WARN_UNUSED_RESULT bool
+CodeGeneratorShared::addCacheLocations(const CacheLocationList& locs, size_t* numLocs,
+                                       size_t* curIndex)
 {
     size_t firstIndex = runtimeData_.length();
     size_t numLocations = 0;
     for (CacheLocationList::iterator iter = locs.begin(); iter != locs.end(); iter++) {
         // allocateData() ensures that sizeof(CacheLocation) is word-aligned.
         // If this changes, we will need to pad to ensure alignment.
-        size_t curIndex = allocateData(sizeof(CacheLocation));
-        new (&runtimeData_[curIndex]) CacheLocation(iter->pc, iter->script);
+        if (!allocateData(sizeof(CacheLocation), curIndex))
+            return false;
+        new (&runtimeData_[*curIndex]) CacheLocation(iter->pc, iter->script);
         numLocations++;
     }
     MOZ_ASSERT(numLocations != 0);
     *numLocs = numLocations;
-    return firstIndex;
+    *curIndex = firstIndex;
+    return true;
 }
 
 ReciprocalMulConstants
diff -Nru mozjs38-38.2.1~rc0/js/src/jit/shared/CodeGenerator-shared.h mozjs38-38.8.0~repack1/js/src/jit/shared/CodeGenerator-shared.h
--- mozjs38-38.2.1~rc0/js/src/jit/shared/CodeGenerator-shared.h	2015-09-17 20:12:22.000000000 +0000
+++ mozjs38-38.8.0~repack1/js/src/jit/shared/CodeGenerator-shared.h	2016-04-20 21:17:34.000000000 +0000
@@ -8,6 +8,7 @@
 #define jit_shared_CodeGenerator_shared_h
 
 #include "mozilla/Alignment.h"
+#include "mozilla/TypeTraits.h"
 
 #include "jit/JitFrames.h"
 #include "jit/LIR.h"
@@ -247,14 +248,6 @@
     }
 
   protected:
-    // Ensure the cache is an IonCache while expecting the size of the derived
-    // class. We only need the cache list at GC time. Everyone else can just take
-    // runtimeData offsets.
-    size_t allocateCache(const IonCache&, size_t size) {
-        size_t dataOffset = allocateData(size);
-        masm.propagateOOM(cacheList_.append(dataOffset));
-        return dataOffset;
-    }
 
 #ifdef CHECK_OSIPOINT_REGISTERS
     void resetOsiPointRegs(LSafepoint* safepoint);
@@ -300,17 +293,23 @@
     };
 
   protected:
-
-    size_t allocateData(size_t size) {
+    MOZ_WARN_UNUSED_RESULT
+    bool allocateData(size_t size, size_t* offset) {
         MOZ_ASSERT(size % sizeof(void*) == 0);
-        size_t dataOffset = runtimeData_.length();
+        *offset = runtimeData_.length();
         masm.propagateOOM(runtimeData_.appendN(0, size));
-        return dataOffset;
+        return !masm.oom();
     }
 
+    // Ensure the cache is an IonCache while expecting the size of the derived
+    // class. We only need the cache list at GC time. Everyone else can just take
+    // runtimeData offsets.
     template <typename T>
     inline size_t allocateCache(const T& cache) {
-        size_t index = allocateCache(cache, sizeof(mozilla::AlignedStorage2<T>));
+        static_assert(mozilla::IsBaseOf<IonCache, T>::value, "T must inherit from IonCache");
+        size_t index;
+        masm.propagateOOM(allocateData(sizeof(mozilla::AlignedStorage2<T>), &index));
+        masm.propagateOOM(cacheList_.append(index));
         if (masm.oom())
             return SIZE_MAX;
         // Use the copy constructor on the allocated space.
@@ -480,7 +479,7 @@
                                     const StoreOutputTo& out);
 
     void addCache(LInstruction* lir, size_t cacheIndex);
-    size_t addCacheLocations(const CacheLocationList& locs, size_t* numLocs);
+    bool addCacheLocations(const CacheLocationList& locs, size_t* numLocs, size_t* offset);
     ReciprocalMulConstants computeDivisionConstants(int d);
 
   protected:
diff -Nru mozjs38-38.2.1~rc0/js/src/jit/TypePolicy.cpp mozjs38-38.8.0~repack1/js/src/jit/TypePolicy.cpp
--- mozjs38-38.2.1~rc0/js/src/jit/TypePolicy.cpp	2015-09-17 20:12:22.000000000 +0000
+++ mozjs38-38.8.0~repack1/js/src/jit/TypePolicy.cpp	2016-04-20 21:17:33.000000000 +0000
@@ -22,6 +22,8 @@
     if (in->type() == MIRType_Float32) {
         MToDouble* replace = MToDouble::New(alloc, in);
         def->block()->insertBefore(def, replace);
+        if (def->isRecoveredOnBailout())
+            replace->setRecoveredOnBailout();
         def->replaceOperand(op, replace);
     }
 }
diff -Nru mozjs38-38.2.1~rc0/js/src/jit/ValueNumbering.cpp mozjs38-38.8.0~repack1/js/src/jit/ValueNumbering.cpp
--- mozjs38-38.2.1~rc0/js/src/jit/ValueNumbering.cpp	2015-09-17 20:12:22.000000000 +0000
+++ mozjs38-38.8.0~repack1/js/src/jit/ValueNumbering.cpp	2016-04-20 21:17:33.000000000 +0000
@@ -438,6 +438,7 @@
     graph_.insertBlockBefore(block, fake);
     fake->setImmediateDominator(fake);
     fake->addNumDominated(1);
+    fake->setDomIndex(fake->id());
 
     // Create zero-input phis to use as inputs for any phis in |block|.
     // Again, this is a little odd, but it's the least-odd thing we can do
@@ -726,6 +727,12 @@
         return true;
     }
 
+    // Skip optimizations on instructions which are recovered on bailout, to
+    // avoid mixing instructions which are recovered on bailouts with
+    // instructions which are not.
+    if (def->isRecoveredOnBailout())
+        return true;
+
     // If this instruction has a dependency() into an unreachable block, we'll
     // need to update AliasAnalysis.
     MInstruction* dep = def->dependency();
diff -Nru mozjs38-38.2.1~rc0/js/src/jit-test/tests/gc/bug-1241731.js mozjs38-38.8.0~repack1/js/src/jit-test/tests/gc/bug-1241731.js
--- mozjs38-38.2.1~rc0/js/src/jit-test/tests/gc/bug-1241731.js	1970-01-01 00:00:00.000000000 +0000
+++ mozjs38-38.8.0~repack1/js/src/jit-test/tests/gc/bug-1241731.js	2016-04-20 21:17:32.000000000 +0000
@@ -0,0 +1,4 @@
+if (!('oomTest' in this))
+    quit();
+
+oomTest(() => serialize(0, [{}]));
diff -Nru mozjs38-38.2.1~rc0/js/src/jit-test/tests/ion/bug1107011-1.js mozjs38-38.8.0~repack1/js/src/jit-test/tests/ion/bug1107011-1.js
--- mozjs38-38.2.1~rc0/js/src/jit-test/tests/ion/bug1107011-1.js	1970-01-01 00:00:00.000000000 +0000
+++ mozjs38-38.8.0~repack1/js/src/jit-test/tests/ion/bug1107011-1.js	2016-04-20 21:17:32.000000000 +0000
@@ -0,0 +1,17 @@
+var f32 = new Float32Array(32);
+function f(n) {
+    var x;
+    if (n > 10000) {
+        x = 4.5;
+    } else {
+        x = f32[0];
+    }
+    f32[0] = (function() {
+        for(var f=0;f<4;++f) {
+            x=1;
+        }
+    })() < x;
+}
+for (var n = 0; n < 100; n++)
+    f(n);
+
diff -Nru mozjs38-38.2.1~rc0/js/src/jit-test/tests/ion/bug1107011-2.js mozjs38-38.8.0~repack1/js/src/jit-test/tests/ion/bug1107011-2.js
--- mozjs38-38.2.1~rc0/js/src/jit-test/tests/ion/bug1107011-2.js	1970-01-01 00:00:00.000000000 +0000
+++ mozjs38-38.8.0~repack1/js/src/jit-test/tests/ion/bug1107011-2.js	2016-04-20 21:17:32.000000000 +0000
@@ -0,0 +1,12 @@
+function foo() {
+    var x = 0, y = 0, a = new Float32Array(1);
+    function bar() {
+        x = y;
+        y = a[0];
+    }
+    for (var i = 0; i < 1000; i++) {
+        bar();
+    }
+}
+for (var i=0; i < 50; i++)
+    foo();
diff -Nru mozjs38-38.2.1~rc0/js/src/jit-test/tests/parser/bug-1254164.js mozjs38-38.8.0~repack1/js/src/jit-test/tests/parser/bug-1254164.js
--- mozjs38-38.2.1~rc0/js/src/jit-test/tests/parser/bug-1254164.js	1970-01-01 00:00:00.000000000 +0000
+++ mozjs38-38.8.0~repack1/js/src/jit-test/tests/parser/bug-1254164.js	2016-04-20 21:17:33.000000000 +0000
@@ -0,0 +1,6 @@
+// |jit-test| slow;
+
+var s = '';
+for (var i = 0; i < 70000; i++)
+    s += 'function x' + i + '() { x' + i + '(); }\n';
+eval("(function() { " + s + " })();");
diff -Nru mozjs38-38.2.1~rc0/js/src/jsalloc.h mozjs38-38.8.0~repack1/js/src/jsalloc.h
--- mozjs38-38.2.1~rc0/js/src/jsalloc.h	2015-09-17 20:12:22.000000000 +0000
+++ mozjs38-38.8.0~repack1/js/src/jsalloc.h	2016-04-20 21:17:34.000000000 +0000
@@ -53,6 +53,14 @@
      */
     JS_FRIEND_API(void*) onOutOfMemory(void* p, size_t nbytes);
 
+    template <typename T>
+    T* onOutOfMemoryTyped(void* p, size_t numElems) {
+        size_t bytes;
+        if (MOZ_UNLIKELY(!CalculateAllocSize<T>(numElems, &bytes)))
+            return nullptr;
+        return static_cast<T*>(onOutOfMemory(p, bytes));
+    }
+
   public:
     MOZ_IMPLICIT TempAllocPolicy(JSContext* cx) : cx_((ContextFriendFields*) cx) {} // :(
     MOZ_IMPLICIT TempAllocPolicy(ContextFriendFields* cx) : cx_(cx) {}
@@ -61,7 +69,7 @@
     T* pod_malloc(size_t numElems) {
         T* p = js_pod_malloc<T>(numElems);
         if (MOZ_UNLIKELY(!p))
-            p = static_cast<T*>(onOutOfMemory(nullptr, numElems * sizeof(T)));
+            p = onOutOfMemoryTyped<T>(nullptr, numElems);
         return p;
     }
 
@@ -69,7 +77,7 @@
     T* pod_calloc(size_t numElems) {
         T* p = js_pod_calloc<T>(numElems);
         if (MOZ_UNLIKELY(!p))
-            p = static_cast<T*>(onOutOfMemory(reinterpret_cast<void*>(1), numElems * sizeof(T)));
+            p = onOutOfMemoryTyped<T>(reinterpret_cast<void*>(1), numElems);
         return p;
     }
 
@@ -77,7 +85,7 @@
     T* pod_realloc(T* prior, size_t oldSize, size_t newSize) {
         T* p2 = js_pod_realloc<T>(prior, oldSize, newSize);
         if (MOZ_UNLIKELY(!p2))
-            p2 = static_cast<T*>(onOutOfMemory(p2, newSize * sizeof(T)));
+            p2 = onOutOfMemoryTyped<T>(p2, newSize);
         return p2;
     }
 
diff -Nru mozjs38-38.2.1~rc0/js/src/jsapi.h mozjs38-38.8.0~repack1/js/src/jsapi.h
--- mozjs38-38.2.1~rc0/js/src/jsapi.h	2015-09-17 20:12:22.000000000 +0000
+++ mozjs38-38.8.0~repack1/js/src/jsapi.h	2016-04-20 21:17:34.000000000 +0000
@@ -275,10 +275,6 @@
         return map.sizeOfIncludingThis(mallocSizeOf);
     }
 
-    uint32_t generation() const {
-        return map.generation();
-    }
-
     /************************************************** Shorthand operations */
 
     bool has(const Lookup& l) const {
@@ -390,10 +386,6 @@
         return set.sizeOfIncludingThis(mallocSizeOf);
     }
 
-    uint32_t generation() const {
-        return set.generation();
-    }
-
     /************************************************** Shorthand operations */
 
     bool has(const Lookup& l) const {
diff -Nru mozjs38-38.2.1~rc0/js/src/jsarray.cpp mozjs38-38.8.0~repack1/js/src/jsarray.cpp
--- mozjs38-38.2.1~rc0/js/src/jsarray.cpp	2015-09-17 20:12:22.000000000 +0000
+++ mozjs38-38.8.0~repack1/js/src/jsarray.cpp	2016-04-20 21:17:34.000000000 +0000
@@ -2661,6 +2661,7 @@
         narr = NewDenseEmptyArray(cx);
         if (!narr)
             return false;
+        TryReuseArrayGroup(aobj, narr);
         args.rval().setObject(*narr);
         length = 0;
     }
diff -Nru mozjs38-38.2.1~rc0/js/src/jscntxt.h mozjs38-38.8.0~repack1/js/src/jscntxt.h
--- mozjs38-38.2.1~rc0/js/src/jscntxt.h	2015-09-17 20:12:22.000000000 +0000
+++ mozjs38-38.8.0~repack1/js/src/jscntxt.h	2016-04-20 21:17:34.000000000 +0000
@@ -35,11 +35,11 @@
 /* Detects cycles when traversing an object graph. */
 class AutoCycleDetector
 {
+    Generation hashsetGenerationAtInit;
     JSContext* cx;
     RootedObject obj;
-    bool cyclic;
-    uint32_t hashsetGenerationAtInit;
     ObjectSet::AddPtr hashsetAddPointer;
+    bool cyclic;
     MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
 
   public:
diff -Nru mozjs38-38.2.1~rc0/js/src/jscompartment.cpp mozjs38-38.8.0~repack1/js/src/jscompartment.cpp
--- mozjs38-38.2.1~rc0/js/src/jscompartment.cpp	2015-09-17 20:12:22.000000000 +0000
+++ mozjs38-38.8.0~repack1/js/src/jscompartment.cpp	2016-04-20 21:17:34.000000000 +0000
@@ -143,18 +143,10 @@
     jitRuntime_ = jrt;
 
     if (!jitRuntime_->initialize(cx)) {
-        js_ReportOutOfMemory(cx);
-
-        js_delete(jitRuntime_);
-        jitRuntime_ = nullptr;
-
-        JSCompartment* comp = cx->runtime()->atomsCompartment();
-        if (comp->jitCompartment_) {
-            js_delete(comp->jitCompartment_);
-            comp->jitCompartment_ = nullptr;
-        }
-
-        return nullptr;
+        // Handling OOM here is complicated: if we delete jitRuntime_ now, we
+        // will destroy the ExecutableAllocator, even though there may still be
+        // JitCode instances holding references to ExecutablePools.
+        CrashAtUnhandlableOOM("OOM in createJitRuntime");
     }
 
     return jitRuntime_;
diff -Nru mozjs38-38.2.1~rc0/js/src/jsobj.cpp mozjs38-38.8.0~repack1/js/src/jsobj.cpp
--- mozjs38-38.2.1~rc0/js/src/jsobj.cpp	2015-09-17 20:12:22.000000000 +0000
+++ mozjs38-38.8.0~repack1/js/src/jsobj.cpp	2016-04-20 21:17:34.000000000 +0000
@@ -1579,8 +1579,9 @@
         if (!res)
             return nullptr;
 
-        if (newKind != SingletonObject)
-            newScript->registerNewObject(res);
+        // Make sure group->newScript is still there.
+        if (newKind != SingletonObject && group->newScript())
+            group->newScript()->registerNewObject(res);
 
         return res;
     }
diff -Nru mozjs38-38.2.1~rc0/js/src/jsscript.cpp mozjs38-38.8.0~repack1/js/src/jsscript.cpp
--- mozjs38-38.2.1~rc0/js/src/jsscript.cpp	2015-09-17 20:12:22.000000000 +0000
+++ mozjs38-38.8.0~repack1/js/src/jsscript.cpp	2016-04-20 21:17:34.000000000 +0000
@@ -116,7 +116,10 @@
     // any time, such accesses are mediated by DebugScopeProxy (see
     // DebugScopeProxy::handleUnaliasedAccess).
     uint32_t nslots = CallObject::RESERVED_SLOTS;
-    uint32_t aliasedBodyLevelLexicalBegin = UINT16_MAX;
+
+    // Unless there are aliased body-level lexical bindings at all, set the
+    // begin index to an impossible slot number.
+    uint32_t aliasedBodyLevelLexicalBegin = LOCALNO_LIMIT;
     for (BindingIter bi(self); bi; bi++) {
         if (bi->aliased()) {
             // Per ES6, lexical bindings cannot be accessed until
@@ -3899,6 +3902,12 @@
     return false;
 }
 
+bool
+JSScript::mayReadFrameArgsDirectly()
+{
+    return argumentsHasVarBinding() || (function_ && function_->hasRest());
+}
+
 static inline void
 LazyScriptHash(uint32_t lineno, uint32_t column, uint32_t begin, uint32_t end,
                HashNumber hashes[3])
diff -Nru mozjs38-38.2.1~rc0/js/src/jsscript.h mozjs38-38.8.0~repack1/js/src/jsscript.h
--- mozjs38-38.2.1~rc0/js/src/jsscript.h	2015-09-17 20:12:22.000000000 +0000
+++ mozjs38-38.8.0~repack1/js/src/jsscript.h	2016-04-20 21:17:34.000000000 +0000
@@ -206,8 +206,8 @@
     uint16_t numArgs_;
     uint16_t numBlockScoped_;
     uint16_t numBodyLevelLexicals_;
-    uint16_t aliasedBodyLevelLexicalBegin_;
     uint16_t numUnaliasedBodyLevelLexicals_;
+    uint32_t aliasedBodyLevelLexicalBegin_;
     uint32_t numVars_;
     uint32_t numUnaliasedVars_;
 
@@ -1402,6 +1402,10 @@
      */
     inline void ensureNonLazyCanonicalFunction(JSContext* cx);
 
+    // Returns true if the script may read formal arguments on the stack
+    // directly, via lazy arguments or a rest parameter.
+    bool mayReadFrameArgsDirectly();
+
     JSFlatString* sourceData(JSContext* cx);
 
     static bool loadSource(JSContext* cx, js::ScriptSource* ss, bool* worked);
diff -Nru mozjs38-38.2.1~rc0/js/src/jswatchpoint.cpp mozjs38-38.8.0~repack1/js/src/jswatchpoint.cpp
--- mozjs38-38.2.1~rc0/js/src/jswatchpoint.cpp	2015-09-17 20:12:22.000000000 +0000
+++ mozjs38-38.8.0~repack1/js/src/jswatchpoint.cpp	2016-04-20 21:17:34.000000000 +0000
@@ -27,15 +27,15 @@
 
 class AutoEntryHolder {
     typedef WatchpointMap::Map Map;
+    Generation gen;
     Map& map;
     Map::Ptr p;
-    uint32_t gen;
     RootedObject obj;
     RootedId id;
 
   public:
     AutoEntryHolder(JSContext* cx, Map& map, Map::Ptr p)
-      : map(map), p(p), gen(map.generation()), obj(cx, p->key().object), id(cx, p->key().id)
+      : gen(map.generation()), map(map), p(p), obj(cx, p->key().object), id(cx, p->key().id)
     {
         MOZ_ASSERT(!p->value().held);
         p->value().held = true;
diff -Nru mozjs38-38.2.1~rc0/js/src/shell/jsheaptools.cpp mozjs38-38.8.0~repack1/js/src/shell/jsheaptools.cpp
--- mozjs38-38.2.1~rc0/js/src/shell/jsheaptools.cpp	2015-09-17 20:12:22.000000000 +0000
+++ mozjs38-38.8.0~repack1/js/src/shell/jsheaptools.cpp	2016-04-20 21:17:34.000000000 +0000
@@ -272,7 +272,7 @@
          * visited from the main loop.
          */
         Node n(kind);
-        uint32_t generation = map.generation();
+        Generation generation = map.generation();
         if (!map.add(a, cell, Move(n)) ||
             !work.append(Child(cell, kind)))
             return false;
diff -Nru mozjs38-38.2.1~rc0/js/src/vm/HelperThreads.cpp mozjs38-38.8.0~repack1/js/src/vm/HelperThreads.cpp
--- mozjs38-38.2.1~rc0/js/src/vm/HelperThreads.cpp	2015-09-17 20:12:16.000000000 +0000
+++ mozjs38-38.8.0~repack1/js/src/vm/HelperThreads.cpp	2016-04-20 21:17:38.000000000 +0000
@@ -203,7 +203,7 @@
     alloc(JSRuntime::TEMP_LIFO_ALLOC_PRIMARY_CHUNK_SIZE),
     exclusiveContextGlobal(initCx, exclusiveContextGlobal),
     callback(callback), callbackData(callbackData),
-    script(nullptr), errors(cx), overRecursed(false)
+    script(initCx->runtime(), nullptr), errors(cx), overRecursed(false)
 {
 }
 
diff -Nru mozjs38-38.2.1~rc0/js/src/vm/HelperThreads.h mozjs38-38.8.0~repack1/js/src/vm/HelperThreads.h
--- mozjs38-38.2.1~rc0/js/src/vm/HelperThreads.h	2015-09-17 20:12:16.000000000 +0000
+++ mozjs38-38.8.0~repack1/js/src/vm/HelperThreads.h	2016-04-20 21:17:38.000000000 +0000
@@ -477,7 +477,7 @@
     // Holds the final script between the invocation of the callback and the
     // point where FinishOffThreadScript is called, which will destroy the
     // ParseTask.
-    JSScript* script;
+    PersistentRootedScript script;
 
     // Any errors or warnings produced during compilation. These are reported
     // when finishing the script.
diff -Nru mozjs38-38.2.1~rc0/js/src/vm/MallocProvider.h mozjs38-38.8.0~repack1/js/src/vm/MallocProvider.h
--- mozjs38-38.2.1~rc0/js/src/vm/MallocProvider.h	2015-09-17 20:12:16.000000000 +0000
+++ mozjs38-38.8.0~repack1/js/src/vm/MallocProvider.h	2016-04-20 21:17:38.000000000 +0000
@@ -64,30 +64,27 @@
             client()->updateMallocCounter(numElems * sizeof(T));
             return p;
         }
-        if (numElems & mozilla::tl::MulOverflowMask<sizeof(T)>::value) {
+        size_t bytes;
+        if (MOZ_UNLIKELY(!CalculateAllocSize<T>(numElems, &bytes))) {
             client()->reportAllocationOverflow();
             return nullptr;
         }
-        return (T*)client()->onOutOfMemory(nullptr, numElems * sizeof(T));
+        return static_cast<T*>(client()->onOutOfMemory(nullptr, bytes));
     }
 
     template <class T, class U>
     T* pod_malloc_with_extra(size_t numExtra) {
-        if (MOZ_UNLIKELY(numExtra & mozilla::tl::MulOverflowMask<sizeof(U)>::value)) {
+        size_t bytes;
+        if (MOZ_UNLIKELY((!CalculateAllocSizeWithExtra<T, U>(numExtra, &bytes)))) {
             client()->reportAllocationOverflow();
             return nullptr;
         }
-        size_t bytes = sizeof(T) + numExtra * sizeof(U);
-        if (MOZ_UNLIKELY(bytes < sizeof(T))) {
-            client()->reportAllocationOverflow();
-            return nullptr;
-        }
-        T* p = reinterpret_cast<T*>(js_pod_malloc<uint8_t>(bytes));
+        T* p = static_cast<T*>(js_malloc(bytes));
         if (MOZ_LIKELY(p)) {
             client()->updateMallocCounter(bytes);
             return p;
         }
-        return (T*)client()->onOutOfMemory(nullptr, bytes);
+        return static_cast<T*>(client()->onOutOfMemory(nullptr, bytes));
     }
 
     template <class T>
@@ -108,30 +105,27 @@
             client()->updateMallocCounter(numElems * sizeof(T));
             return p;
         }
-        if (numElems & mozilla::tl::MulOverflowMask<sizeof(T)>::value) {
+        size_t bytes;
+        if (MOZ_UNLIKELY(!CalculateAllocSize<T>(numElems, &bytes))) {
             client()->reportAllocationOverflow();
             return nullptr;
         }
-        return (T*)client()->onOutOfMemory(nullptr, numElems * sizeof(T));
+        return static_cast<T*>(client()->onOutOfMemory(nullptr, bytes));
     }
 
     template <class T, class U>
     T* pod_calloc_with_extra(size_t numExtra) {
-        if (MOZ_UNLIKELY(numExtra & mozilla::tl::MulOverflowMask<sizeof(U)>::value)) {
-            client()->reportAllocationOverflow();
-            return nullptr;
-        }
-        size_t bytes = sizeof(T) + numExtra * sizeof(U);
-        if (MOZ_UNLIKELY(bytes < sizeof(T))) {
+        size_t bytes;
+        if (MOZ_UNLIKELY((!CalculateAllocSizeWithExtra<T, U>(numExtra, &bytes)))) {
             client()->reportAllocationOverflow();
             return nullptr;
         }
-        T* p = reinterpret_cast<T*>(js_pod_calloc<uint8_t>(bytes));
+        T* p = static_cast<T*>(js_calloc(bytes));
         if (MOZ_LIKELY(p)) {
             client()->updateMallocCounter(bytes);
             return p;
         }
-        return (T*)client()->onOutOfMemory(nullptr, bytes);
+        return static_cast<T*>(client()->onOutOfMemory(nullptr, bytes));
     }
 
     template <class T>
@@ -151,11 +145,12 @@
                 client()->updateMallocCounter((newSize - oldSize) * sizeof(T));
             return p;
         }
-        if (newSize & mozilla::tl::MulOverflowMask<sizeof(T)>::value) {
+        size_t bytes;
+        if (MOZ_UNLIKELY(!CalculateAllocSize<T>(newSize, &bytes))) {
             client()->reportAllocationOverflow();
             return nullptr;
         }
-        return (T*)client()->onOutOfMemory(prior, newSize * sizeof(T));
+        return static_cast<T*>(client()->onOutOfMemory(prior, bytes));
     }
 
     JS_DECLARE_NEW_METHODS(new_, pod_malloc<uint8_t>, MOZ_ALWAYS_INLINE)
diff -Nru mozjs38-38.2.1~rc0/js/src/vm/Runtime.h mozjs38-38.8.0~repack1/js/src/vm/Runtime.h
--- mozjs38-38.2.1~rc0/js/src/vm/Runtime.h	2015-09-17 20:12:16.000000000 +0000
+++ mozjs38-38.8.0~repack1/js/src/vm/Runtime.h	2016-04-20 21:17:38.000000000 +0000
@@ -1354,11 +1354,12 @@
         T* p = pod_calloc<T>(numElems);
         if (MOZ_LIKELY(!!p))
             return p;
-        if (numElems & mozilla::tl::MulOverflowMask<sizeof(T)>::value) {
+        size_t bytes;
+        if (MOZ_UNLIKELY(!js::CalculateAllocSize<T>(numElems, &bytes))) {
             reportAllocationOverflow();
             return nullptr;
         }
-        return (T*)onOutOfMemoryCanGC(reinterpret_cast<void*>(1), numElems * sizeof(T));
+        return static_cast<T*>(onOutOfMemoryCanGC(reinterpret_cast<void*>(1), bytes));
     }
 
     template <typename T>
@@ -1366,11 +1367,12 @@
         T* p2 = pod_realloc<T>(p, oldSize, newSize);
         if (MOZ_LIKELY(!!p2))
             return p2;
-        if (newSize & mozilla::tl::MulOverflowMask<sizeof(T)>::value) {
+        size_t bytes;
+        if (MOZ_UNLIKELY(!js::CalculateAllocSize<T>(newSize, &bytes))) {
             reportAllocationOverflow();
             return nullptr;
         }
-        return (T*)onOutOfMemoryCanGC(p, newSize * sizeof(T));
+        return static_cast<T*>(onOutOfMemoryCanGC(p, bytes));
     }
 
     /*
diff -Nru mozjs38-38.2.1~rc0/js/src/vm/Shape.cpp mozjs38-38.8.0~repack1/js/src/vm/Shape.cpp
--- mozjs38-38.2.1~rc0/js/src/vm/Shape.cpp	2015-09-17 20:12:16.000000000 +0000
+++ mozjs38-38.8.0~repack1/js/src/vm/Shape.cpp	2016-04-20 21:17:38.000000000 +0000
@@ -387,8 +387,10 @@
         if (!shape)
             return nullptr;
         if (childRoot->hasSlot() && childRoot->slot() >= obj->lastProperty()->base()->slotSpan()) {
-            if (!obj->setSlotSpan(cx, childRoot->slot() + 1))
+            if (!obj->setSlotSpan(cx, childRoot->slot() + 1)) {
+                new (shape) Shape(obj->lastProperty()->base()->unowned(), 0);
                 return nullptr;
+            }
         }
         shape->initDictionaryShape(*childRoot, obj->numFixedSlots(), &obj->shape_);
     }
diff -Nru mozjs38-38.2.1~rc0/js/src/vm/StructuredClone.cpp mozjs38-38.8.0~repack1/js/src/vm/StructuredClone.cpp
--- mozjs38-38.2.1~rc0/js/src/vm/StructuredClone.cpp	2015-09-17 20:12:16.000000000 +0000
+++ mozjs38-38.8.0~repack1/js/src/vm/StructuredClone.cpp	2016-04-20 21:17:38.000000000 +0000
@@ -384,10 +384,11 @@
 Discard(uint64_t* buffer, size_t nbytes, const JSStructuredCloneCallbacks* cb, void* cbClosure)
 {
     MOZ_ASSERT(nbytes % sizeof(uint64_t) == 0);
-    if (nbytes < sizeof(uint64_t))
+    uint64_t* end = buffer + nbytes / sizeof(uint64_t);
+    uint64_t* point = buffer;
+    if (point == end)
         return; // Empty buffer
 
-    uint64_t* point = buffer;
     uint32_t tag, data;
     SCInput::getPair(point++, &tag, &data);
     if (tag != SCTAG_TRANSFER_MAP_HEADER)
@@ -399,14 +400,24 @@
     // freeTransfer should not GC
     JS::AutoSuppressGCAnalysis nogc;
 
+    if (point == end)
+        return;
+
     uint64_t numTransferables = LittleEndian::readUint64(point++);
     while (numTransferables--) {
+        if (point == end)
+            return;
+
         uint32_t ownership;
         SCInput::getPair(point++, &tag, &ownership);
         MOZ_ASSERT(tag >= SCTAG_TRANSFER_MAP_PENDING_ENTRY);
+        if (point == end)
+            return;
 
         void* content;
         SCInput::getPtr(point++, &content);
+        if (point == end)
+            return;
 
         uint64_t extraData = LittleEndian::readUint64(point++);
 
diff -Nru mozjs38-38.2.1~rc0/js/src/vm/TypeInference.cpp mozjs38-38.8.0~repack1/js/src/vm/TypeInference.cpp
--- mozjs38-38.2.1~rc0/js/src/vm/TypeInference.cpp	2015-09-17 20:12:16.000000000 +0000
+++ mozjs38-38.8.0~repack1/js/src/vm/TypeInference.cpp	2016-04-20 21:17:38.000000000 +0000
@@ -3966,6 +3966,12 @@
     for (unsigned i = 0; i < num; i++)
         typeArray[i].sweep(zone(), *oom);
 
+    if (oom->hadOOM()) {
+        // It's possible we OOM'd while copying freeze constraints, so they
+        // need to be regenerated.
+        hasFreezeConstraints_ = false;
+    }
+
     // Update the recompile indexes in any IonScripts still on the script.
     if (hasIonScript())
         ionScript()->recompileInfoRef().shouldSweep(types);
diff -Nru mozjs38-38.2.1~rc0/js/src/vm/TypeInference.h mozjs38-38.8.0~repack1/js/src/vm/TypeInference.h
--- mozjs38-38.2.1~rc0/js/src/vm/TypeInference.h	2015-09-17 20:12:16.000000000 +0000
+++ mozjs38-38.8.0~repack1/js/src/vm/TypeInference.h	2016-04-20 21:17:38.000000000 +0000
@@ -571,6 +571,9 @@
     void setOOM() {
         oom = true;
     }
+    bool hadOOM() const {
+        return oom;
+    }
 };
 
 /* Superclass common to stack and heap type sets. */
diff -Nru mozjs38-38.2.1~rc0/mfbt/moz.build mozjs38-38.8.0~repack1/mfbt/moz.build
--- mozjs38-38.2.1~rc0/mfbt/moz.build	2015-09-17 20:12:16.000000000 +0000
+++ mozjs38-38.8.0~repack1/mfbt/moz.build	2016-04-20 21:17:37.000000000 +0000
@@ -53,6 +53,7 @@
     'Move.h',
     'NullPtr.h',
     'NumericLimits.h',
+    'Opaque.h',
     'Pair.h',
     'PodOperations.h',
     'Poison.h',
diff -Nru mozjs38-38.2.1~rc0/mfbt/Opaque.h mozjs38-38.8.0~repack1/mfbt/Opaque.h
--- mozjs38-38.2.1~rc0/mfbt/Opaque.h	1970-01-01 00:00:00.000000000 +0000
+++ mozjs38-38.8.0~repack1/mfbt/Opaque.h	2016-04-20 21:17:37.000000000 +0000
@@ -0,0 +1,44 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+/* An opaque integral type supporting only comparison operators. */
+
+#ifndef mozilla_Opaque_h
+#define mozilla_Opaque_h
+
+#include "mozilla/TypeTraits.h"
+
+namespace mozilla {
+
+/**
+ * Opaque<T> is a replacement for integral T in cases where only comparisons
+ * must be supported, and it's desirable to prevent accidental dependency on
+ * exact values.
+ */
+template<typename T>
+class Opaque final
+{
+  static_assert(mozilla::IsIntegral<T>::value,
+                "mozilla::Opaque only supports integral types");
+
+  T mValue;
+
+public:
+  Opaque() {}
+  explicit Opaque(T aValue) : mValue(aValue) {}
+
+  bool operator==(const Opaque& aOther) const {
+    return mValue == aOther.mValue;
+  }
+
+  bool operator!=(const Opaque& aOther) const {
+    return !(*this == aOther);
+  }
+};
+
+} // namespace mozilla
+
+#endif /* mozilla_Opaque_h */
diff -Nru mozjs38-38.2.1~rc0/mfbt/WeakPtr.h mozjs38-38.8.0~repack1/mfbt/WeakPtr.h
--- mozjs38-38.2.1~rc0/mfbt/WeakPtr.h	2015-09-17 20:12:16.000000000 +0000
+++ mozjs38-38.8.0~repack1/mfbt/WeakPtr.h	2016-04-20 21:17:37.000000000 +0000
@@ -172,7 +172,13 @@
 
   WeakPtr& operator=(T* aOther)
   {
-    return *this = aOther->SelfReferencingWeakPtr();
+    if (aOther) {
+      *this = aOther->SelfReferencingWeakPtr();
+    } else if (!mRef || mRef->get()) {
+      // Ensure that mRef is dereferenceable in the uninitialized state.
+      mRef = new WeakReference(nullptr);
+    }
+    return *this;
   }
 
   MOZ_IMPLICIT WeakPtr(T* aOther)
