SPARC architecture specific patch. Probably cannot send upstream.

--- comm-esr31/mozilla/media/libcubeb/src/cubeb_pulse.c.orig	2015-03-30 22:18:12.000000000 +0530
+++ comm-esr31/mozilla/media/libcubeb/src/cubeb_pulse.c	2015-05-08 17:54:35.369052446 +0530
@@ -13,6 +13,11 @@
 #include "cubeb/cubeb.h"
 #include "cubeb-internal.h"
 
+#ifdef __sparc
+#define pa_nop() do {} while (0)
+#define MAX_ALLOC_SIZE (1024*1024*96)
+#define pa_assert(expr) pa_nop()
+#endif
 #ifdef DISABLE_LIBPULSE_DLOPEN
 #define WRAP(x) x
 #else
@@ -675,3 +678,47 @@ static struct cubeb_ops const pulse_ops
   .stream_get_position = pulse_stream_get_position,
   .stream_get_latency = pulse_stream_get_latency
 };
+
+#ifdef __sparc
+void* pa_xmalloc0(size_t size) {
+    void *p;
+    pa_assert(size > 0);
+    pa_assert(size < MAX_ALLOC_SIZE);
+
+    if (!(p = calloc(1, size)))
+        exit(1);
+
+    return p;
+}
+
+void *pa_xrealloc(void *ptr, size_t size) {
+    void *p;
+    pa_assert(size > 0);
+    pa_assert(size < MAX_ALLOC_SIZE);
+
+    if (!(p = realloc(ptr, size)))
+        exit(1);
+    return p;
+}
+
+void* pa_xmalloc(size_t size) {
+    void *p;
+    pa_assert(size > 0);
+    pa_assert(size < MAX_ALLOC_SIZE);
+
+    if (!(p = malloc(size)))
+        exit(1);
+
+    return p;
+}
+
+void* pa_xmemdup(const void *p, size_t l) {
+    if (!p)
+        return NULL;
+    else {
+        char *r = pa_xmalloc(l);
+        memcpy(r, p, l);
+        return r;
+    }
+}
+#endif
