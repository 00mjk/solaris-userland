# This patch is to fix:
# 16134419 rsyslogd forwarding over TCP does not detect server restart
# which was fixed in upstream version 6.4.1; this patch is a minor variant
# on the upstream patch, adapted for 6.2.0 .  This can go away once we
# upgrade to 6.4.1 or later, except for the CheckConnection() part in
# runtime/netstrm.c which needs to make sure to return a value, as there
# was a bug in the 6.4.1 code that failed to do this:
# http://bugzilla.adiscon.com/show_bug.cgi?id=511
--- rsyslog/runtime/netstrm.c.orig	2012-01-09 06:05:45.000000000 -0800
+++ rsyslog/runtime/netstrm.c	2014-01-29 10:16:47.131765870 -0800
@@ -250,11 +250,13 @@
 
 
 /* check connection - slim wrapper for NSD driver function */
-static void
+static rsRetVal
 CheckConnection(netstrm_t *pThis)
 {
+	DEFiRet;
 	ISOBJ_TYPE_assert(pThis, netstrm);
-	pThis->Drvr.CheckConnection(pThis->pDrvrData);
+	iRet = pThis->Drvr.CheckConnection(pThis->pDrvrData);
+	RETiRet;
 }
 
 
--- rsyslog/runtime/netstrm.h~	2011-12-01 02:26:19.000000000 -0800
+++ rsyslog/runtime/netstrm.h	2013-12-02 09:30:45.155766988 -0800
@@ -53,7 +53,7 @@
 	rsRetVal (*SetDrvrMode)(netstrm_t *pThis, int iMode);
 	rsRetVal (*SetDrvrAuthMode)(netstrm_t *pThis, uchar*);
 	rsRetVal (*SetDrvrPermPeers)(netstrm_t *pThis, permittedPeers_t*);
-	void     (*CheckConnection)(netstrm_t *pThis);	/* This is a trick mostly for plain tcp syslog */
+	rsRetVal (*CheckConnection)(netstrm_t *pThis);	/* This is a trick mostly for plain tcp syslog */
 	/* the GetSock() below is a hack to make imgssapi work. In the long term,
 	 * we should migrate imgssapi to a stream driver, which will relieve us of
 	 * this problem. Please note that nobody else should use GetSock(). Using it 
@@ -72,9 +72,10 @@
 	/* v4 */
 	rsRetVal (*EnableKeepAlive)(netstrm_t *pThis);
 ENDinterface(netstrm)
-#define netstrmCURR_IF_VERSION 4 /* increment whenever you change the interface structure! */
+#define netstrmCURR_IF_VERSION 5 /* increment whenever you change the interface structure! */
 /* interface version 3 added GetRemAddr()
  * interface version 4 added EnableKeepAlive() -- rgerhards, 2009-06-02
+ * interface version 5 changed return of CheckConnection from void to rsRetVal -- alorbach, 2012-09-06
  * */
 
 /* prototypes */
--- rsyslog/runtime/nsd.h.orig	2012-01-09 06:05:45.000000000 -0800
+++ rsyslog/runtime/nsd.h	2013-12-02 09:21:26.146155301 -0800
@@ -65,7 +65,7 @@
 	rsRetVal (*SetMode)(nsd_t *pThis, int mode); /* sets a driver specific mode - see driver doc for details */
 	rsRetVal (*SetAuthMode)(nsd_t *pThis, uchar*); /* sets a driver specific mode - see driver doc for details */
 	rsRetVal (*SetPermPeers)(nsd_t *pThis, permittedPeers_t*); /* sets driver permitted peers for auth needs */
-	void     (*CheckConnection)(nsd_t *pThis);	/* This is a trick mostly for plain tcp syslog */
+	rsRetVal (*CheckConnection)(nsd_t *pThis);	/* This is a trick mostly for plain tcp syslog */
 	rsRetVal (*GetSock)(nsd_t *pThis, int *pSock);
 	rsRetVal (*SetSock)(nsd_t *pThis, int sock);
 	/* GetSock() and SetSock() return an error if the driver does not use plain
@@ -82,9 +82,10 @@
 	/* v5 */
 	rsRetVal (*EnableKeepAlive)(nsd_t *pThis);
 ENDinterface(nsd)
-#define nsdCURR_IF_VERSION 5 /* increment whenever you change the interface structure! */
+#define nsdCURR_IF_VERSION 6 /* increment whenever you change the interface structure! */
 /* interface version 4 added GetRemAddr()
  * interface version 5 added EnableKeepAlive() -- rgerhards, 2009-06-02
+ * interface version 6 changed return of CheckConnection from void to rsRetVal -- alorbach, 2012-09-06
  */
 
 /* interface  for the select call */
--- rsyslog/runtime/nsd_gtls.c~	2012-01-09 06:05:45.000000000 -0800
+++ rsyslog/runtime/nsd_gtls.c	2013-12-02 10:14:55.324156585 -0800
@@ -1310,13 +1310,16 @@
  * This is a dummy here. For details, check function common in ptcp driver.
  * rgerhards, 2008-06-09
  */
-static void
+static rsRetVal
 CheckConnection(nsd_t __attribute__((unused)) *pNsd)
 {
+	DEFiRet;
 	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;
 	ISOBJ_TYPE_assert(pThis, nsd_gtls);
 
-	nsd_ptcp.CheckConnection(pThis->pTcp);
+	CHKiRet(nsd_ptcp.CheckConnection(pThis->pTcp));
+finalize_it:
+	RETiRet;
 }
 
 
--- rsyslog/runtime/nsd_ptcp.c~	2012-01-09 06:05:17.000000000 -0800
+++ rsyslog/runtime/nsd_ptcp.c	2013-12-02 10:13:48.561929979 -0800
@@ -726,9 +726,10 @@
  * http://blog.gerhards.net/2008/06/getting-bit-more-reliability-from-plain.html
  * rgerhards, 2008-06-09
  */
-static void
+static rsRetVal
 CheckConnection(nsd_t *pNsd)
 {
+	DEFiRet;
 	int rc;
 	char msgbuf[1]; /* dummy */
 	nsd_ptcp_t *pThis = (nsd_ptcp_t*) pNsd;
@@ -741,7 +742,10 @@
 		 * need to close our side, too.
 		 */
 		sockClose(&pThis->sock);
+		ABORT_FINALIZE(RS_RET_IO_ERROR);
 	}
+finalize_it:
+	RETiRet;
 }
 
 
--- rsyslog/tools/omfwd.c.orig	2012-01-09 06:05:45.000000000 -0800
+++ rsyslog/tools/omfwd.c	2013-12-02 09:01:51.293926230 -0800
@@ -310,7 +310,7 @@
 
 	alreadySent = 0;
 dbgprintf("omfwd: XXXX: pData %p, pNetStrm %p\n", pData, pData->pNetstrm);
-	netstrm.CheckConnection(pData->pNetstrm); /* hack for plain tcp syslog - see ptcp driver for details */
+	CHKiRet(netstrm.CheckConnection(pData->pNetstrm)); /* hack for plain tcp syslog - see ptcp driver for details */
 	while(alreadySent != len) {
 		lenSend = len - alreadySent;
 		CHKiRet(netstrm.Send(pData->pNetstrm, buf+alreadySent, &lenSend));
@@ -319,6 +319,12 @@
 	}
 
 finalize_it:
+	if(iRet != RS_RET_OK) {
+		/* error! */
+		dbgprintf("TCPSendBuf error %d, destruct TCP Connection!\n", iRet);
+		DestructTCPInstanceData(pData);
+		iRet = RS_RET_SUSPENDED;
+	}
 	RETiRet;
 }
 
@@ -363,6 +369,7 @@
 {
 	DEFiRet;
 	instanceData *pData = (instanceData *) pvData;
+	dbgprintf("TCPSendPrepRetry performs a DestructTCPInstanceData\n");
 
 	assert(pData != NULL);
 	DestructTCPInstanceData(pData);
@@ -380,6 +387,7 @@
 
 	assert(pData != NULL);
 	if(pData->pNetstrm == NULL) {
+		dbgprintf("TCPSendInit CREATE\n");
 		CHKiRet(netstrms.Construct(&pData->pNS));
 		/* the stream driver must be set before the object is finalized! */
 		CHKiRet(netstrms.SetDrvrName(pData->pNS, cs.pszStrmDrvr));
@@ -403,6 +411,7 @@
 
 finalize_it:
 	if(iRet != RS_RET_OK) {
+		dbgprintf("TCPSendInit FAILED with %d.\n", iRet);
 		DestructTCPInstanceData(pData);
 	}
 
