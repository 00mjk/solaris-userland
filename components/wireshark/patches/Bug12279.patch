From 5ca557c31e3e799068c4531deaed78792845027d Mon Sep 17 00:00:00 2001
From: Petr Sumbera <petr.sumbera@oracle.com>
Date: Wed, 23 Mar 2016 02:02:34 -0700
Subject: [PATCH] support for IP-over-Infiniband - pcap encapsulation

Bug: 12279
Change-Id: Ib6c54f8b86d95c5546bc800749f124cd0dbb8ff0
Reviewed-on: https://code.wireshark.org/review/14585
Petri-Dish: Alexis La Goutte <alexis.lagoutte@gmail.com>
Tested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>
Reviewed-by: Alexis La Goutte <alexis.lagoutte@gmail.com>
---
 epan/dissectors/packet-ipoib.c |   97 +++++++++++++++++++++++++++++++++++-----
 wiretap/pcap-common.c          |    2 +-
 wiretap/snoop.c                |    2 +-
 wiretap/wtap.h                 |    3 +-
 4 files changed, 91 insertions(+), 13 deletions(-)

diff --git a/epan/dissectors/packet-ipoib.c b/epan/dissectors/packet-ipoib.c
index 7d8c527..91af43a 100644
--- epan/dissectors/packet-ipoib.c
+++ epan/dissectors/packet-ipoib.c
@@ -30,11 +30,21 @@
 void proto_register_ipoib(void);
 void proto_reg_handoff_ipoib(void);
 
-static int proto_ipoib = -1;
-static int hf_type     = -1;
-static int hf_reserved = -1;
+static int proto_ipoib          = -1;
+static int hf_dgid              = -1;
+static int hf_daddr             = -1;
+static int hf_daddr_qpn         = -1;
+static int hf_grh               = -1;
+static int hf_grh_ip_version    = -1;
+static int hf_grh_traffic_class = -1;
+static int hf_grh_flow_label    = -1;
+static int hf_grh_sqpn          = -1;
+static int hf_grh_sgid          = -1;
+static int hf_type              = -1;
+static int hf_reserved          = -1;
 
 static gint ett_raw = -1;
+static gint ett_hdr = -1;
 
 static dissector_handle_t arp_handle;
 static dissector_handle_t ip_handle;
@@ -44,9 +54,14 @@
 dissect_ipoib(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
 {
   proto_tree *fh_tree;
+  proto_tree *fh_subtree;
   proto_item *ti;
   tvbuff_t   *next_tvb;
   guint16     type;
+  int         grh_size = 0;
+
+  if (pinfo->phdr->pkt_encap == WTAP_ENCAP_IP_OVER_IB_PCAP)
+    grh_size = 40;
 
   /* load the top pane info. This should be overwritten by
      the next protocol in the stack */
@@ -55,16 +70,40 @@ dissect_ipoib(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U
 
   /* populate a tree in the second pane with the IPoIB header data */
   if (tree) {
-    ti = proto_tree_add_item (tree, proto_ipoib, tvb, 0, 4, ENC_NA);
+    ti = proto_tree_add_item (tree, proto_ipoib, tvb, 0, grh_size + 4, ENC_NA);
     fh_tree = proto_item_add_subtree(ti, ett_raw);
 
-    proto_tree_add_item(fh_tree, hf_type, tvb, 0, 2, ENC_BIG_ENDIAN);
-    proto_tree_add_item(fh_tree, hf_reserved, tvb, 2, 2, ENC_BIG_ENDIAN);
+    /* for PCAP data populate subtree with GRH pseudo header data */
+    if (pinfo->phdr->pkt_encap == WTAP_ENCAP_IP_OVER_IB_PCAP) {
+
+      /* Zero means GRH is not valid (unicast). Only destination
+         address is set. */
+      if (tvb_get_ntohs(tvb, 0) == 0) {
+        ti = proto_tree_add_item (fh_tree, hf_daddr, tvb, 20, 20, ENC_NA);
+        fh_subtree = proto_item_add_subtree(ti, ett_hdr);
+
+        proto_tree_add_item(fh_subtree, hf_daddr_qpn, tvb, 21, 3, ENC_BIG_ENDIAN);
+        proto_tree_add_item(fh_subtree, hf_dgid, tvb, 24, 16, ENC_NA);
+      } else {
+        ti = proto_tree_add_item (fh_tree, hf_grh, tvb, 0, 40, ENC_NA);
+        fh_subtree = proto_item_add_subtree(ti, ett_hdr);
+
+        proto_tree_add_item(fh_subtree, hf_grh_ip_version, tvb, 0, 1, ENC_BIG_ENDIAN);
+        proto_tree_add_item(fh_subtree, hf_grh_traffic_class, tvb, 0, 2, ENC_BIG_ENDIAN);
+        proto_tree_add_item(fh_subtree, hf_grh_flow_label,tvb, 0, 4, ENC_BIG_ENDIAN);
+        proto_tree_add_item(fh_subtree, hf_grh_sqpn, tvb, 5, 3, ENC_BIG_ENDIAN);
+        proto_tree_add_item(fh_subtree, hf_grh_sgid, tvb, 8, 16, ENC_NA);
+        proto_tree_add_item(fh_subtree, hf_dgid, tvb, 24, 16, ENC_NA);
+      }
+    }
+
+    proto_tree_add_item(fh_tree, hf_type, tvb, grh_size + 0, 2, ENC_BIG_ENDIAN);
+    proto_tree_add_item(fh_tree, hf_reserved, tvb, grh_size + 2, 2, ENC_BIG_ENDIAN);
   }
 
-  next_tvb = tvb_new_subset_remaining(tvb, 4);
+  next_tvb = tvb_new_subset_remaining(tvb, grh_size + 4);
 
-  type = tvb_get_ntohs(tvb, 0);
+  type = tvb_get_ntohs(tvb, grh_size + 0);
   switch (type) {
   case ETHERTYPE_IP:
     call_dissector(ip_handle, next_tvb, pinfo, tree);
@@ -85,6 +124,42 @@ void
 proto_register_ipoib(void)
 {
   static hf_register_info hf[] = {
+    { &hf_daddr,
+      { "Destination address", "ipoib.daddr",
+        FT_NONE, BASE_NONE, NULL, 0x0,
+        NULL, HFILL}},
+    { &hf_daddr_qpn,
+      { "Destination QPN", "ipoib.daddr.qpn",
+        FT_UINT24, BASE_HEX, NULL, 0x0,
+        NULL, HFILL}},
+    { &hf_dgid,
+      { "Destination GID", "ipoib.dgid",
+        FT_IPv6, BASE_NONE, NULL, 0x0,
+        NULL, HFILL }},
+    { &hf_grh,
+      { "Global Route Header", "ipoib.grh",
+        FT_NONE, BASE_NONE, NULL, 0x0,
+        NULL, HFILL}},
+    { &hf_grh_ip_version, {
+       "IP Version", "ipoib.grh.ipver",
+       FT_UINT8, BASE_DEC, NULL, 0xF0,
+       NULL, HFILL}},
+    { &hf_grh_traffic_class, {
+       "Traffic Class", "ipoib.grh.tclass",
+       FT_UINT16, BASE_DEC, NULL, 0x0FF0,
+       NULL, HFILL}},
+    { &hf_grh_flow_label, {
+       "Flow Label", "ipoib.grh.flowlabel",
+       FT_UINT32, BASE_DEC, NULL, 0x000FFFFF,
+       NULL, HFILL}},
+    { &hf_grh_sqpn,
+      { "Source QPN", "ipoib.grh.sqpn",
+        FT_UINT24, BASE_HEX, NULL, 0x0,
+        NULL, HFILL}},
+    { &hf_grh_sgid,
+      { "Source GID", "ipoib.grh.sgid",
+        FT_IPv6, BASE_NONE, NULL, 0x0,
+        NULL, HFILL }},
     { &hf_type,
       { "Type", "ipoib.type",
         FT_UINT16, BASE_HEX, VALS(etype_vals), 0x0,
@@ -96,7 +171,8 @@ proto_register_ipoib(void)
   };
 
   static gint *ett[] = {
-    &ett_raw
+    &ett_raw,
+    &ett_hdr
   };
 
   proto_ipoib = proto_register_protocol("IP over Infiniband", "IPoIB", "ipoib");
@@ -117,7 +193,8 @@
   ipv6_handle = find_dissector("ipv6");
 
   ipoib_handle = create_dissector_handle(dissect_ipoib, proto_ipoib);
-  dissector_add_uint("wtap_encap", WTAP_ENCAP_IP_OVER_IB, ipoib_handle);
+  dissector_add_uint("wtap_encap", WTAP_ENCAP_IP_OVER_IB_SNOOP, ipoib_handle);
+  dissector_add_uint("wtap_encap", WTAP_ENCAP_IP_OVER_IB_PCAP, ipoib_handle);
 }
 
 /*
diff --git a/wiretap/pcap-common.c b/wiretap/pcap-common.c
index 9d6826b..297387a 100644
--- wiretap/pcap-common.c
+++ wiretap/pcap-common.c
@@ -400,7 +400,7 @@ static const struct {
 	/* netANALYZER pseudo-header in transparent mode */
 	{ 241,		WTAP_ENCAP_NETANALYZER_TRANSPARENT },
 	/* IP-over-Infiniband, as specified by RFC 4391 section 6 */
-	{ 242,		WTAP_ENCAP_IP_OVER_IB },
+	{ 242,		WTAP_ENCAP_IP_OVER_IB_PCAP },
 	/* ISO/IEC 13818-1 MPEG2-TS packets */
 	{ 243,		WTAP_ENCAP_MPEG_2_TS },
 	/* NFC LLCP */
diff --git a/wiretap/snoop.c b/wiretap/snoop.c
index da88bb4..3a7cc9e 100644
--- wiretap/snoop.c
+++ wiretap/snoop.c
@@ -210,7 +210,7 @@ wtap_open_return_val snoop_open(wtap *wth, int *err, gchar **err_info)
 		WTAP_ENCAP_UNKNOWN,	/* 100VG-AnyLAN Token Ring */
 		WTAP_ENCAP_UNKNOWN,	/* "ISO 8802/3 and Ethernet" */
 		WTAP_ENCAP_UNKNOWN,	/* 100BaseT (but that's just Ethernet) */
-		WTAP_ENCAP_IP_OVER_IB,	/* Infiniband */
+		WTAP_ENCAP_IP_OVER_IB_SNOOP,	/* Infiniband */
 	};
 	#define NUM_SNOOP_ENCAPS (sizeof snoop_encap / sizeof snoop_encap[0])
 	#define SNOOP_PRIVATE_BIT 0x80000000
diff --git a/wiretap/wtap.h b/wiretap/wtap.h
index 169f26c..3e10101 100644
--- wiretap/wtap.h
+++ wiretap/wtap.h
@@ -223,7 +223,7 @@
 #define WTAP_ENCAP_MIME                         134
 #define WTAP_ENCAP_NETANALYZER                  135
 #define WTAP_ENCAP_NETANALYZER_TRANSPARENT      136
-#define WTAP_ENCAP_IP_OVER_IB                   137
+#define WTAP_ENCAP_IP_OVER_IB_SNOOP             137
 #define WTAP_ENCAP_MPEG_2_TS                    138
 #define WTAP_ENCAP_PPP_ETHER                    139
 #define WTAP_ENCAP_NFC_LLCP                     140
@@ -264,6 +264,7 @@
 #define WTAP_ENCAP_LOOP                         175
 #define WTAP_ENCAP_JSON                         176
 #define WTAP_ENCAP_NSTRACE_3_5                  177
+#define WTAP_ENCAP_IP_OVER_IB_PCAP              180
 /* After adding new item here, please also add new item to encap_table_base array */
 
 #define WTAP_NUM_ENCAP_TYPES                    wtap_get_num_encap_types()
