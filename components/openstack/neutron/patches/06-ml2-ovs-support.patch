Changes to Neutron Open vSwitch agent to port it to Solaris. These changes
will eventually be proposed upstream.
  
*** neutron-2015.1.2/neutron/plugins/openvswitch/agent/ovs_neutron_agent.py	2015-10-13 10:35:16.000000000 -0700
--- new/neutron/plugins/openvswitch/agent/ovs_neutron_agent.py	2016-05-14 07:44:21.485893158 -0700
***************
*** 15,20 ****
--- 15,21 ----
  #    under the License.
  
  import hashlib
+ import platform
  import signal
  import sys
  import time
***************
*** 33,42 ****
--- 34,45 ----
  from neutron.agent.linux import ip_lib
  from neutron.agent import rpc as agent_rpc
  from neutron.agent import securitygroups_rpc as sg_rpc
+ from neutron.agent.solaris import net_lib
  from neutron.api.rpc.handlers import dvr_rpc
  from neutron.common import config as common_config
  from neutron.common import constants as q_const
  from neutron.common import exceptions
+ from neutron.common import log
  from neutron.common import topics
  from neutron.common import utils as q_utils
  from neutron import context
***************
*** 53,58 ****
--- 56,70 ----
  # A placeholder for dead vlans.
  DEAD_VLAN_TAG = q_const.MAX_VLAN_TAG + 1
  
+ # Solaris specific additional OpenFlow tables to steer packets to/from VNICs
+ # on top of VXLAN datalink.
+ LEARN_FROM_PORTS = 2
+ # Broadcast/Unknown Unicast/Multicast (BUM) tables
+ OUTBOUND_UCAST_BUM_TABLE = 3
+ INBOUND_UCAST_BUM_TABLE = 11
+ INBOUND_UCAST_TABLE = 12
+ INBOUND_BUM_TABLE = 13
+ 
  
  class DeviceListRetrievalError(exceptions.NeutronException):
      message = _("Unable to retrieve port details for devices: %(devices)s "
***************
*** 1685,1690 ****
--- 1697,2190 ----
                                 "Agent and Server side."))
  
  
+ class SolarisOVSNeutronAgent(OVSNeutronAgent):
+     """Solaris implementation of OVS L2 Agent"""
+ 
+     def __init__(self, integ_br, tun_br, local_ip,
+                  bridge_mappings, polling_interval, tunnel_types=None,
+                  veth_mtu=None, l2_population=False,
+                  enable_distributed_routing=False,
+                  minimize_polling=False,
+                  ovsdb_monitor_respawn_interval=(
+                      constants.DEFAULT_OVSDBMON_RESPAWN),
+                  arp_responder=False,
+                  prevent_arp_spoofing=True,
+                  use_veth_interconnection=False,
+                  quitting_rpc_timeout=None):
+         '''Please see the Base Class' constructor for parameters info
+         '''
+         self.tun_ofport = None
+         # mapping of VNIC's OpenFlow Port Number (ofport) to
+         # VXLAN segmentation id.
+         self.br_port_segid = {}
+         # mapping of VXLAN sgementation id to set of ports on that segment.
+         # The port is a ovs_lib.VifPort object.
+         self.br_segid_ports = {}
+         # mapping of Neutron port UUID to ovs_lib.VifPort object.
+         self.vif_ports = {}
+         super(SolarisOVSNeutronAgent, self).\
+             __init__(integ_br, tun_br,
+                      local_ip, bridge_mappings, polling_interval,
+                      tunnel_types, veth_mtu, l2_population,
+                      enable_distributed_routing, minimize_polling,
+                      ovsdb_monitor_respawn_interval, arp_responder,
+                      prevent_arp_spoofing, use_veth_interconnection,
+                      quitting_rpc_timeout)
+ 
+     def _setup_tunnel_port(self, br, port_name, remote_ip, tunnel_type):
+         LOG.debug(_("Setting up tunnel(%s) for remote_ip: %s") %
+                   (tunnel_type, remote_ip))
+         if tunnel_type != p_const.TYPE_VXLAN:
+             return
+         self.tun_br_ofports[tunnel_type][remote_ip] = remote_ip
+         remote_ips = self.tun_br_ofports[tunnel_type].values()
+         LOG.debug(_("current list of remote_ips: %s"), remote_ips)
+         for ofport, segmentation_id in self.br_port_segid.iteritems():
+             flood_local_ofports = self.br_segid_ports[segmentation_id]
+             self._mod_flood_to_tun_flows(ofport, remote_ips, segmentation_id,
+                                          flood_local_ofports - set([ofport]))
+ 
+     def cleanup_tunnel_port(self, br, remote_ip, tunnel_type):
+         LOG.debug(_("Cleaning up tunnel(%s) for remote_ip: %s") %
+                   (tunnel_type, remote_ip))
+         if tunnel_type != p_const.TYPE_VXLAN:
+             return
+         self.tun_br_ofports[tunnel_type].pop(remote_ip, None)
+         remote_ips = self.tun_br_ofports[tunnel_type].values()
+         for ofport, segmentation_id in self.br_port_segid.iteritems():
+             flood_local_ofports = self.br_segid_ports[segmentation_id]
+             self._mod_flood_to_tun_flows(ofport, remote_ips, segmentation_id,
+                                          flood_local_ofports - set([ofport]))
+ 
+     # The following methods are called through RPC.
+     #     add_fdb_entries(), remove_fdb_entries(), update_fdb_entries()
+     # These methods are overridden from L2populationRpcCallBackMixin class.
+     @log.log
+     def add_fdb_entries(self, context, fdb_entries, host=None):
+         # Needed for L2 Population support. Will be added later
+         pass
+ 
+     @log.log
+     def remove_fdb_entries(self, context, fdb_entries, host=None):
+         # Needed for L2 Population support. Will be added later
+         pass
+ 
+     @log.log
+     def update_fdb_entries(self, context, fdb_entries, host=None):
+         # Needed for L2 Population support. Will be added later
+         pass
+ 
+     def setup_integration_br(self):
+         '''Setup the integration bridge and remove all existing flows.'''
+ 
+         # Ensure the integration bridge is created.
+         # ovs_lib.OVSBridge.create() will run
+         #   ovs-vsctl -- --may-exist add-br BRIDGE_NAME
+         # which does nothing if bridge already exists.
+         self.int_br.create()
+         self.int_br.set_secure_mode()
+ 
+         self.int_br.remove_all_flows()
+         # Switch all traffic using normal-mode OVS only if tunneling
+         # is disabled. Otherwise, we will need to add various OpenFlow tables
+         # and flows to switch traffic.
+         if not self.enable_tunneling:
+             self.int_br.add_flow(priority=1, actions="normal")
+         # Add a canary flow to int_br to track OVS restarts
+         self.int_br.add_flow(table=constants.CANARY_TABLE, priority=0,
+                              actions="drop")
+ 
+     def setup_physical_bridges(self, bridge_mappings):
+         '''Makes sure that the uplink port for a given physical network
+         exists in the integration bridge.
+         '''
+         self.phys_brs = {}
+         # We do not use either int_ofports or phys_ofports below, however
+         # we need to initialize them to empty values since it is used in
+         # the common code which is mostly no-op for us.
+         self.int_ofports = {}
+         self.phys_ofports = {}
+         ovs = ovs_lib.BaseOVS()
+         for physical_network, uplink_port in bridge_mappings.iteritems():
+             LOG.info(_LI("Mapping physical network %(physical_network)s to "
+                          "uplink port %(uplink_port)s"),
+                      {'physical_network': physical_network,
+                       'uplink_port': uplink_port})
+             if not ovs.port_exists(uplink_port):
+                 LOG.error(_LE("Uplink port %(uplink_port)s for physical "
+                               "network %(physical_network)s does not exist. "
+                               "Agent terminated!"),
+                           {'physical_network': physical_network,
+                            'uplink_port': uplink_port})
+                 sys.exit(1)
+             self.phys_brs[physical_network] = uplink_port
+ 
+     def setup_ancillary_bridges(self, integ_br, tun_br):
+         '''Setup ancillary bridges - for example br-ex.'''
+         ovs = ovs_lib.BaseOVS()
+         ovs_bridges = set(ovs.get_bridges())
+         # Remove all known bridges
+         ovs_bridges.remove(integ_br)
+ 
+         # Filter list of bridges to those that have external
+         # bridge-id's configured
+         br_names = []
+         for bridge in ovs_bridges:
+             bridge_id = ovs.get_bridge_external_bridge_id(bridge)
+             if bridge_id != bridge:
+                 br_names.append(bridge)
+         ovs_bridges.difference_update(br_names)
+         ancillary_bridges = []
+         for bridge in ovs_bridges:
+             br = ovs_lib.OVSBridge(bridge)
+             LOG.info(_LI('Adding %s to list of bridges.'), bridge)
+             ancillary_bridges.append(br)
+         return ancillary_bridges
+ 
+     def reset_tunnel_br(self, tun_br_name=None):
+         '''(re)initialize the tunnel bridge.
+ 
+         :param tun_br_name: the name of the tunnel bridge.
+         '''
+         # Solaris doesn't have a separate tunnel bridge, instead we
+         # re-use the integration bridge itself.
+         if self.tun_br is None:
+             self.tun_br = self.int_br
+ 
+         # create ovs.vxlan1 datalink and add it to integration bridge
+         if not self.local_ip:
+             LOG.error(_LE("local_ip parameter is not set. Cannot have "
+                           "tunneling enabled without it. Agent terminated!"))
+             exit(1)
+         if not net_lib.Datalink.datalink_exists("ovs.vxlan1"):
+             # create the required vxlan
+             cmd = ['/usr/sbin/dladm', 'create-vxlan', '-t', '-p',
+                    'addr=%s,vni=flow' % (self.local_ip), 'ovs.vxlan1']
+             try:
+                 utils.execute(cmd)
+             except Exception as e:
+                 LOG.error(_LE("failed to create VXLAN tunnel end point "
+                               "ovs.vxlan1: %s. Agent terminated!") % (e))
+                 exit(1)
+         # set openvswitch property to on
+         try:
+             cmd = ['/usr/sbin/dladm', 'show-linkprop', '-p',
+                    'openvswitch', '-co', 'value', 'ovs.vxlan1']
+             stdout = utils.execute(cmd)
+             if stdout.strip() == 'off':
+                 cmd = ['/usr/sbin/dladm', 'set-linkprop', '-t', '-p',
+                        'openvswitch=on', 'ovs.vxlan1']
+                 utils.execute(cmd)
+         except Exception as e:
+             LOG.error(_LE("failed to set 'openvswitch' property on "
+                           "ovs.vxlan1: %s. Agent terminated!") % (e))
+             exit(1)
+ 
+         attrs = [('type', 'vxlan'),
+                  ('options', {'remote_ip': 'flow'}),
+                  ('options', {'key': 'flow'})]
+         self.tun_br.replace_port('ovs.vxlan1', *attrs)
+         self.tun_ofport = self.tun_br.get_port_ofport('ovs.vxlan1')
+         if self.tun_ofport == constants.OFPORT_INVALID:
+             LOG.error(_LE("Failed to add ovs.vxlan1 to integration bridge. "
+                           "Cannot have tunneling enabled on this agent. "
+                           "Agent terminated!"))
+             exit(1)
+ 
+     def setup_tunnel_br(self):
+         '''Setup the tunnel bridge
+ 
+         Add all flows to the tunnel bridge.
+         '''
+ 
+         #
+         # Add flows for inbound packets
+         #
+ 
+         # Table 0 (default) will sort incoming traffic depending on in_port.
+         # Forward all the packets coming in from all the ports of the bridge
+         # to respective learning tables (LEARN_FROM_TUN or LEARN_FROM_PORTS).
+         self.tun_br.add_flow(priority=1,
+                              in_port=self.tun_ofport,
+                              actions="resubmit(,%s)" %
+                              constants.LEARN_FROM_TUN)
+         self.tun_br.add_flow(priority=0, actions="drop")
+ 
+         # LEARN_FROM_TUN table will have a single flow using a learn action to
+         # dynamically set-up flows in UCAST_TO_TUN corresponding to remote mac
+         # addresses
+         learned_flow = ("table=%s,"
+                         "priority=1,"
+                         "hard_timeout=300,"
+                         "NXM_NX_TUN_ID[],"
+                         "NXM_OF_ETH_DST[]=NXM_OF_ETH_SRC[],"
+                         "load:NXM_NX_TUN_IPV4_SRC[]->NXM_NX_TUN_IPV4_DST[],"
+                         "output:NXM_OF_IN_PORT[]" %
+                         constants.UCAST_TO_TUN)
+ 
+         # Once remote mac addresses are learned, packets are sent to
+         # INBOUND_UCAST_BUM_TABLE where the packets are triaged based on
+         # whether they are unicast or broadcast/multicast and sent to
+         # respective tables either for forwarding or flooding
+         self.tun_br.add_flow(table=constants.LEARN_FROM_TUN,
+                              priority=1,
+                              actions="learn(%s),resubmit(,%s)" %
+                              (learned_flow, INBOUND_UCAST_BUM_TABLE))
+ 
+         # INBOUND_UCAST_TABLE handles forwarding the packet to the right port
+         self.tun_br.add_flow(table=INBOUND_UCAST_BUM_TABLE,
+                              priority=0,
+                              dl_dst="00:00:00:00:00:00/01:00:00:00:00:00",
+                              actions="resubmit(,%s)" % INBOUND_UCAST_TABLE)
+ 
+         # INBOUND_BUM_TABLE handles flooding for broadcast/unknown-unicast/
+         # multicast packets
+         self.tun_br.add_flow(table=INBOUND_UCAST_BUM_TABLE,
+                              priority=0,
+                              dl_dst="01:00:00:00:00:00/01:00:00:00:00:00",
+                              actions="resubmit(,%s)" % INBOUND_BUM_TABLE)
+ 
+         # INBOUND_UCAST_TABLE has flows dynamically added by learn action of
+         # a flow in LEARN_FROM_PORTS table. These flows forward a packet to a
+         # port that matches the destination MAC address. If no flow matches,
+         # then the packet will be resubmitted to INBOUND_BUM_TABLE for
+         # flooding.
+         self.tun_br.add_flow(table=INBOUND_UCAST_TABLE,
+                              priority=0,
+                              actions="resubmit(,%s)" %
+                              INBOUND_BUM_TABLE)
+         self.tun_br.add_flow(table=INBOUND_BUM_TABLE,
+                              priority=0,
+                              actions="drop")
+ 
+         # Egress unicast will be handled in table UCAST_TO_TUN, where remote
+         # mac addresses will be learned. For now, just add a default flow that
+         # will resubmit unknown unicasts to table FLOOD_TO_TUN to treat them
+         # as broadcasts/multicasts
+         self.tun_br.add_flow(table=constants.UCAST_TO_TUN,
+                              priority=0,
+                              actions="resubmit(,%s)" %
+                              constants.FLOOD_TO_TUN)
+ 
+         # FLOOD_TO_TUN will handle flooding to tunnels based on segmentation
+         # id. For now, add a default drop action
+         self.tun_br.add_flow(table=constants.FLOOD_TO_TUN,
+                              priority=0,
+                              actions="drop")
+ 
+         #
+         # add flows for outbound packets
+         #
+ 
+         # LEARN_FROM_PORTS table will have a single flow using two learn
+         # actions to dynamically set-up flows in INBOUND_UCAST_TABLE and
+         # UCAST_TO_TUN corresponding to local mac addresses
+         learned_flow = ("table=%s,"
+                         "priority=1,"
+                         "hard_timeout=300,"
+                         "NXM_NX_TUN_ID[],"
+                         "NXM_OF_ETH_DST[]=NXM_OF_ETH_SRC[],"
+                         "output:NXM_OF_IN_PORT[]")
+         self.tun_br.add_flow(table=LEARN_FROM_PORTS,
+                              priority=1,
+                              actions="learn(%s),learn(%s),resubmit(,%s)" %
+                              (learned_flow % INBOUND_UCAST_TABLE,
+                               learned_flow % constants.UCAST_TO_TUN,
+                               OUTBOUND_UCAST_BUM_TABLE))
+ 
+         # Once local MAC addresses are learned, packets are sent to
+         # OUTBOUND_UCAST_BUM_TABLE where the packet is triaged based on whether
+         # they are unicast or broadcast/multicast and sent to respective tables
+         # either for forwarding or for flooding
+         self.tun_br.add_flow(table=OUTBOUND_UCAST_BUM_TABLE,
+                              priority=0,
+                              dl_dst="00:00:00:00:00:00/01:00:00:00:00:00",
+                              actions="resubmit(,%s)" % constants.UCAST_TO_TUN)
+         # Broadcasts/multicasts go to table FLOOD_TO_TUN that handles flooding
+         self.tun_br.add_flow(table=OUTBOUND_UCAST_BUM_TABLE,
+                              priority=0,
+                              dl_dst="01:00:00:00:00:00/01:00:00:00:00:00",
+                              actions="resubmit(,%s)" % constants.FLOOD_TO_TUN)
+ 
+     def check_changed_vlans(self, registered_ports):
+         # Not applicable to Solaris
+         return []
+ 
+     def _mod_flood_to_tun_flows(self, ofport, remote_ips, segmentation_id,
+                                 local_ofports):
+         LOG.debug(_("Modifying flooding for %s to all %s for VNI %s on %s") %
+                   (ofport, remote_ips, segmentation_id, local_ofports))
+         if not local_ofports and not remote_ips:
+             return
+         action_prefix = ""
+         if local_ofports:
+             action_prefix = "output:%s" % _ofport_set_to_str(local_ofports)
+         if not remote_ips:
+             assert local_ofports
+             self.tun_br.mod_flow(table=constants.FLOOD_TO_TUN,
+                                  in_port="%s" % ofport,
+                                  actions="%s" % action_prefix)
+             return
+         action_str = ""
+         if action_prefix:
+             action_str = "%s," % action_prefix
+         action_str += "set_tunnel:%s" % segmentation_id
+         # for each of the remote_ip
+         for remote_ip in remote_ips:
+             action_str += ",set_field:%s->tun_dst,output:%s" % \
+                 (remote_ip, self.tun_ofport)
+ 
+         self.tun_br.mod_flow(table=constants.FLOOD_TO_TUN,
+                              in_port="%s" % ofport,
+                              actions="%s" % action_str)
+ 
+     def port_bound(self, port, net_uuid,
+                    network_type, physical_network,
+                    segmentation_id, fixed_ips, device_owner,
+                    ovs_restarted):
+         '''Bind port to net_uuid/lsw_id and install flow for inbound traffic
+         to vm.
+ 
+         :param port: a ovslib.VifPort object.
+         :param net_uuid: the net_uuid this port is to be associated with.
+         :param network_type: the network type ('gre', 'vlan', 'flat', 'local')
+         :param physical_network: the physical network for 'vlan' or 'flat'
+         :param segmentation_id: the VID for 'vlan' or tunnel ID for 'tunnel'
+         :param fixed_ips: the ip addresses assigned to this port
+         :param device_owner: the string indicative of owner of this port
+         :param ovs_restarted: indicates if this is called for an OVS restart.
+         '''
+ 
+         LOG.info(_LI("Setting up datapath for port: %s connected to "
+                      "network: %s of type: %s") % (port.vif_id, net_uuid,
+                                                    network_type))
+ 
+         if network_type in constants.TUNNEL_NETWORK_TYPES:
+             if self.enable_tunneling:
+                 remote_ips = self.tun_br_ofports[network_type].values()
+                 # add a flow to flood Broadcast/Unknown Unicast/Multicast
+                 # packets from this port to all the remote_ips and local
+                 # ports on port's segmentation_id.
+                 self._mod_flood_to_tun_flows(port.ofport, remote_ips,
+                     segmentation_id, self.br_segid_ports.get(segmentation_id))
+ 
+                 # add segmentation id for all the packets from this port and
+                 # send it to table 2 for learning.
+                 self.tun_br.add_flow(priority=1,
+                                      in_port="%s" % (port.ofport),
+                                      actions="set_tunnel:%s,"
+                                      "resubmit(,%s)" %
+                                      (segmentation_id, LEARN_FROM_PORTS))
+ 
+                 # update flow that steers inbound broadcast/unknown/multicast
+                 # packets on this segmentation id to all of the ports
+                 # (including this port)
+                 self.br_port_segid[port.ofport] = segmentation_id
+                 if self.br_segid_ports.get(segmentation_id):
+                     self.br_segid_ports[segmentation_id].add(port.ofport)
+                 else:
+                     self.br_segid_ports[segmentation_id] = set([port.ofport])
+                 ofports_str = \
+                     _ofport_set_to_str(self.br_segid_ports[segmentation_id])
+                 self.tun_br.mod_flow(table=INBOUND_BUM_TABLE,
+                                      tun_id=segmentation_id,
+                                      actions="output:%s" % ofports_str)
+                 # we need to modify flows for other ports that are part of
+                 # this segmentation ID
+                 ofports = self.br_segid_ports[segmentation_id]
+                 for ofport in ofports:
+                     if ofport == port.ofport:
+                         continue
+                     self._mod_flood_to_tun_flows(ofport, remote_ips,
+                                                  segmentation_id,
+                                                  ofports - set([ofport]))
+                 self.vif_ports[port.vif_id] = port
+             else:
+                 LOG.error(_LE("Cannot provision %(network_type)s network for "
+                               "net-id=%(net_uuid)s - tunneling disabled"),
+                           {'network_type': network_type,
+                            'net_uuid': net_uuid})
+         elif network_type == p_const.TYPE_FLAT:
+             if physical_network not in self.phys_brs:
+                 LOG.error(_LE("Cannot provision flat network for "
+                               "net-id=%(net_uuid)s - no uplink port for "
+                               "physical_network %(physical_network)s"),
+                           {'net_uuid': net_uuid,
+                            'physical_network': physical_network})
+         elif network_type == p_const.TYPE_VLAN:
+             if physical_network in self.phys_brs:
+                 # Do not bind a port if it's already bound
+                 cur_tag = self.int_br.db_get_val("Port", port.port_name, "tag")
+                 if cur_tag != segmentation_id:
+                     self.int_br.set_db_attribute("Port", port.port_name, "tag",
+                                                  segmentation_id)
+                 if port.ofport != -1:
+                     self.int_br.delete_flows(in_port=port.ofport)
+             else:
+                 LOG.error(_LE("Cannot provision VLAN network for "
+                               "net-id=%(net_uuid)s - no uplink-port for "
+                               "physical_network %(physical_network)s"),
+                           {'net_uuid': net_uuid,
+                            'physical_network': physical_network})
+         else:
+             LOG.error(_LE("Cannot provision unknown network type "
+                           "%(network_type)s for net-id=%(net_uuid)s"),
+                       {'network_type': network_type, 'net_uuid': net_uuid})
+ 
+     def port_unbound(self, vif_id, net_uuid=None):
+         '''Unbind port.
+ 
+         Removes all the OpenFlow rules associated with the port going away.
+ 
+         :param vif_id: the id of the vif
+         :param net_uuid: the net_uuid this port is associated with.
+         '''
+         LOG.info(_LI("Removing flows for port: %s" % (vif_id)))
+         if self.enable_tunneling:
+             port = self.vif_ports.pop(vif_id, None)
+             if port is None:
+                 return
+             # remove all the OpenFlows that we have added for this port
+             # across all the tables.
+             self.tun_br.delete_flows(in_port=port.ofport)
+             self.tun_br.delete_flows(table=constants.FLOOD_TO_TUN,
+                                      in_port=port.ofport)
+             segid = self.br_port_segid.pop(port.ofport, None)
+             if segid is None:
+                 return
+             self.tun_br.delete_flows(table=INBOUND_UCAST_TABLE,
+                                      tun_id=segid, dl_dst=port.vif_mac)
+             self.tun_br.delete_flows(table=constants.UCAST_TO_TUN,
+                                      tun_id=segid, dl_dst=port.vif_mac)
+             if self.br_segid_ports.get(segid) is None:
+                 return
+             self.br_segid_ports[segid].discard(port.ofport)
+             ofports = self.br_segid_ports[segid]
+             if ofports:
+                 # update brodcast/multicast table to not to include this port
+                 ofportstr = _ofport_set_to_str(ofports)
+                 self.tun_br.mod_flow(table=INBOUND_BUM_TABLE, tun_id=segid,
+                                      actions="output:%s" % ofportstr)
+                 for ofport in ofports:
+                     remote_ips = \
+                         self.tun_br_ofports[p_const.TYPE_VXLAN].values()
+                     self._mod_flood_to_tun_flows(ofport, remote_ips, segid,
+                                                  ofports - set([ofport]))
+             else:
+                 # if this was the last port for that segmentation ID, then
+                 # remove all associated flows from broadcast/multicast table
+                 self.tun_br.delete_flows(table=INBOUND_BUM_TABLE, tun_id=segid)
+ 
+     def port_dead(self, port, log_errors=True):
+         # Not required for Solaris
+         pass
+ 
+     def update_stale_ofport_rules(self):
+         # Not required for Solaris since we don't support ARP spoofing
+         # protection yet
+         pass
+ 
+ 
  def _ofport_set_to_str(ofport_set):
      return ",".join(map(str, ofport_set))
  
***************
*** 1696,1702 ****
      :returns: a map of agent configuration parameters
      """
      try:
!         bridge_mappings = q_utils.parse_mappings(config.OVS.bridge_mappings)
      except ValueError as e:
          raise ValueError(_("Parsing bridge_mappings failed: %s.") % e)
  
--- 2196,2210 ----
      :returns: a map of agent configuration parameters
      """
      try:
!         if platform.system() == "SunOS":
!             # In case of Solaris, we want to allow multiple physical networks
!             # to share the same uplink-port
!             bridge_mappings = \
!                 q_utils.parse_mappings(config.OVS.bridge_mappings,
!                                        unique_values=False)
!         else:
!             bridge_mappings = \
!                 q_utils.parse_mappings(config.OVS.bridge_mappings)
      except ValueError as e:
          raise ValueError(_("Parsing bridge_mappings failed: %s.") % e)
  
***************
*** 1749,1755 ****
          cfg.CONF.set_default('ip_lib_force_root', True)
  
      try:
!         agent = OVSNeutronAgent(**agent_config)
      except RuntimeError as e:
          LOG.error(_LE("%s Agent terminated!"), e)
          sys.exit(1)
--- 2257,2266 ----
          cfg.CONF.set_default('ip_lib_force_root', True)
  
      try:
!         if platform.system() == "SunOS":
!             agent = SolarisOVSNeutronAgent(**agent_config)
!         else:
!             agent = OVSNeutronAgent(**agent_config)
      except RuntimeError as e:
          LOG.error(_LE("%s Agent terminated!"), e)
          sys.exit(1)
