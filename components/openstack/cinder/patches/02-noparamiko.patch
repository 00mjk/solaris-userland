In-house patch for the temporary removal of Paramiko dependency in
Cinder.  This patch is Solaris-specific and not suitable for upstream

--- cinder-2013.2.3/cinder/utils.py.orig	2014-04-03 11:42:36.000000000 -0700
+++ cinder-2013.2.3/cinder/utils.py	2014-04-09 00:14:56.141352333 -0700
@@ -43,7 +43,6 @@
 from eventlet import greenthread
 from eventlet import pools
 from oslo.config import cfg
-import paramiko
 
 from cinder.brick.initiator import connector
 from cinder import exception
@@ -142,125 +141,6 @@
     return processutils.execute(*cmd, **kwargs)
 
 
-def check_ssh_injection(cmd_list):
-    ssh_injection_pattern = ['`', '$', '|', '||', ';', '&', '&&', '>', '>>',
-                             '<']
-
-    # Check whether injection attacks exist
-    for arg in cmd_list:
-        arg = arg.strip()
-
-        # Check for matching quotes on the ends
-        is_quoted = re.match('^(?P<quote>[\'"])(?P<quoted>.*)(?P=quote)$', arg)
-        if is_quoted:
-            # Check for unescaped quotes within the quoted argument
-            quoted = is_quoted.group('quoted')
-            if quoted:
-                if (re.match('[\'"]', quoted) or
-                        re.search('[^\\\\][\'"]', quoted)):
-                    raise exception.SSHInjectionThreat(command=str(cmd_list))
-        else:
-            # We only allow spaces within quoted arguments, and that
-            # is the only special character allowed within quotes
-            if len(arg.split()) > 1:
-                raise exception.SSHInjectionThreat(command=str(cmd_list))
-
-        # Second, check whether danger character in command. So the shell
-        # special operator must be a single argument.
-        for c in ssh_injection_pattern:
-            if arg == c:
-                continue
-
-            result = arg.find(c)
-            if not result == -1:
-                if result == 0 or not arg[result - 1] == '\\':
-                    raise exception.SSHInjectionThreat(command=cmd_list)
-
-
-def create_channel(client, width, height):
-    """Invoke an interactive shell session on server."""
-    channel = client.invoke_shell()
-    channel.resize_pty(width, height)
-    return channel
-
-
-class SSHPool(pools.Pool):
-    """A simple eventlet pool to hold ssh connections."""
-
-    def __init__(self, ip, port, conn_timeout, login, password=None,
-                 privatekey=None, *args, **kwargs):
-        self.ip = ip
-        self.port = port
-        self.login = login
-        self.password = password
-        self.conn_timeout = conn_timeout if conn_timeout else None
-        self.privatekey = privatekey
-        super(SSHPool, self).__init__(*args, **kwargs)
-
-    def create(self):
-        try:
-            ssh = paramiko.SSHClient()
-            ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
-            if self.password:
-                ssh.connect(self.ip,
-                            port=self.port,
-                            username=self.login,
-                            password=self.password,
-                            timeout=self.conn_timeout)
-            elif self.privatekey:
-                pkfile = os.path.expanduser(self.privatekey)
-                privatekey = paramiko.RSAKey.from_private_key_file(pkfile)
-                ssh.connect(self.ip,
-                            port=self.port,
-                            username=self.login,
-                            pkey=privatekey,
-                            timeout=self.conn_timeout)
-            else:
-                msg = _("Specify a password or private_key")
-                raise exception.CinderException(msg)
-
-            # Paramiko by default sets the socket timeout to 0.1 seconds,
-            # ignoring what we set thru the sshclient. This doesn't help for
-            # keeping long lived connections. Hence we have to bypass it, by
-            # overriding it after the transport is initialized. We are setting
-            # the sockettimeout to None and setting a keepalive packet so that,
-            # the server will keep the connection open. All that does is send
-            # a keepalive packet every ssh_conn_timeout seconds.
-            if self.conn_timeout:
-                transport = ssh.get_transport()
-                transport.sock.settimeout(None)
-                transport.set_keepalive(self.conn_timeout)
-            return ssh
-        except Exception as e:
-            msg = _("Error connecting via ssh: %s") % e
-            LOG.error(msg)
-            raise paramiko.SSHException(msg)
-
-    def get(self):
-        """
-        Return an item from the pool, when one is available.  This may
-        cause the calling greenthread to block. Check if a connection is active
-        before returning it. For dead connections create and return a new
-        connection.
-        """
-        conn = super(SSHPool, self).get()
-        if conn:
-            if conn.get_transport().is_active():
-                return conn
-            else:
-                conn.close()
-        return self.create()
-
-    def remove(self, ssh):
-        """Close an ssh client and remove it from free_items."""
-        ssh.close()
-        ssh = None
-        if ssh in self.free_items:
-            self.free_items.pop(ssh)
-        if self.current_size > 0:
-            self.current_size -= 1
-
-
 def cinderdir():
     import cinder
     return os.path.abspath(cinder.__file__).split('cinder/__init__.py')[0]

