This patch is to replace Linux-specific code with conditional checks in
the Cinder Brick code to support Cinder backup on Solaris. Patch has
not yet been submitted upstream.

--- cinder-2015.1.2/cinder/brick/initiator/connector.py.~1~	2015-10-13 09:27:35.000000000 -0700
+++ cinder-2015.1.2/cinder/brick/initiator/connector.py	2016-01-31 00:12:30.729547660 -0800
@@ -32,6 +32,8 @@ from cinder.brick.initiator import host_
 from cinder.brick.initiator import linuxfc
 from cinder.brick.initiator import linuxscsi
 from cinder.brick.remotefs import remotefs
+from cinder.brick.initiator import solarisfc
+from cinder.brick.initiator import solarisiscsi
 from cinder.i18n import _, _LE, _LW
 from cinder.openstack.common import loopingcall
 
@@ -72,7 +74,10 @@ def get_connector_properties(root_helper
     """
 
     iscsi = ISCSIConnector(root_helper=root_helper)
-    fc = linuxfc.LinuxFibreChannel(root_helper=root_helper)
+    if sys.platform == 'sunos5':
+        fc = solarisfc.SolarisFibreChannel()
+    else:
+        fc = linuxfc.LinuxFibreChannel(root_helper=root_helper)
 
     props = {}
     props['ip'] = my_ip
@@ -188,8 +193,11 @@ class InitiatorConnector(executor.Execut
                'of=/dev/null', 'count=1')
         out, info = None, None
         try:
-            out, info = self._execute(*cmd, run_as_root=run_as_root,
-                                      root_helper=self._root_helper)
+            if sys.platform == 'sunos5':
+                out, info = self._execute(*cmd)
+            else:
+                out, info = self._execute(*cmd, run_as_root=run_as_root,
+                                          root_helper=self._root_helper)
         except putils.ProcessExecutionError as e:
             LOG.error(_LE("Failed to access the device on the path "
                           "%(path)s: %(error)s %(info)s.") %
@@ -225,7 +233,10 @@ class ISCSIConnector(InitiatorConnector)
                  execute=putils.execute, use_multipath=False,
                  device_scan_attempts=DEVICE_SCAN_ATTEMPTS_DEFAULT,
                  *args, **kwargs):
-        self._linuxscsi = linuxscsi.LinuxSCSI(root_helper, execute)
+        if sys.platform == 'sunos5':
+            self._solarisiscsi = solarisiscsi.SolarisiSCSI()
+        else:
+            self._linuxscsi = linuxscsi.LinuxSCSI(root_helper, execute)
         super(ISCSIConnector, self).__init__(root_helper, driver=driver,
                                              execute=execute,
                                              device_scan_attempts=
@@ -235,6 +246,8 @@ class ISCSIConnector(InitiatorConnector)
 
     def set_execute(self, execute):
         super(ISCSIConnector, self).set_execute(execute)
+        if sys.platform == 'sunos5':
+            return
         self._linuxscsi.set_execute(execute)
 
     def _iterate_all_targets(self, connection_properties):
@@ -289,6 +302,9 @@ class ISCSIConnector(InitiatorConnector)
         Note that plural keys may be used when use_multipath=True
         """
 
+        if sys.platform == 'sunos5':
+            return self._solarisiscsi.connect_volume(connection_properties,
+                                                     self.device_scan_attempts)
         device_info = {'type': 'block'}
 
         if self.use_multipath:
@@ -365,6 +381,8 @@ class ISCSIConnector(InitiatorConnector)
         target_iqn(s) - iSCSI Qualified Name
         target_lun(s) - LUN id of the volume
         """
+        if sys.platform == 'sunos5':
+            return
         # Moved _rescan_iscsi and _rescan_multipath
         # from _disconnect_volume_multipath_iscsi to here.
         # Otherwise, if we do rescan after _linuxscsi.remove_multipath_device
@@ -431,6 +449,9 @@ class ISCSIConnector(InitiatorConnector)
 
     def get_initiator(self):
         """Secure helper to read file as root."""
+        if sys.platform == 'sunos5':
+            return self._solarisiscsi.get_initiator()
+
         file_path = '/etc/iscsi/initiatorname.iscsi'
         try:
             lines, _err = self._execute('cat', file_path, run_as_root=True,
@@ -674,8 +695,11 @@ class FibreChannelConnector(InitiatorCon
                  execute=putils.execute, use_multipath=False,
                  device_scan_attempts=DEVICE_SCAN_ATTEMPTS_DEFAULT,
                  *args, **kwargs):
-        self._linuxscsi = linuxscsi.LinuxSCSI(root_helper, execute)
-        self._linuxfc = linuxfc.LinuxFibreChannel(root_helper, execute)
+        if sys.platform == 'sunos5':
+            self._solarisfc = solarisfc.SolarisFibreChannel()
+        else:
+            self._linuxscsi = linuxscsi.LinuxSCSI(root_helper, execute)
+            self._linuxfc = linuxfc.LinuxFibreChannel(root_helper, execute)
         super(FibreChannelConnector, self).__init__(root_helper, driver=driver,
                                                     execute=execute,
                                                     device_scan_attempts=
@@ -685,6 +709,8 @@ class FibreChannelConnector(InitiatorCon
 
     def set_execute(self, execute):
         super(FibreChannelConnector, self).set_execute(execute)
+        if sys.platform == 'sunos5':
+            return
         self._linuxscsi.set_execute(execute)
         self._linuxfc.set_execute(execute)
 
@@ -697,6 +723,10 @@ class FibreChannelConnector(InitiatorCon
         target_iqn - iSCSI Qualified Name
         target_lun - LUN id of the volume
         """
+        if sys.platform == 'sunos5':
+            return self._solarisfc.connect_volume(connection_properties,
+                                                  self.device_scan_attempts)
+
         LOG.debug("execute = %s" % self._execute)
         device_info = {'type': 'block'}
 
@@ -830,6 +860,13 @@ class FibreChannelConnector(InitiatorCon
         target_wwn - iSCSI Qualified Name
         target_lun - LUN id of the volume
         """
+        if sys.platform == 'sunos5':
+            # There is some latency before the next time connection happens.
+            # The best practice is to offline the state of the switch now
+            # and online it at the next connection.
+            # But now, we just return without any operation.
+            return
+
         devices = device_info['devices']
 
         # If this is a multipath device, we need to search again
--- cinder-2015.1.2/cinder/utils.py.~1~	2015-10-13 09:27:35.000000000 -0700
+++ cinder-2015.1.2/cinder/utils.py	2016-01-31 00:12:30.730160694 -0800
@@ -138,8 +138,12 @@ def check_exclusive_options(**kwargs):
 
 def execute(*cmd, **kwargs):
     """Convenience wrapper around oslo's execute() method."""
-    if 'run_as_root' in kwargs and 'root_helper' not in kwargs:
-        kwargs['root_helper'] = get_root_helper()
+    if sys.platform == 'sunos5':
+        if 'run_as_root' in kwargs:
+            kwargs['run_as_root'] = False
+    else:
+        if 'run_as_root' in kwargs and 'root_helper' not in kwargs:
+            kwargs['root_helper'] = get_root_helper()
     return processutils.execute(*cmd, **kwargs)
 
 
