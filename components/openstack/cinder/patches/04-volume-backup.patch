This patch is to replace the linux-specific codes with the solaris
codes to support the cinder backup on the Solaris.

--- cinder-2014.2.2/cinder/brick/initiator/connector.py.~1~	2015-02-05 08:03:26.000000000 -0800
+++ cinder-2014.2.2/cinder/brick/initiator/connector.py	2015-04-20 21:05:25.881159722 -0700
@@ -15,6 +15,7 @@
 
 import os
 import socket
+import sys
 import time
 
 from cinder.brick import exception
@@ -22,6 +23,8 @@
 from cinder.brick.initiator import host_driver
 from cinder.brick.initiator import linuxfc
 from cinder.brick.initiator import linuxscsi
+from cinder.brick.initiator import solarisfc
+from cinder.brick.initiator import solarisiscsi
 from cinder.brick.remotefs import remotefs
 from cinder.i18n import _
 from cinder.openstack.common import lockutils
@@ -39,7 +42,10 @@
     """Get the connection properties for all protocols."""
 
     iscsi = ISCSIConnector(root_helper=root_helper)
-    fc = linuxfc.LinuxFibreChannel(root_helper=root_helper)
+    if sys.platform == 'sunos5':
+        fc = solarisfc.SolarisFibreChannel()
+    else:
+        fc = linuxfc.LinuxFibreChannel(root_helper=root_helper)
 
     props = {}
     props['ip'] = my_ip
@@ -134,8 +140,11 @@
                'of=/dev/null', 'count=1')
         out, info = None, None
         try:
-            out, info = self._execute(*cmd, run_as_root=True,
-                                      root_helper=self._root_helper)
+            if sys.platform == 'sunos5':
+                out, info = self._execute(*cmd)
+            else:
+                out, info = self._execute(*cmd, run_as_root=True,
+                                          root_helper=self._root_helper)
         except putils.ProcessExecutionError as e:
             LOG.error(_("Failed to access the device on the path "
                         "%(path)s: %(error)s %(info)s.") %
@@ -171,7 +180,10 @@
                  execute=putils.execute, use_multipath=False,
                  device_scan_attempts=DEVICE_SCAN_ATTEMPTS_DEFAULT,
                  *args, **kwargs):
-        self._linuxscsi = linuxscsi.LinuxSCSI(root_helper, execute)
+        if sys.platform == 'sunos5':
+            self._solarisiscsi = solarisiscsi.SolarisiSCSI()
+        else:
+            self._linuxscsi = linuxscsi.LinuxSCSI(root_helper, execute)
         super(ISCSIConnector, self).__init__(root_helper, driver=driver,
                                              execute=execute,
                                              device_scan_attempts=
@@ -181,6 +193,8 @@
 
     def set_execute(self, execute):
         super(ISCSIConnector, self).set_execute(execute)
+        if sys.platform == 'sunos5':
+            return
         self._linuxscsi.set_execute(execute)
 
     @synchronized('connect_volume')
@@ -192,6 +206,9 @@
         target_iqn - iSCSI Qualified Name
         target_lun - LUN id of the volume
         """
+        if sys.platform == 'sunos5':
+            return self._solarisiscsi.connect_volume(connection_properties,
+                                                     self.device_scan_attempts)
 
         device_info = {'type': 'block'}
 
@@ -262,6 +279,9 @@
         target_iqn - iSCSI Qualified Name
         target_lun - LUN id of the volume
         """
+        if sys.platform == 'sunos5':
+            return
+
         # Moved _rescan_iscsi and _rescan_multipath
         # from _disconnect_volume_multipath_iscsi to here.
         # Otherwise, if we do rescan after _linuxscsi.remove_multipath_device
@@ -306,6 +326,9 @@
 
     def get_initiator(self):
         """Secure helper to read file as root."""
+        if sys.platform == 'sunos5':
+            return self._solarisiscsi.get_initiator()
+
         file_path = '/etc/iscsi/initiatorname.iscsi'
         try:
             lines, _err = self._execute('cat', file_path, run_as_root=True,
@@ -555,8 +578,11 @@
                  execute=putils.execute, use_multipath=False,
                  device_scan_attempts=DEVICE_SCAN_ATTEMPTS_DEFAULT,
                  *args, **kwargs):
-        self._linuxscsi = linuxscsi.LinuxSCSI(root_helper, execute)
-        self._linuxfc = linuxfc.LinuxFibreChannel(root_helper, execute)
+        if sys.platform == 'sunos5':
+            self._solarisfc = solarisfc.SolarisFibreChannel()
+        else:
+            self._linuxscsi = linuxscsi.LinuxSCSI(root_helper, execute)
+            self._linuxfc = linuxfc.LinuxFibreChannel(root_helper, execute)
         super(FibreChannelConnector, self).__init__(root_helper, driver=driver,
                                                     execute=execute,
                                                     device_scan_attempts=
@@ -566,6 +592,8 @@
 
     def set_execute(self, execute):
         super(FibreChannelConnector, self).set_execute(execute)
+        if sys.platform == 'sunos5':
+            return
         self._linuxscsi.set_execute(execute)
         self._linuxfc.set_execute(execute)
 
@@ -578,6 +606,10 @@
         target_iqn - iSCSI Qualified Name
         target_lun - LUN id of the volume
         """
+        if sys.platform == 'sunos5':
+            return self._solarisfc.connect_volume(connection_properties,
+                                                  self.device_scan_attempts)
+
         LOG.debug("execute = %s" % self._execute)
         device_info = {'type': 'block'}
 
@@ -686,6 +718,13 @@
         target_wwn - iSCSI Qualified Name
         target_lun - LUN id of the volume
         """
+        if sys.platform == 'sunos5':
+            # There is some latency before the next time connection happens.
+            # The best practice is to offline the state of the switch now
+            # and online it at the next connection.
+            # But now, we just return without any operation.
+            return
+
         devices = device_info['devices']
 
         # If this is a multipath device, we need to search again


--- cinder-2014.2.2/cinder/utils.py.~1~ 2015-02-05 08:03:26.000000000 -0800
+++ cinder-2014.2.2/cinder/utils.py     2015-04-20 20:46:27.658908715 -0700
@@ -137,8 +137,12 @@

 def execute(*cmd, **kwargs):
     """Convenience wrapper around oslo's execute() method."""
-    if 'run_as_root' in kwargs and 'root_helper' not in kwargs:
-        kwargs['root_helper'] = get_root_helper()
+    if sys.platform == 'sunos5':
+        if 'run_as_root' in kwargs:
+            kwargs['run_as_root'] = False
+    else:
+        if 'run_as_root' in kwargs and 'root_helper' not in kwargs:
+            kwargs['root_helper'] = get_root_helper()
     return processutils.execute(*cmd, **kwargs)


