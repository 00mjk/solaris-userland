Patches taken from:
https://github.com/django/django/commit/f4e6e02f7713a6924d16540be279909ff4091eb6

This is fixed in Django 1.8.11 and 1.9.4

--- Django-1.4.22/django/contrib/auth/hashers.py.orig    2016-03-09 20:03:40.232546554 -0800
+++ Django-1.4.22/django/contrib/auth/hashers.py  2016-03-09 20:12:45.684315031 -0800
@@ -1,4 +1,5 @@
 import hashlib
+import warnings

 from django.conf import settings
 from django.utils import importlib
@@ -47,8 +48,17 @@ def check_password(password, encoded, se
         algorithm = encoded.split('$', 1)[0]
         hasher = get_hasher(algorithm)

-    must_update = hasher.algorithm != preferred.algorithm
+    hasher_changed = hasher.algorithm != preferred.algorithm
+    must_update = hasher_changed or preferred.must_update(encoded)
     is_correct = hasher.verify(password, encoded)
+
+    # If the hasher didn't change (we don't protect against enumeration if it
+    # does) and the password should get updated, try to close the timing gap
+    # between the work factor of the current encoded password and the default
+    # work factor.
+    if not is_correct and not hasher_changed and must_update:
+        hasher.harden_runtime(password, encoded)
+
     if setter and is_correct and must_update:
         setter(raw_password)
     return is_correct
@@ -189,6 +199,22 @@ class BasePasswordHasher(object):
         """
         raise NotImplementedError()

+    def must_update(self, encoded):
+        return False
+
+    def harden_runtime(self, password, encoded):
+        """
+        Bridge the runtime gap between the work factor supplied in `encoded`
+        and the work factor suggested by this hasher.
+
+        Taking PBKDF2 as an example, if `encoded` contains 20000 iterations and
+        `self.iterations` is 30000, this method should run password through
+        another 10000 iterations of PBKDF2. Similar approaches should exist
+        for any hasher that has a work factor. If not, this method should be
+        defined as a no-op to silence the warning.
+        """
+        warnings.warn('subclasses of BasePasswordHasher should provide a harden_runtime() method')
+

 class PBKDF2PasswordHasher(BasePasswordHasher):
     """
@@ -227,6 +253,16 @@ class PBKDF2PasswordHasher(BasePasswordH
             (_('hash'), mask_hash(hash)),
         ])

+    def must_update(self, encoded):
+        algorithm, iterations, salt, hash = encoded.split('$', 3)
+        return int(iterations) != self.iterations
+
+    def harden_runtime(self, password, encoded):
+        algorithm, iterations, salt, hash = encoded.split('$', 3)
+        extra_iterations = self.iterations - int(iterations)
+        if extra_iterations > 0:
+            self.encode(password, salt, extra_iterations)
+

 class PBKDF2SHA1PasswordHasher(PBKDF2PasswordHasher):
     """
@@ -278,6 +314,10 @@ class BCryptPasswordHasher(BasePasswordH
             (_('checksum'), mask_hash(checksum)),
         ])

+    def harden_runtime(self, password, encoded):
+        pass
+
+

 class SHA1PasswordHasher(BasePasswordHasher):
     """
@@ -334,6 +374,9 @@ class MD5PasswordHasher(BasePasswordHash
             (_('hash'), mask_hash(hash)),
         ])

+    def harden_runtime(self, password, encoded):
+        pass
+

 class UnsaltedSHA1PasswordHasher(BasePasswordHasher):
     """
@@ -366,6 +409,9 @@ class UnsaltedSHA1PasswordHasher(BasePas
             (_('hash'), mask_hash(hash)),
         ])

+    def harden_runtime(self, password, encoded):
+        pass
+

 class UnsaltedMD5PasswordHasher(BasePasswordHasher):
     """
@@ -399,6 +445,9 @@ class UnsaltedMD5PasswordHasher(BasePass
             (_('hash'), mask_hash(encoded, show=3)),
         ])

+    def harden_runtime(self, password, encoded):
+        pass
+

 class CryptPasswordHasher(BasePasswordHasher):
     """
@@ -434,3 +483,5 @@ class CryptPasswordHasher(BasePasswordHa
             (_('hash'), mask_hash(data, show=3)),
         ])

+    def harden_runtime(self, password, encoded):
+        pass

--- Django-1.4.22/django/contrib/auth/tests/hashers.py.orig    2016-03-09 20:16:47.206793739 -0800
+++ Django-1.4.22/django/contrib/auth/tests/hashers.py  2016-03-09 20:22:16.148834976 -0800
@@ -6,6 +6,8 @@ from django.utils import unittest
 from django.utils.unittest import skipUnless
 from django.test.utils import override_settings

+import mock
+

 try:
     import crypt
@@ -150,3 +152,36 @@ class TestUtilsHashPass(unittest.TestCas
                 state['upgraded'] = True
             self.assertFalse(check_password('WRONG', encoded, setter))
             self.assertFalse(state['upgraded'])
+
+    def test_pbkdf2_harden_runtime(self):
+        hasher = get_hasher('default')
+        self.assertEqual('pbkdf2_sha256', hasher.algorithm)
+
+        with mock.patch.object(hasher, 'iterations', 1):
+            encoded = make_password('letmein')
+
+        with mock.patch.object(hasher, 'iterations', 6), \
+                mock.patch.object(hasher, 'encode', side_effect=hasher.encode):
+            hasher.harden_runtime('wrong_password', encoded)
+
+            # Encode should get called once ...
+            self.assertEqual(hasher.encode.call_count, 1)
+
+            # ... with the original salt and 5 iterations.
+            algorithm, iterations, salt, hash = encoded.split('$', 3)
+            expected_call = (('wrong_password', salt, 5),)
+            self.assertEqual(hasher.encode.call_args, expected_call)
+
+    def test_check_password_calls_harden_runtime(self):
+        hasher = get_hasher('default')
+        encoded = make_password('letmein')
+
+        with mock.patch.object(hasher, 'harden_runtime'), \
+                mock.patch.object(hasher, 'must_update', return_value=True):
+            # Correct password supplied, no hardening needed
+            check_password('letmein', encoded)
+            self.assertEqual(hasher.harden_runtime.call_count, 0)
+
+            # Wrong password supplied, hardening needed
+            check_password('wrong_password', encoded)
+            self.assertEqual(hasher.harden_runtime.call_count, 1)
