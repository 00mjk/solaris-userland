If getifaddrs blocks on a lock and a SIGALRM happens to fire while it
is block, it will return with EINTR. WE need to detect that and just
try again.

This is NTP bug 2565. Remove this patch when upgrading to a version that
has bug 2565 fixed in it.

--- lib/isc/unix/ifiter_getifaddrs.c
+++ lib/isc/unix/ifiter_getifaddrs.c
@@ -55,6 +55,8 @@ isc_interfaceiter_create(isc_mem_t *mctx
 	isc_interfaceiter_t *iter;
 	isc_result_t result;
 	char strbuf[ISC_STRERRORSIZE];
+	int trys;
+	int ret;
 
 	REQUIRE(mctx != NULL);
 	REQUIRE(iterp != NULL);
@@ -86,15 +88,21 @@ isc_interfaceiter_create(isc_mem_t *mctx
 	iter->valid = ISC_R_FAILURE;
 #endif
 
-	if (getifaddrs(&iter->ifaddrs) < 0) {
+	for (trys = 0; trys < 3; trys++) {
+		if ((ret = getifaddrs(&iter->ifaddrs)) >= 0)
+			break;
+		if (errno != EINTR) 
+			break;
+	}
+	if (ret < 0) {
 		isc__strerror(errno, strbuf, sizeof(strbuf));
 		UNEXPECTED_ERROR(__FILE__, __LINE__,
-				 isc_msgcat_get(isc_msgcat,
-						ISC_MSGSET_IFITERGETIFADDRS,
-						ISC_MSG_GETIFADDRS,
-						"getting interface "
-						"addresses: getifaddrs: %s"),
-				 strbuf);
+		    isc_msgcat_get(isc_msgcat,
+		    ISC_MSGSET_IFITERGETIFADDRS,
+		    ISC_MSG_GETIFADDRS,
+		    "getting interface "
+		    "addresses: getifaddrs: %s"),
+		    strbuf);
 		result = ISC_R_UNEXPECTED;
 		goto failure;
 	}
